---
---
<!doctype html>
<html lang="en">
<head>
<title>Gnome::Glib::Source</title>
<meta charset="UTF-8" />

<link href="asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />

</head>
	<body class="pod">
<header><img src="asset_files/images/gtk-raku.png" id="Camelia_bug"><h2 class="title" id="Gnome::Glib::Source">Gnome::Glib::Source</h2></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#Description">Description</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Synopsis">Synopsis</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Declaration">Declaration</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Types">Types</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#N-GSourceFuncs">N-GSourceFuncs</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#new">new</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#:idle">:idle</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#:timout">:timout</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#:native-object">:native-object</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-child-source">add-child-source</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-poll">add-poll</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-unix-fd">add-unix-fd</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#attach">attach</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#destroy">destroy</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#g-child-watch-add">g-child-watch-add</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#g-child-watch-add-full">g-child-watch-add-full</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#g-child-watch-source-new">g-child-watch-source-new</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#g-clear-handle-id">g-clear-handle-id</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#g-get-current-time">g-get-current-time</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-monotonic-time">get-monotonic-time</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-real-time">get-real-time</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-can-recurse">get-can-recurse</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-context">get-context</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-id">get-id</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-name">get-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-priority">get-priority</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-ready-time">get-ready-time</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-time">get-time</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#idle-add">idle-add</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#idle-add-full">idle-add-full</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#idle-remove-by-data">idle-remove-by-data</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#g-idle-source-new">g-idle-source-new</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#is-destroyed">is-destroyed</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#modify-unix-fd">modify-unix-fd</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#query-unix-fd">query-unix-fd</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#ref">ref</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove">remove</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-by-funcs-user-data">remove-by-funcs-user-data</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-by-user-data">remove-by-user-data</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-child-source">remove-child-source</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-poll">remove-poll</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-unix-fd">remove-unix-fd</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-callback">set-callback</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-callback-indirect">set-callback-indirect</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-can-recurse">set-can-recurse</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-funcs">set-funcs</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-name">set-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-name-by-id">set-name-by-id</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-priority">set-priority</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-ready-time">set-ready-time</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#timeout-add">timeout-add</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#timeout-add-full">timeout-add-full</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#timeout-add-seconds">timeout-add-seconds</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#timeout-add-seconds-full">timeout-add-seconds-full</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#g-timeout-source-new">g-timeout-source-new</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#g-timeout-source-new-seconds">g-timeout-source-new-seconds</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#unref">unref</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#_g_source_new">_g_source_new</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top"><p>manages all available sources of events</p>
<h1 id="Description"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">Description</a></h1>
<p>To get a bigger picture, you can read the description of class <strong>Gnome::Glib::MainContext</strong>.</p>
<h1 id="Synopsis"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">Synopsis</a></h1>

<h2 id="Declaration"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">Declaration</a></h2>
<pre class="pod-block-code">unit class Gnome::Glib::Source;
also is Gnome::N::TopLevelClassSupport;</pre>
<h1 id="Types"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">Types</a></h1>

<h2 id="N-GSourceFuncs"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">N-GSourceFuncs</a></h2>
<p>The <code>N-GSourceFuncs</code> struct contains a table of functions used to handle event sources in a generic manner.</p><p>For idle sources, the prepare and check functions always return TRUE to indicate that the source is always ready to be processed. The prepare function also returns a timeout value of 0 to ensure that the poll() call doesn't block (since that would be time wasted which could have been spent running the idle function).</p><p>For timeout sources, the prepare and check functions both return TRUE if the timeout interval has expired. The prepare function also returns a timeout value to ensure that the poll() call doesn't block too long and miss the next timeout.</p><p>For file descriptor sources, the prepare function typically returns FALSE, since it must wait until poll() has been called before it knows whether any events need to be processed. It sets the returned timeout to -1 to indicate that it doesn't mind how long the poll() call blocks. In the check function, it tests the results of the poll() call to see if the required condition has been met, and returns TRUE if so.</p><p>The structure of N-GSourceFuncs is</p><pre class="pod-block-code">class N-GSourceFuncs is repr('CStruct') {
  has Callable $.prepare ( N-GObject $source, gint $timeout --&gt; gboolean ) is rw;
  has Callable $.check ( N-GObject $source --&gt; gboolean ) is rw;
  has Callable $.dispatch (
  N-GObject source, GSourceFunc $callback, gpointer $user_data
  --&gt; gboolean
) is rw;
  has Callable $.finalize ( N-GObject $source) is rw;
};</pre><ul>
<li><p>function prepare</p></li>
</ul>
<p>Called before all the file descriptors are polled. If the source can determine that it is ready here (without waiting for the results of the poll() call) it should return TRUE. It can also return a timeout_ value which should be the maximum timeout (in milliseconds) which should be passed to the poll() call. The actual timeout used will be -1 if all sources returned -1, or it will be the minimum of all the timeout_ values returned which were &gt;= 0. Since 2.36 this may be NULL, in which case the effect is as if the function always returns FALSE with a timeout of -1. If prepare returns a timeout and the source also has a ready time set, then the lower of the two will be used.</p><pre class="pod-block-code">sub prepare ( N-GObject $source, gint $timeout --&gt; gboolean )</pre><ul>
<li><p>function check</p></li>
</ul>
<p>Called after all the file descriptors are polled. The source should return TRUE if it is ready to be dispatched. Note that some time may have passed since the previous prepare function was called, so the source should be checked again here. Since 2.36 this may be NULL, in which case the effect is as if the function always returns FALSE.</p><ul>
<li><p>function dispatch</p></li>
</ul>
<p>Called to dispatch the event source, after it has returned TRUE in either its prepare or its check function, or if a ready time has been reached. The dispatch function receives a callback function and user data. The callback function may be NULL if the source was never connected to a callback using g_source_set_callback(). The dispatch function should call the callback function with user_data and whatever additional parameters are needed for this type of event source. The return value of the dispatch function should be G_SOURCE_REMOVE if the source should be removed or G_SOURCE_CONTINUE to keep it.</p><ul>
<li><p>function finalize</p></li>
</ul>
<p>Called when the source is finalized. At this point, the source will have been destroyed, had its callback cleared, and have been removed from its GMainContext, but it will still have its final reference count, so methods can be called on it from within this function.</p>
<h1 id="Methods"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">Methods</a></h1>

<h2 id="new"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">new</a></h2>

<h3 id=":idle"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">:idle</a></h3>
<p>Create a new Source object to run processes in idle time. The source will not initially be associated with any <strong>Gnome::Glib::MainContext</strong> and must be added to one with <code>attach()</code> before it will be executed. Note that the default priority for idle sources is <code>G-PRIORITY-DEFAULT-IDLE</code>, as compared to other sources which have a default priority of <code>G-PRIORITY-DEFAULT</code>.</p><pre class="pod-block-code">multi method new ( :idle! )</pre>
<h3 id=":timout"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">:timout</a></h3>
<p>Creates a new timeout source. The source will not initially be associated with any <strong>Gnome::Glib::MainContext</strong> and must be added to one with <code>attach()</code> before it will be executed.</p><p>The interval given is in terms of monotonic time, not wall clock time. See <code>get-monotonic-time()</code>.</p><pre class="pod-block-code">multi method new ( Int :$timeout!, Bool :$seconds = False )</pre><ul>
<li><p>UInt $interval; the timeout interval in milliseconds.</p></li>
</ul>

<h3 id=":native-object"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">:native-object</a></h3>
<p>Create a Source object using a native object from elsewhere. See also <strong>Gnome::N::TopLevelClassSupport</strong>.</p><pre class="pod-block-code">multi method new ( N-GObject :$native-object! )</pre>
<h2 id="add-child-source"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">add-child-source</a></h2>
<p>Adds <em>child-source</em> to <em>source</em> as a &quot;polled&quot; source; when <em>source</em> is added to a <strong>Gnome::Glib::MainContext</strong>, <em>child-source</em> will be automatically added with the same priority, when <em>child-source</em> is triggered, it will cause <em>source</em> to dispatch (in addition to calling its own callback), and when <em>source</em> is destroyed, it will destroy <em>child-source</em> as well. (<em>source</em> will also still be dispatched if its own prepare/check functions indicate that it is ready.)</p><p>If you don't need <em>child-source</em> to do anything on its own when it triggers, you can call <code>set-dummy-callback()</code> on it to set a callback that does nothing (except return <code>True</code> if appropriate).</p><p><em>source</em> will hold a reference on <em>child-source</em> while <em>child-source</em> is attached to it.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><pre class="pod-block-code">method add-child-source ( N-GObject $child_source )</pre><ul>
<li><p>N-GObject $child_source; a second <strong>Gnome::Glib::Source</strong> that <em>source</em> should &quot;poll&quot;</p></li>
</ul>

<h2 id="add-poll"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">add-poll</a></h2>
<p>Adds a file descriptor to the set of file descriptors polled for this source. This is usually combined with <code>new()</code> to add an event source. The event source's check function will typically test the <em>revents</em> field in the <strong>Gnome::Glib::PollFD</strong> struct and return <code>True</code> if events need to be processed.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><p>Using this API forces the linear scanning of event sources on each main loop iteration. Newly-written event sources should try to use <code>g-source-add-unix-fd()</code> instead of this API.</p><pre class="pod-block-code">method add-poll ( GPollFD $fd )</pre><ul>
<li><p>GPollFD $fd; a <strong>Gnome::Glib::PollFD</strong> structure holding information about a file descriptor to watch.</p></li>
</ul>

<h2 id="add-unix-fd"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">add-unix-fd</a></h2>
<p>Monitors <em>fd</em> for the IO events in <em>events</em>.</p><p>The tag returned by this function can be used to remove or modify the monitoring of the fd using <code>remove-unix-fd()</code> or <code>g-source-modify-unix-fd()</code>.</p><p>It is not necessary to remove the fd before destroying the source; it will be cleaned up automatically.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><p>As the name suggests, this function is not available on Windows.</p><p>Returns: an opaque tag</p><pre class="pod-block-code">method add-unix-fd ( Int $fd, GIOCondition $events --&gt; Pointer )</pre><ul>
<li><p>Int $fd; the fd to monitor</p></li>
<li><p>GIOCondition $events; an event mask</p></li>
</ul>

<h2 id="attach"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">attach</a></h2>
<p>Adds a <strong>Gnome::Glib::Source</strong> to a <em>context</em> so that it will be executed within that context. Remove it by calling <code>destroy()</code>.</p><p>Returns: the ID (greater than 0) for the source within the <strong>Gnome::Glib::MainContext</strong>.</p><pre class="pod-block-code">method attach ( N-GObject $context --&gt; UInt )</pre><ul>
<li><p>N-GObject $context; a <strong>Gnome::Glib::MainContext</strong> (if <code>undefined</code>, the default context will be used)</p></li>
</ul>

<h2 id="destroy"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">destroy</a></h2>
<p>Removes a source from its <strong>Gnome::Glib::MainContext</strong>, if any, and mark it as destroyed. The source cannot be subsequently added to another context. It is safe to call this on sources which have already been removed from their context.</p><pre class="pod-block-code">method destroy ( )</pre>
<h2 id="g-child-watch-add"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">g-child-watch-add</a></h2>
<p>Sets a function to be called when the child indicated by <em>pid</em> exits, at a default priority, <code>G-PRIORITY-DEFAULT</code>.</p><p>If you obtain <em>pid</em> from <code>g-spawn-async()</code> or <code>g-spawn-async-with-pipes()</code> you will need to pass <strong>Gnome::Glib::-SPAWN-DO-NOT-REAP-CHILD</strong> as flag to the spawn function for the child watching to work.</p><p>Note that on platforms where <strong>Gnome::Glib::Pid</strong> must be explicitly closed (see <code>g-spawn-close-pid()</code>) <em>pid</em> must not be closed while the source is still active. Typically, you will want to call <code>g-spawn-close-pid()</code> in the callback function for the source.</p><p>GLib supports only a single callback per process id. On POSIX platforms, the same restrictions mentioned for <code>g-child-watch-source-new()</code> apply to this function.</p><p>This internally creates a main loop source using <code>g-child-watch-source-new()</code> and attaches it to the main loop context using <code>attach()</code>. You can do these steps manually if you need greater control.</p><p>Returns: the ID (greater than 0) of the event source.</p><pre class="pod-block-code">method g-child-watch-add ( GPid $pid, GChildWatchFunc $function, Pointer $data --&gt; UInt )</pre><ul>
<li><p>GPid $pid; process id to watch. On POSIX the positive pid of a child process. On Windows a handle for a process (which doesn't have to be a child).</p></li>
<li><p>GChildWatchFunc $function; function to call</p></li>
<li><p>Pointer $data; data to pass to <em>function</em></p></li>
</ul>

<h2 id="g-child-watch-add-full"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">g-child-watch-add-full</a></h2>
<p>Sets a function to be called when the child indicated by <em>pid</em> exits, at the priority <em>priority</em>.</p><p>If you obtain <em>pid</em> from <code>g-spawn-async()</code> or <code>g-spawn-async-with-pipes()</code> you will need to pass <strong>Gnome::Glib::-SPAWN-DO-NOT-REAP-CHILD</strong> as flag to the spawn function for the child watching to work.</p><p>In many programs, you will want to call <code>g-spawn-check-exit-status()</code> in the callback to determine whether or not the child exited successfully.</p><p>Also, note that on platforms where <strong>Gnome::Glib::Pid</strong> must be explicitly closed (see <code>g-spawn-close-pid()</code>) <em>pid</em> must not be closed while the source is still active. Typically, you should invoke <code>g-spawn-close-pid()</code> in the callback function for the source.</p><p>GLib supports only a single callback per process id. On POSIX platforms, the same restrictions mentioned for <code>g-child-watch-source-new()</code> apply to this function.</p><p>This internally creates a main loop source using <code>g-child-watch-source-new()</code> and attaches it to the main loop context using <code>attach()</code>. You can do these steps manually if you need greater control.</p><p>Returns: the ID (greater than 0) of the event source.</p><pre class="pod-block-code">method g-child-watch-add-full ( Int $priority, GPid $pid, GChildWatchFunc $function, Pointer $data, GDestroyNotify $notify --&gt; UInt )</pre><ul>
<li><p>Int $priority; the priority of the idle source. Typically this will be in the range between <code>G-PRIORITY-DEFAULT-IDLE</code> and <code>G-PRIORITY-HIGH-IDLE</code>.</p></li>
<li><p>GPid $pid; process to watch. On POSIX the positive pid of a child process. On Windows a handle for a process (which doesn't have to be a child).</p></li>
<li><p>GChildWatchFunc $function; function to call</p></li>
<li><p>Pointer $data; data to pass to <em>function</em></p></li>
<li><p>GDestroyNotify $notify; function to call when the idle is removed, or <code>undefined</code></p></li>
</ul>

<h2 id="g-child-watch-source-new"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">g-child-watch-source-new</a></h2>
<p>Creates a new child-watch source.</p><p>The source will not initially be associated with any <strong>Gnome::Glib::MainContext</strong> and must be added to one with <code>attach()</code> before it will be executed.</p><p>Note that child watch sources can only be used in conjunction with `g-spawn...` when the <code>G-SPAWN-DO-NOT-REAP-CHILD</code> flag is used.</p><p>Note that on platforms where <strong>Gnome::Glib::Pid</strong> must be explicitly closed (see <code>g-spawn-close-pid()</code>) <em>pid</em> must not be closed while the source is still active. Typically, you will want to call <code>g-spawn-close-pid()</code> in the callback function for the source.</p><p>On POSIX platforms, the following restrictions apply to this API due to limitations in POSIX process interfaces:</p><p>* <em>pid</em> must be a child of this process * <em>pid</em> must be positive * the application must not call `waitpid` with a non-positive first argument, for instance in another thread * the application must not wait for <em>pid</em> to exit by any other mechanism, including `waitpid(pid, ...)` or a second child-watch source for the same <em>pid</em> * the application must not ignore SIGCHILD</p><p>If any of those conditions are not met, this and related APIs will not work correctly. This can often be diagnosed via a GLib warning stating that `ECHILD` was received by `waitpid`.</p><p>Calling `waitpid` for specific processes other than <em>pid</em> remains a valid thing to do.</p><p>Returns: the newly-created child watch source</p><pre class="pod-block-code">method g-child-watch-source-new ( GPid $pid --&gt; N-GObject )</pre><ul>
<li><p>GPid $pid; process to watch. On POSIX the positive pid of a child process. On Windows a handle for a process (which doesn't have to be a child).</p></li>
</ul>

<h2 id="g-clear-handle-id"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">g-clear-handle-id</a></h2>
<p>Clears a numeric handler, such as a <strong>Gnome::Glib::Source</strong> ID.</p><p><em>tag-ptr</em> must be a valid pointer to the variable holding the handler.</p><p>If the ID is zero then this function does nothing. Otherwise, <code>clear-func()</code> is called with the ID as a parameter, and the tag is set to zero.</p><p>A macro is also included that allows this function to be used without pointer casts.</p><pre class="pod-block-code">method g-clear-handle-id ( guInt-ptr $tag_ptr, GClearHandleFunc $clear_func )</pre><ul>
<li><p>guInt-ptr $tag_ptr; a pointer to the handler ID</p></li>
<li><p>GClearHandleFunc $clear_func; the function to call to clear the handler</p></li>
</ul>

<h2 id="g-get-current-time"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">g-get-current-time</a></h2>
<p>Equivalent to the UNIX <code>gettimeofday()</code> function, but portable.</p><p>You may find <code>g-get-real-time()</code> to be more convenient.</p><pre class="pod-block-code">method g-get-current-time ( GTimeVal $result )</pre><ul>
<li><p>GTimeVal $result; <strong>Gnome::Glib::TimeVal</strong> structure in which to store current time.</p></li>
</ul>

<h2 id="get-monotonic-time"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-monotonic-time</a></h2>
<p>Queries the system monotonic time.</p><p>The monotonic clock will always increase and doesn't suffer discontinuities when the user (or NTP) changes the system time. It may or may not continue to tick during times where the machine is suspended.</p><p>We try to use the clock that corresponds as closely as possible to the passage of time as measured by system calls such as <code>poll()</code> but it may not always be possible to do this.</p><p>Returns: the monotonic time, in microseconds</p><pre class="pod-block-code">method get-monotonic-time ( --&gt; Int )</pre>
<h2 id="get-real-time"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-real-time</a></h2>
<p>Queries the system wall-clock time.</p><p>This call is functionally equivalent to <code>g-get-current-time()</code> except that the return value is often more convenient than dealing with a <strong>Gnome::Glib::TimeVal</strong>.</p><p>You should only use this call if you are actually interested in the real wall-clock time. <code>g-get-monotonic-time()</code> is probably more useful for measuring intervals.</p><p>Returns: the number of microseconds since January 1, 1970 UTC.</p><pre class="pod-block-code">method get-real-time ( --&gt; Int )</pre>
<h2 id="get-can-recurse"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-can-recurse</a></h2>
<p>Checks whether a source is allowed to be called recursively. see <code>set-can-recurse()</code>.</p><p>Returns: whether recursion is allowed.</p><pre class="pod-block-code">method get-can-recurse ( --&gt; Bool )</pre>
<h2 id="get-context"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-context</a></h2>
<p>Gets the <strong>Gnome::Glib::MainContext</strong> with which the source is associated.</p><p>You can call this on a source that has been destroyed, provided that the <strong>Gnome::Glib::MainContext</strong> it was attached to still exists (in which case it will return that <strong>Gnome::Glib::MainContext</strong>). In particular, you can always call this function on the source returned from <code>g-main-current-source()</code>. But calling this function on a source whose <strong>Gnome::Glib::MainContext</strong> has been destroyed is an error.</p><p>Returns: the <strong>Gnome::Glib::MainContext</strong> with which the source is associated, or <code>undefined</code> if the context has not yet been added to a source.</p><pre class="pod-block-code">method get-context ( --&gt; N-GObject )</pre>
<h2 id="get-id"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-id</a></h2>
<p>Returns the numeric ID for a particular source. The ID of a source is a positive integer which is unique within a particular main loop context. The reverse mapping from ID to source is done by <code>g-main-context-find-source-by-id()</code>.</p><p>You can only call this function while the source is associated to a <strong>Gnome::Glib::MainContext</strong> instance; calling this function before <code>attach()</code> or after <code>g-source-destroy()</code> yields undefined behavior. The ID returned is unique within the <strong>Gnome::Glib::MainContext</strong> instance passed to <code>g-source-attach()</code>.</p><p>Returns: the ID (greater than 0) for the source</p><pre class="pod-block-code">method get-id ( --&gt; UInt )</pre>
<h2 id="get-name"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-name</a></h2>
<p>Gets a name for the source, used in debugging and profiling. The name may be <strong>NULL</strong> if it has never been set with <code>set-name()</code>.</p><p>Returns: the name of the source</p><pre class="pod-block-code">method get-name ( --&gt; Str )</pre>
<h2 id="get-priority"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-priority</a></h2>
<p>Gets the priority of a source.</p><p>Returns: the priority of the source</p><pre class="pod-block-code">method get-priority ( --&gt; Int )</pre>
<h2 id="get-ready-time"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-ready-time</a></h2>
<p>Gets the &quot;ready time&quot; of <em>source</em>, as set by <code>set-ready-time()</code>.</p><p>Any time before the current monotonic time (including 0) is an indication that the source will fire immediately.</p><p>Returns: the monotonic ready time, -1 for &quot;never&quot;</p><pre class="pod-block-code">method get-ready-time ( --&gt; Int )</pre>
<h2 id="get-time"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">get-time</a></h2>
<p>Gets the time to be used when checking this source. The advantage of calling this function over calling <code>g-get-monotonic-time()</code> directly is that when checking multiple sources, GLib can cache a single value instead of having to repeatedly get the system monotonic time.</p><p>The time here is the system monotonic time, if available, or some other reasonable alternative otherwise. See <code>g-get-monotonic-time()</code>.</p><p>Returns: the monotonic time in microseconds</p><pre class="pod-block-code">method get-time ( --&gt; Int )</pre>
<h2 id="idle-add"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">idle-add</a></h2>
<p>Adds a function to be called whenever there are no higher priority events pending to the default main loop. The function is given the default idle priority, <code>G-PRIORITY-DEFAULT-IDLE</code>. If the function returns <code>False</code> it is automatically removed from the list of event sources and will not be called again.</p><p>This internally creates a main loop source using <code>g-idle-source-new()</code> and attaches it to the global <strong>Gnome::Glib::MainContext</strong> using <code>attach()</code>, so the callback will be invoked in whichever thread is running that main context. You can do these steps manually if you need greater control or to use a custom main context.</p><p>Returns: the ID (greater than 0) of the event source.</p><pre class="pod-block-code">method idle-add (
  Any:D $handler-object, Str:D $method, *%user-options
  --&gt; UInt
)</pre><ul>
<li><p>$handler-object; User object where $method is defined</p></li>
<li><p>Str $method; name of callback handler</p></li>
<li><p>%user-options; optional named arguments to be provided to the callback</p></li>
</ul>

<h2 id="idle-add-full"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">idle-add-full</a></h2>
<p>Adds a function to be called whenever there are no higher priority events pending. If the function returns <code>False</code> it is automatically removed from the list of event sources and will not be called again.</p><p>This internally creates a main loop source using <code>g-idle-source-new()</code> and attaches it to the global <strong>Gnome::Glib::MainContext</strong> using <code>attach()</code>, so the callback will be invoked in whichever thread is running that main context. You can do these steps manually if you need greater control or to use a custom main context.</p><p>Returns: the ID (greater than 0) of the event source.</p><pre class="pod-block-code">method idle-add-full (
  Int $priority,
  Any:D $handler-object, Str:D $method, Str $method-notify = Str,
  *%user-options
  --&gt; UInt
)</pre><ul>
<li><p>Int $priority; the priority of the idle source. Typically this will be in the range between <code>G-PRIORITY-DEFAULT-IDLE</code> and <code>G-PRIORITY-HIGH-IDLE</code>.</p></li>
<li><p>$handler-object; User object where both methods are defined</p></li>
<li><p>Str $method; name of callback handler</p></li>
<li><p>Str $method-notify; name of callback handler. Ignored when $method-notify is undefined. This function is called when the source is removed.</p></li>
<li><p>%user-options; optional named arguments to be provided to both callbacks</p></li>
</ul>

<h2 id="idle-remove-by-data"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">idle-remove-by-data</a></h2>
<p>Removes the idle function with the given data.</p><p>Returns: <code>True</code> if an idle source was found and removed.</p><pre class="pod-block-code">method idle-remove-by-data ( Pointer $data --&gt; Bool )</pre><ul>
<li><p>Pointer $data; the data for the idle source's callback.</p></li>
</ul>

<h2 id="g-idle-source-new"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">g-idle-source-new</a></h2>
<p>Creates a new idle source.</p><p>The source will not initially be associated with any <strong>Gnome::Glib::MainContext</strong> and must be added to one with <code>attach()</code> before it will be executed. Note that the default priority for idle sources is <code>G-PRIORITY-DEFAULT-IDLE</code>, as compared to other sources which have a default priority of <code>G-PRIORITY-DEFAULT</code>.</p><p>Returns: the newly-created idle source</p><pre class="pod-block-code">method g-idle-source-new ( --&gt; N-GObject )</pre>
<h2 id="is-destroyed"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">is-destroyed</a></h2>
<p>Returns whether <em>source</em> has been destroyed.</p><p>This is important when you operate upon your objects from within idle handlers, but may have freed the object before the dispatch of your idle handler.</p><p>This will fail in a multi-threaded application if the widget is destroyed before the idle handler fires due to the use after free in the callback. A solution, to this particular problem, is to check to if the source has already been destroy within the callback.</p><p>Calls to this function from a thread other than the one acquired by the <strong>Gnome::Glib::MainContext</strong> the <strong>Gnome::Glib::Source</strong> is attached to are typically redundant, as the source could be destroyed immediately after this function returns. However, once a source is destroyed it cannot be un-destroyed, so this function can be used for opportunistic checks from any thread.</p><p>Returns: <code>True</code> if the source has been destroyed</p><pre class="pod-block-code">method is-destroyed ( --&gt; Bool )</pre>
<h2 id="modify-unix-fd"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">modify-unix-fd</a></h2>
<p>Updates the event mask to watch for the fd identified by <em>tag</em>.</p><p><em>tag</em> is the tag returned from <code>add-unix-fd()</code>.</p><p>If you want to remove a fd, don't set its event mask to zero. Instead, call <code>g-source-remove-unix-fd()</code>.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><p>As the name suggests, this function is not available on Windows.</p><pre class="pod-block-code">method modify-unix-fd ( Pointer $tag, GIOCondition $new_events )</pre><ul>
<li><p>Pointer $tag; the tag from <code>add-unix-fd()</code></p></li>
<li><p>GIOCondition $new_events; the new event mask to watch</p></li>
</ul>

<h2 id="query-unix-fd"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">query-unix-fd</a></h2>
<p>Queries the events reported for the fd corresponding to <em>tag</em> on <em>source</em> during the last poll.</p><p>The return value of this function is only defined when the function is called from the check or dispatch functions for <em>source</em>.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><p>As the name suggests, this function is not available on Windows.</p><p>Returns: the conditions reported on the fd</p><pre class="pod-block-code">method query-unix-fd ( Pointer $tag --&gt; GIOCondition )</pre><ul>
<li><p>Pointer $tag; the tag from <code>add-unix-fd()</code></p></li>
</ul>

<h2 id="ref"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">ref</a></h2>
<p>Increases the reference count on a source by one.</p><p>Returns: <em>source</em></p><pre class="pod-block-code">method ref ( --&gt; N-GObject )</pre>
<h2 id="remove"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">remove</a></h2>
<p>Removes the source with the given ID from the default main context. You must use <code>destroy()</code> for sources added to a non-default main context.</p><p>The ID of a <strong>Gnome::Glib::Source</strong> is given by <code>g-source-get-id()</code>, or will be returned by the functions <code>g-source-attach()</code>, <code>g-idle-add()</code>, <code>g-idle-add-full()</code>, <code>g-timeout-add()</code>, <code>g-timeout-add-full()</code>, <code>g-child-watch-add()</code>, <code>g-child-watch-add-full()</code>, <code>g-io-add-watch()</code>, and <code>g-io-add-watch-full()</code>.</p><p>It is a programmer error to attempt to remove a non-existent source.</p><p>More specifically: source IDs can be reissued after a source has been destroyed and therefore it is never valid to use this function with a source ID which may have already been removed. An example is when scheduling an idle to run in another thread with <code>g-idle-add()</code>: the idle may already have run and been removed by the time this function is called on its (now invalid) source ID. This source ID may have been reissued, leading to the operation being performed against the wrong source.</p><p>Returns: For historical reasons, this function always returns <code>True</code></p><pre class="pod-block-code">method remove ( UInt $tag --&gt; Bool )</pre><ul>
<li><p>UInt $tag; the ID of the source to remove.</p></li>
</ul>

<h2 id="remove-by-funcs-user-data"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">remove-by-funcs-user-data</a></h2>
<p>Removes a source from the default main loop context given the source functions and user data. If multiple sources exist with the same source functions and user data, only one will be destroyed.</p><p>Returns: <code>True</code> if a source was found and removed.</p><pre class="pod-block-code">method remove-by-funcs-user-data ( N-GSourceFuncs $funcs, Pointer $user_data --&gt; Bool )</pre><ul>
<li><p>N-GSourceFuncs $funcs; The <em>source-funcs</em> passed to <code>new()</code></p></li>
<li><p>Pointer $user_data; the user data for the callback</p></li>
</ul>

<h2 id="remove-by-user-data"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">remove-by-user-data</a></h2>
<p>Removes a source from the default main loop context given the user data for the callback. If multiple sources exist with the same user data, only one will be destroyed.</p><p>Returns: <code>True</code> if a source was found and removed.</p><pre class="pod-block-code">method remove-by-user-data ( Pointer $user_data --&gt; Bool )</pre><ul>
<li><p>Pointer $user_data; the user-data for the callback.</p></li>
</ul>

<h2 id="remove-child-source"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">remove-child-source</a></h2>
<p>Detaches <em>child-source</em> from <em>source</em> and destroys it.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><pre class="pod-block-code">method remove-child-source ( N-GObject $child_source )</pre><ul>
<li><p>N-GObject $child_source; a <strong>Gnome::Glib::Source</strong> previously passed to <code>add-child-source()</code>.</p></li>
</ul>

<h2 id="remove-poll"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">remove-poll</a></h2>
<p>Removes a file descriptor from the set of file descriptors polled for this source.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><pre class="pod-block-code">method remove-poll ( GPollFD $fd )</pre><ul>
<li><p>GPollFD $fd; a <strong>Gnome::Glib::PollFD</strong> structure previously passed to <code>add-poll()</code>.</p></li>
</ul>

<h2 id="remove-unix-fd"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">remove-unix-fd</a></h2>
<p>Reverses the effect of a previous call to <code>add-unix-fd()</code>.</p><p>You only need to call this if you want to remove an fd from being watched while keeping the same source around. In the normal case you will just want to destroy the source.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><p>As the name suggests, this function is not available on Windows.</p><pre class="pod-block-code">method remove-unix-fd ( Pointer $tag )</pre><ul>
<li><p>Pointer $tag; the tag from <code>add-unix-fd()</code></p></li>
</ul>

<h2 id="set-callback"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">set-callback</a></h2>
<p>Sets the callback function for a source. The callback for a source is called from the source's dispatch function.</p><p>Typically, you won't use this function. Instead use functions specific to the type of source you are using, such as <code>g-idle-add()</code> or <code>g-timeout-add()</code>.</p><p>It is safe to call this function multiple times on a source which has already been attached to a context. The changes will take effect for the next time the source is dispatched after this call returns.</p><pre class="pod-block-code">method set-callback (
  Any:D $handler-object, Str:D $method, Str $method-notify = Str,
  *%user-options
)</pre><ul>
<li><p>$handler-object; User object where both methods are defined</p></li>
<li><p>Str $method; name of callback handler</p></li>
<li><p>Str $method-notify; name of callback handler. Ignored when $method-notify is undefined. This function is called when the source is removed.</p></li>
<li><p>%user-options; optional named arguments to be provided to both callbacks</p></li>
</ul>

<h2 id="set-callback-indirect"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">set-callback-indirect</a></h2>
<p>Sets the callback function storing the data as a refcounted callback &quot;object&quot;. This is used internally. Note that calling <code>set-callback-indirect()</code> assumes an initial reference count on <em>callback-data</em>, and thus <em>callback-funcs</em>-&gt;unref will eventually be called once more than <em>callback-funcs</em>-&gt;ref.</p><p>It is safe to call this function multiple times on a source which has already been attached to a context. The changes will take effect for the next time the source is dispatched after this call returns.</p><pre class="pod-block-code">method set-callback-indirect ( Pointer $callback_data, N-GObjectCallbackFuncs $callback_funcs )</pre><ul>
<li><p>Pointer $callback_data; pointer to callback data &quot;object&quot;</p></li>
<li><p>N-GObjectCallbackFuncs $callback_funcs; functions for reference counting <em>callback-data</em> and getting the callback and data</p></li>
</ul>

<h2 id="set-can-recurse"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">set-can-recurse</a></h2>
<p>Sets whether a source can be called recursively. If <em>can-recurse</em> is <code>True</code>, then while the source is being dispatched then this source will be processed normally. Otherwise, all processing of this source is blocked until the dispatch function returns.</p><pre class="pod-block-code">method set-can-recurse ( Bool $can_recurse )</pre><ul>
<li><p>Bool $can_recurse; whether recursion is allowed for this source</p></li>
</ul>

<h2 id="set-funcs"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">set-funcs</a></h2>
<p>Sets the source functions (can be used to override default implementations) of an unattached source.</p><pre class="pod-block-code">method set-funcs ( N-GSourceFuncs $funcs )</pre><ul>
<li><p>N-GSourceFuncs $funcs; the new <strong>Gnome::Glib::SourceFuncs</strong></p></li>
</ul>

<h2 id="set-name"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">set-name</a></h2>
<p>Sets a name for the source, used in debugging and profiling. The name defaults to <strong>NULL</strong>.</p><p>The source name should describe in a human-readable way what the source does. For example, &quot;X11 event queue&quot; or &quot;GTK+ repaint idle handler&quot; or whatever it is.</p><p>It is permitted to call this function multiple times, but is not recommended due to the potential performance impact. For example, one could change the name in the &quot;check&quot; function of a <strong>Gnome::Glib::SourceFuncs</strong> to include details like the event type in the source name.</p><p>Use caution if changing the name while another thread may be accessing it with <code>get-name()</code>; that function does not copy the value, and changing the value will free it while the other thread may be attempting to use it.</p><pre class="pod-block-code">method set-name ( Str $name )</pre><ul>
<li><p>Str $name; debug name for the source</p></li>
</ul>

<h2 id="set-name-by-id"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">set-name-by-id</a></h2>
<p>Sets the name of a source using its ID.</p><p>This is a convenience utility to set source names from the return value of <code>g-idle-add()</code>, <code>timeout-add()</code>, etc.</p><p>It is a programmer error to attempt to set the name of a non-existent source.</p><p>More specifically: source IDs can be reissued after a source has been destroyed and therefore it is never valid to use this function with a source ID which may have already been removed. An example is when scheduling an idle to run in another thread with <code>g-idle-add()</code>: the idle may already have run and been removed by the time this function is called on its (now invalid) source ID. This source ID may have been reissued, leading to the operation being performed against the wrong source.</p><pre class="pod-block-code">method set-name-by-id ( UInt $tag, Str $name )</pre><ul>
<li><p>UInt $tag; a <strong>Gnome::Glib::Source</strong> ID</p></li>
<li><p>Str $name; debug name for the source</p></li>
</ul>

<h2 id="set-priority"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">set-priority</a></h2>
<p>Sets the priority of a source. While the main loop is being run, a source will be dispatched if it is ready to be dispatched and no sources at a higher (numerically smaller) priority are ready to be dispatched.</p><p>A child source always has the same priority as its parent. It is not permitted to change the priority of a source once it has been added as a child of another source.</p><pre class="pod-block-code">method set-priority ( Int $priority )</pre><ul>
<li><p>Int $priority; the new priority.</p></li>
</ul>

<h2 id="set-ready-time"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">set-ready-time</a></h2>
<p>Sets a <strong>Gnome::Glib::Source</strong> to be dispatched when the given monotonic time is reached (or passed). If the monotonic time is in the past (as it always will be if <em>ready-time</em> is 0) then the source will be dispatched immediately.</p><p>If <em>ready-time</em> is -1 then the source is never woken up on the basis of the passage of time.</p><p>Dispatching the source does not reset the ready time. You should do so yourself, from the source dispatch function.</p><p>Note that if you have a pair of sources where the ready time of one suggests that it will be delivered first but the priority for the other suggests that it would be delivered first, and the ready time for both sources is reached during the same main context iteration, then the order of dispatch is undefined.</p><p>It is a no-op to call this function on a <strong>Gnome::Glib::Source</strong> which has already been destroyed with <code>destroy()</code>.</p><p>This API is only intended to be used by implementations of <strong>Gnome::Glib::Source</strong>. Do not call this API on a <strong>Gnome::Glib::Source</strong> that you did not create.</p><pre class="pod-block-code">method set-ready-time ( Int $ready_time )</pre><ul>
<li><p>Int $ready_time; the monotonic time at which the source will be ready, 0 for &quot;immediately&quot;, -1 for &quot;never&quot;</p></li>
</ul>

<h2 id="timeout-add"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">timeout-add</a></h2>
<p>Sets a function to be called at regular intervals, with the default priority, <code>G-PRIORITY-DEFAULT</code>. The function is called repeatedly until it returns <code>False</code>, at which point the timeout is automatically destroyed and the function will not be called again. The first call to the function will be at the end of the first <em>$interval</em>.</p><p>Note that timeout functions may be delayed, due to the processing of other event sources. Thus they should not be relied on for precise timing. After each call to the timeout function, the time of the next timeout is recalculated based on the current time and the given interval (it does not try to 'catch up' time lost in delays).</p><p>If you want to have a timer in the &quot;seconds&quot; range and do not care about the exact time of the first call of the timer, use the <code>timeout-add-seconds()</code> function; this function allows for more optimizations and more efficient system power usage.</p><p>The interval given is in terms of monotonic time, not wall clock time. See <code>get-monotonic-time()</code>.</p><p>Returns: the ID (greater than 0) of the event source.</p><pre class="pod-block-code">method timeout-add (
  UInt $interval,
  Any:D $handler-object, Str:D $method, *%user-options
  --&gt; UInt
)</pre><ul>
<li><p>UInt $interval; the time between calls to the function, in milliseconds (1/1000ths of a second)</p></li>
<li><p>$handler-object; User object where $method is defined</p></li>
<li><p>Str $method; name of callback handler</p></li>
<li><p>%user-options; optional named arguments to be provided to the callback</p></li>
</ul>

<h2 id="timeout-add-full"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">timeout-add-full</a></h2>
<p>Sets a function to be called at regular intervals, with the given priority. The function is called repeatedly until it returns <code>False</code>, at which point the timeout is automatically destroyed and the function will not be called again. The <em>notify</em> function is called when the timeout is destroyed. The first call to the function will be at the end of the first <em>interval</em>.</p><p>Note that timeout functions may be delayed, due to the processing of other event sources. Thus they should not be relied on for precise timing. After each call to the timeout function, the time of the next timeout is recalculated based on the current time and the given interval (it does not try to 'catch up' time lost in delays).</p><p>This internally creates a main loop source using <code>g-timeout-source-new()</code> and attaches it to the global <strong>Gnome::Glib::MainContext</strong> using <code>attach()</code>, so the callback will be invoked in whichever thread is running that main context. You can do these steps manually if you need greater control or to use a custom main context.</p><p>The interval given is in terms of monotonic time, not wall clock time. See <code>g-get-monotonic-time()</code>.</p><p>Returns: the ID (greater than 0) of the event source.</p><pre class="pod-block-code">method timeout-add-full (
  Int $priority, UInt $interval,
  Any:D $handler-object, Str:D $method, Str $method-notify = Str,
  *%user-options
  --&gt; UInt
)</pre><ul>
<li><p>Int $priority; the priority of the timeout source. Typically this will be in the range between <code>G-PRIORITY-DEFAULT</code> and <code>G-PRIORITY-HIGH</code>.</p></li>
<li><p>UInt $interval; the time between calls to the function, in milliseconds (1/1000ths of a second)</p></li>
<li><p>$handler-object; User object where both methods are defined</p></li>
<li><p>Str $method; name of callback handler</p></li>
<li><p>Str $method-notify; name of callback handler. Ignored when $method-notify is undefined. This function is called when the source is removed.</p></li>
<li><p>%user-options; optional named arguments to be provided to both callbacks</p></li>
</ul>

<h2 id="timeout-add-seconds"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">timeout-add-seconds</a></h2>
<p>Sets a function to be called at regular intervals with the default priority, <code>G-PRIORITY-DEFAULT</code>. The function is called repeatedly until it returns <code>False</code>, at which point the timeout is automatically destroyed and the function will not be called again.</p><p>This internally creates a main loop source using <code>g-timeout-source-new-seconds()</code> and attaches it to the main loop context using <code>attach()</code>. You can do these steps manually if you need greater control. Also see <code>timeout-add-seconds-full()</code>.</p><p>Note that the first call of the timer may not be precise for timeouts of one second. If you need finer precision and have such a timeout, you may want to use <code>timeout-add()</code> instead.</p><p>The interval given is in terms of monotonic time, not wall clock time. See <code>g-get-monotonic-time()</code>.</p><p>Returns: the ID (greater than 0) of the event source.</p><pre class="pod-block-code">method timeout-add-seconds (
  UInt $interval, Any:D $handler-object, Str:D $method, *%user-options
  --&gt; UInt
)</pre><ul>
<li><p>UInt $interval; the time between calls to the function, in seconds</p></li>
<li><p>$handler-object; User object where $method is defined</p></li>
<li><p>Str $method; name of callback handler</p></li>
<li><p>%user-options; optional named arguments to be provided to the callback</p></li>
</ul>

<h2 id="timeout-add-seconds-full"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">timeout-add-seconds-full</a></h2>
<p>Sets a function to be called at regular intervals, with <em>priority</em>. The function is called repeatedly until it returns <code>False</code>, at which point the timeout is automatically destroyed and the function will not be called again.</p><p>Unlike <code>timeout-add()</code>, this function operates at whole second granularity. The initial starting point of the timer is determined by the implementation and the implementation is expected to group multiple timers together so that they fire all at the same time. To allow this grouping, the <em>$interval</em> to the first timer is rounded and can deviate up to one second from the specified interval. Subsequent timer iterations will generally run at the specified interval.</p><p>Note that timeout functions may be delayed, due to the processing of other event sources. Thus they should not be relied on for precise timing. After each call to the timeout function, the time of the next timeout is recalculated based on the current time and the given <em>$interval</em></p><p>If you want timing more precise than whole seconds, use <code>timeout-add()</code> instead.</p><p>The grouping of timers to fire at the same time results in a more power and CPU efficient behavior so if your timer is in multiples of seconds and you don't require the first timer exactly one second from now, the use of <code>timeout-add-seconds()</code> is preferred over <code>timeout-add()</code>.</p><p>This internally creates a main loop source using <code>timeout-source-new-seconds()</code> and attaches it to the main loop context using <code>attach()</code>. You can do these steps manually if you need greater control.</p><p>The interval given is in terms of monotonic time, not wall clock time. See <code>get-monotonic-time()</code>.</p><p>Returns: the ID (greater than 0) of the event source.</p><pre class="pod-block-code">method timeout-add-seconds-full (
  Int $priority, UInt $interval,
  Any:D $handler-object, Str:D $method, Str $method-notify = Str,
  *%user-options
  --&gt; UInt
)</pre><ul>
<li><p>Int $priority; the priority of the timeout source. Typically this will be in the range between <code>G-PRIORITY-DEFAULT</code> and <code>G-PRIORITY-HIGH</code>.</p></li>
<li><p>UInt $interval; the time between calls to the function, in seconds</p></li>
<li><p>$handler-object; User object where both methods are defined</p></li>
<li><p>Str $method; name of callback handler</p></li>
<li><p>Str $method-notify; name of callback handler. Ignored when $method-notify is undefined. This function is called when the source is removed.</p></li>
<li><p>%user-options; optional named arguments to be provided to both callbacks</p></li>
</ul>

<h2 id="g-timeout-source-new"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">g-timeout-source-new</a></h2>
<p>Creates a new timeout source.</p><p>The source will not initially be associated with any <strong>Gnome::Glib::MainContext</strong> and must be added to one with <code>attach()</code> before it will be executed.</p><p>The interval given is in terms of monotonic time, not wall clock time. See <code>g-get-monotonic-time()</code>.</p><p>Returns: the newly-created timeout source</p><pre class="pod-block-code">method g-timeout-source-new ( UInt $interval --&gt; N-GObject )</pre><ul>
<li><p>UInt $interval; the timeout interval in milliseconds.</p></li>
</ul>

<h2 id="g-timeout-source-new-seconds"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">g-timeout-source-new-seconds</a></h2>
<p>Creates a new timeout source.</p><p>The source will not initially be associated with any <strong>Gnome::Glib::MainContext</strong> and must be added to one with <code>attach()</code> before it will be executed.</p><p>The scheduling granularity/accuracy of this timeout source will be in seconds.</p><p>The interval given is in terms of monotonic time, not wall clock time. See <code>g-get-monotonic-time()</code>.</p><p>Returns: the newly-created timeout source</p><pre class="pod-block-code">method g-timeout-source-new-seconds ( UInt $interval --&gt; N-GObject )</pre><ul>
<li><p>UInt $interval; the timeout interval in seconds</p></li>
</ul>

<h2 id="unref"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">unref</a></h2>
<p>Decreases the reference count of a source by one. If the resulting reference count is zero the source and associated memory will be destroyed.</p><pre class="pod-block-code">method unref ( )</pre>
<h2 id="_g_source_new"><a href="#Gnome::Glib::Source" class="u" title="go to top of document">_g_source_new</a></h2>
<p>Creates a new <strong>Gnome::Glib::Source</strong> structure. The size is specified to allow creating structures derived from <strong>Gnome::Glib::Source</strong> that contain additional data. The size passed in must be at least `sizeof (N-GObject)`.</p><p>The source will not initially be associated with any <strong>Gnome::Glib::MainContext</strong> and must be added to one with <code>attach()</code> before it will be executed.</p><p>Returns: the newly-created <strong>Gnome::Glib::Source</strong>.</p><pre class="pod-block-code">method _g_source_new ( N-GSourceFuncs $source_funcs, UInt $struct_size --&gt; N-GObject )</pre><ul>
<li><p>N-GSourceFuncs $source_funcs; structure containing functions that implement the sources behavior.</p></li>
<li><p>UInt $struct_size; size of the <strong>Gnome::Glib::Source</strong> structure to create.</p></li>
</ul>
</section>		</div>
</div><footer><div>Rendered from <span class="path">/home/marcel/Languages/Raku/Projects/gnome-api1/gnome-glib/lib/Gnome/Glib/Source.rakumod</span></div><div>at <span class="time">2025-07-20T17:01:55Z</span></div></footer>
	</body>
</html>
