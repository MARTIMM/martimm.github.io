---
---
<!doctype html>
<html lang="en">
<head>
<title>Gnome::Glib::List</title>
<meta charset="UTF-8" />

<link href="asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />

</head>
	<body class="pod">
<header><img src="asset_files/images/gtk-raku.png" id="Camelia_bug"><h2 class="title" id="Gnome::Glib::List">Gnome::Glib::List</h2></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#Description">Description</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Synopsis">Synopsis</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Declaration">Declaration</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Uml_Diagram">Uml Diagram</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#"></a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Example_1,_a_while_loop_to_visit_all_widgets_in_a_grid">Example 1, a while loop to visit all widgets in a grid</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Example_2,_using_foreach()_to_visit_all_items_in_the_list">Example 2, using foreach() to visit all items in the list</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Types">Types</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class_N-GList">class N-GList</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#new">new</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Default,_no_options">Default, no options</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#:native-object">:native-object</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[g_]_list_free">[g_] list_free</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#alloc">alloc</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#append">append</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Example">Example</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#concat">concat</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#copy">copy</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#copy-deep">copy-deep</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#data">data</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#delete-link">delete-link</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#find">find</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#find-custom">find-custom</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#first">first</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#foreach">foreach</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#free1">free1</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#free-full">free-full</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#index">index</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#insert">insert</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#insert-before">insert-before</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#insert-sorted">insert-sorted</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#insert-sorted-with-data">insert-sorted-with-data</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#last">last</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#length">length</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#next">next</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#nth">nth</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#nth-data">nth-data</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#nth-prev">nth-prev</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#position">position</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#prepend">prepend</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Example_0">Example</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#previous">previous</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove">remove</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-all">remove-all</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-link">remove-link</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#reverse">reverse</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#sort">sort</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#sort-with-data">sort-with-data</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top"><p>linked lists that can be iterated over in both directions</p>
<h1 id="Description"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Description</a></h1>
<p>The <strong>Gnome::Glib::List</strong> structure and its associated functions provide a standard doubly-linked list data structure.</p><p>Each element in the list contains a piece of data, together with pointers which link to the previous and next elements in the list. Using these pointers it is possible to move through the list in both directions (unlike the singly-linked list, which only allows movement through the list in the forward direction).</p><p>The double linked list does not keep track of the number of items and does not keep track of both the start and end of the list. The data contained in each element can be either simple values like integer or real numbers or pointers to any type of data.</p><p>Note that most of the list functions expect to be passed a pointer to the first element in the list.</p><p>Raku does have plenty ways of its own two handle data for any kind of problem so a doubly linked list is not really needed. This class, however, is provided to handle returned information from other GTK+ methods. E.g. A Container can return child widgets in a List like this. If you really, really want to use this module for your own data, please study the test program in <code>t/List.t</code>. It is important for instance to gard your data against Raku's garbage collecting. Your data gets corrupted before you can say <code>Oh! my program runs ok … (His Famous Last Words)</code>.</p><p>To create an empty list just call <code>.new</code>.</p><p>To remove elements, use <code>remove()</code>.</p><p>To navigate in a list, use <code>first()</code>, <code>last()</code>, <code>next()</code>, <code>previous()</code>, etc.</p><p>To find elements in the list use <code>nth()</code>, <code>nth_data()</code>, <code>foreach()</code> and <code>find_custom()</code>.</p><p>To find the index of an element use <code>position()</code> and <code>index()</code>.</p><p>To free the entire list, use <code>clear-object()</code>.</p><p>When methods return lists, the list might be empty if e.g., things can not be found. You can test for its validity.</p>
<h1 id="Synopsis"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Synopsis</a></h1>

<h2 id="Declaration"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Declaration</a></h2>
<pre class="pod-block-code">unit class Gnome::Glib::List;
also is Gnome::N::TopLevelClassSupport;</pre>
<h2 id="Uml_Diagram"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Uml Diagram</a></h2>
<div class="image-container inline"><img src="asset_files/images/plantuml/List.svg" width="60%" height="auto" alt="No caption"></div>

<h2 id="Example_1,_a_while_loop_to_visit_all_widgets_in_a_grid"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Example 1, a while loop to visit all widgets in a grid</a></h2>
<pre class="pod-block-code"># Get the objects from the grid in a list
my Gnome::Glib::List $list .= new(
  :native-object($grid.get-children)
);

while $list.is-valid {
  # Do something with data at $list.data
  my N-GObject $no = $list.data;
  my Gnome::Gtk3::Widget $w .= new(:native-object($no));

  # Names can be set but are like 'GtkLabel', GtkButton', etc. by default
  given $w.get-name {
    when 'GtkLabel' {
      my Gnome::Gtk3::Label $hl .= new(:native-object($no));
      …
    }
    …
  }

  $list .= next;
}

$list.clear-object;</pre>
<h2 id="Example_2,_using_foreach()_to_visit_all_items_in_the_list"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Example 2, using foreach() to visit all items in the list</a></h2>
<pre class="pod-block-code">use NativeCall;

class ListManagement {
  method list-handler ( Pointer $item ) {
    # do something with the data $item
    my Gnome::Gtk3::Widget $w .= new(:native-object($item));
    given $w.get-name {
      when 'GtkLabel' {
        my Gnome::Gtk3::Label $lbl .= new(:native-object($item));
        …
      }
      …
    }
  }
}

# Get the objects from the grid in a list
my Gnome::Glib::List $list .= new(
  :native-object($grid.get-children)
);

# work through all items in this list
$list.foreach( ListManagement.new, 'list-handler');
$list.clear-object;</pre>
<h1 id="Types"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Types</a></h1>

<h2 id="class_N-GList"><a href="#Gnome::Glib::List" class="u" title="go to top of document">class N-GList</a></h2>
<p>Structure to create a doubly linked list.</p>
<h1 id="Methods"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Methods</a></h1>

<h2 id="new"><a href="#Gnome::Glib::List" class="u" title="go to top of document">new</a></h2>

<h3 id="Default,_no_options"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Default, no options</a></h3>
<p>Create a new plain object.</p><pre class="pod-block-code">multi method new ( )</pre>
<h3 id=":native-object"><a href="#Gnome::Glib::List" class="u" title="go to top of document">:native-object</a></h3>
<p>Create a new list object using an other native list object.</p><pre class="pod-block-code">multi method new ( N-GList :$native-object! )</pre>
<h2 id="[g_]_list_free"><a href="#Gnome::Glib::List" class="u" title="go to top of document">[g_] list_free</a></h2>
<p>Frees all of the memory used by a <strong>Gnome::Glib::List</strong>. The freed elements are returned to the slice allocator.</p><p>If list elements contain dynamically-allocated memory, you should either use <code>g_list_free_full()</code> or free them manually first.</p><pre class="pod-block-code">method g_list_free ( )</pre>
<h2 id="alloc"><a href="#Gnome::Glib::List" class="u" title="go to top of document">alloc</a></h2>
<p>Allocates space for one <strong>Gnome::Glib::List</strong> element. It is called by <code>append()</code>, <code>g-list-prepend()</code>, <code>g-list-insert()</code> and <code>g-list-insert-sorted()</code> and so is rarely used on its own.</p><p>Returns: a pointer to the newly-allocated <strong>Gnome::Glib::List</strong> element</p><pre class="pod-block-code">method alloc ( --&gt; N-GList )</pre>
<h2 id="append"><a href="#Gnome::Glib::List" class="u" title="go to top of document">append</a></h2>
<p>Adds a new element on to the end of the list.</p><p>Note that the return value is the new start of the list, if <em>list</em> was empty; make sure you store the new value.</p><p><code>append()</code> has to traverse the entire list to find the end, which is inefficient when adding multiple elements. A common idiom to avoid the inefficiency is to use <code>prepend()</code> and reverse the list with <code>reverse()</code> when all elements have been added.</p>
<h3 id="Example"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Example</a></h3>
<pre class="pod-block-code">use Gnome::N::GlibToRakuTypes:api&lt;1&gt;;
use Gnome::Glib::List:api&lt;1&gt;;

class IntList {

  has Gnome::Glib::List() $!int-list;

  submethod BUILD () {
    $!int-list .= new;
  }

  # A list item is a pointer to your data. We need to convert it into one.
  # This works for simple data. Raku Structures can not be stored
  # because it is not native and garbage collection might destroy it.
  method pack ( Int $n --&gt; gpointer ) {
    my $o = CArray[gint].new($n);
    nativecast( gpointer, $o)
  }

  # To get it back we must get the data from where the list item points to
  method unpack ( gpointer $p --&gt; Int ) {
    my $o = nativecast( CArray[gint], $p);
    $o[0]
  }

  method append ( Int:D $n ) {
    $!int-list .= append(self.pack($n);
  }

  method get( Int:D $index --&gt; Int ) {
    $!int-list .= first;
    self.unpack($!int-list.nth-data($index)) // Int
  }
}</pre><p>Returns: either <em>list</em> or the new start of the <strong>Gnome::Glib::List</strong> if <em>list</em> was <code>undefined</code></p><pre class="pod-block-code">method append ( Pointer $data --&gt; Gnome::Glib::List )</pre><ul>
<li><p>Pointer $data; the data for the new element</p></li>
</ul>

<h2 id="concat"><a href="#Gnome::Glib::List" class="u" title="go to top of document">concat</a></h2>
<p>Adds the provided <strong>Gnome::Glib::List</strong> onto the end of this list. Note that the elements of the given <strong>Gnome::Glib::List</strong> are not copied. They are used directly.</p><p>This function is for example used to move an element in the list.</p><p>Returns: the start of the new <strong>Gnome::Glib::List</strong>, which equals <em>list1</em> if not <code>undefined</code></p><pre class="pod-block-code">method concat ( N-GList() $list --&gt; Gnome::Glib::List )</pre><ul>
<li><p>N-GList $list; the <strong>Gnome::Glib::List</strong> to add to the end of this list <strong>Gnome::Glib::List</strong>, this must point to the top of the list</p></li>
</ul>

<h2 id="copy"><a href="#Gnome::Glib::List" class="u" title="go to top of document">copy</a></h2>
<p>Copies a <strong>Gnome::Glib::List</strong>.</p><p>Note that this is a &quot;shallow&quot; copy. If the list elements consist of pointers to data, the pointers are copied but the actual data is not.</p><p>Returns: the start of the new list that holds the same data as <em>list</em></p><pre class="pod-block-code">method copy ( --&gt; Gnome::Glib::List )</pre>
<h2 id="copy-deep"><a href="#Gnome::Glib::List" class="u" title="go to top of document">copy-deep</a></h2>
<p>Makes a full (deep) copy of a <strong>Gnome::Glib::List</strong>.</p><p>In contrast with <code>copy()</code>, this function uses <em>func</em> to make a copy of each list element, in addition to copying the list container itself.</p><p><em>func</em>, as a <strong>Gnome::Glib::CopyFunc</strong>, takes two arguments, the data to be copied and a <em>user-data</em> pointer. On common processor architectures, it's safe to pass <code>undefined</code> as <em>user-data</em> if the copy function takes only one argument. You may get compiler warnings from this though if compiling with GCC’s `-Wcast-function-type` warning.</p><p>For instance, if <em>list</em> holds a list of GObjects, you can do: |[&lt;!-- language=&quot;C&quot; --&gt; another-list = g-list-copy-deep (list, (GCopyFunc) g-object-ref, NULL); ]|</p><p>And, to entirely free the new list, you could do: |[&lt;!-- language=&quot;C&quot; --&gt; g-list-free-full (another-list, g-object-unref); ]|</p><p>Returns: the start of the new list that holds a full copy of <em>list</em>, use <code>g-list-free-full()</code> to free it</p><pre class="pod-block-code">method copy-deep ( GCopyFunc $func, Pointer $user_data --&gt; N-GList )</pre><ul>
<li><p>GCopyFunc $func; a copy function used to copy every element in the list</p></li>
<li><p>Pointer $user_data; user data passed to the copy function <em>func</em>, or <code>undefined</code></p></li>
</ul>

<h2 id="data"><a href="#Gnome::Glib::List" class="u" title="go to top of document">data</a></h2>
<p>Gets the data from the current <strong>Gnome::Glib::List</strong> position.</p><pre class="pod-block-code">method data ( --&gt; Pointer )</pre>
<h2 id="delete-link"><a href="#Gnome::Glib::List" class="u" title="go to top of document">delete-link</a></h2>
<p>Removes the node link- from the list and frees it. Compare this to <code>remove-link()</code> which removes the node without freeing it.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method delete-link ( N-GList $link --&gt; Gnome::Glib::List )</pre><ul>
<li><p>N-GList $link_; node to delete from <em>list</em></p></li>
</ul>

<h2 id="find"><a href="#Gnome::Glib::List" class="u" title="go to top of document">find</a></h2>
<p>Finds the element in a <strong>Gnome::Glib::List</strong> which contains the given data.</p><p>Returns: the found <strong>Gnome::Glib::List</strong> element, or <code>invalid</code> if it is not found</p><pre class="pod-block-code">method find ( Pointer $data --&gt; Gnome::Glib::List )</pre><ul>
<li><p>Pointer $data; the element data to find</p></li>
</ul>

<h2 id="find-custom"><a href="#Gnome::Glib::List" class="u" title="go to top of document">find-custom</a></h2>
<p>Finds an element in a <strong>Gnome::Glib::List</strong>, using a supplied function to find the desired element. It iterates over the list, calling the given function which should return 0 when the desired element is found.</p><p>Returns: the found <strong>Gnome::Glib::List</strong> element, or <code>invalid</code> if it is not found.</p><pre class="pod-block-code">method find-custom (
  $handler-object, $method, *%user-data
  --&gt; Gnome::Glib::List
)</pre><ul>
<li><p>$handler-object; Object where method is defined.</p></li>
<li><p>$method; Name of method to call for each element in the list.</p></li>
<li><p>%user-data; optional data provided as named arguments</p></li>
</ul>
<p>The method must be defined as follows;</p><pre class="pod-block-code">method search-handler ( Pointer $list-data, *%user-data --&gt; int )</pre><p>An example where a search is done through a list of widgets returned from, for example, a grid. Such a search could be started after an 'ok' or 'apply' button is clicked on a configuration screen.</p><pre class="pod-block-code">class MySearchEngine {
  method search ( Pointer $item, :$widget-name --&gt; int ) {
    my Gnome::Gtk3::Widget $w .= new(:native-object($item));

    # stop when specified widget is found
    $w.widget-get-name eq $widget-name ?? 0 !! 1
  }
  …
}

# prepare grid
my Gnome::Gtk3::Grid $g .= new;
… a label …
… then an input field …
my Gnome::Gtk3::Entry $e .= new;
$e.set-name('db-username');
$g.attach( $e, 1, 0, 1, 1);
… more fields to specify …

# search for an item (in a button click handler)
my Gnome::Glib::List $list .= new(:native-object($g.get-children));
if my N-GList $sloc = $list.find-custom(
  MySearchEngine.new, 'search', :widget-name('db-username')
) {
  … do something with found widget …
}</pre><p>This example might not be the best choice when all fields are searched through this way because most elements are passed multiple times after all tests. To prevent this, one could continue the search from where it returned a defined list. The other option is to use <code>foreach()</code>.</p>
<h2 id="first"><a href="#Gnome::Glib::List" class="u" title="go to top of document">first</a></h2>
<p>Gets the first element in a <strong>Gnome::Glib::List</strong>.</p><p>Returns: the first element in the <strong>Gnome::Glib::List</strong>, or <code>invalid</code> if the <strong>Gnome::Glib::List</strong> has no elements.</p><pre class="pod-block-code">method first ( --&gt; Gnome::Glib::List )</pre>
<h2 id="foreach"><a href="#Gnome::Glib::List" class="u" title="go to top of document">foreach</a></h2>
<p>Calls a function for each element of a <strong>Gnome::Glib::List</strong>.</p><pre class="pod-block-code">method foreach ( Any:D $handler-object, Str:D $method, *%user-data )</pre><ul>
<li><p>$handler-object; Object where method is defined.</p></li>
<li><p>$method; Name of method to call for each element in the list.</p></li>
<li><p>%user-data; optional data provided as named arguments</p></li>
</ul>
<p>The method must be defined as follows;</p><pre class="pod-block-code">method foreach-handler ( Pointer $list-data, *%user-data )</pre>
<h2 id="free1"><a href="#Gnome::Glib::List" class="u" title="go to top of document">free1</a></h2>
<p>Frees one <strong>Gnome::Glib::List</strong> element, but does not update links from the next and previous elements in the list, so you should not call this function on an element that is currently part of a list.</p><p>It is usually used after <code>remove-link()</code>.</p><pre class="pod-block-code">method free1 ( )</pre>
<h2 id="free-full"><a href="#Gnome::Glib::List" class="u" title="go to top of document">free-full</a></h2>
<p>Convenience method, which frees all the memory used by a <strong>Gnome::Glib::List</strong>, and calls <em>free-func</em> on every element's data.</p><p><em>free-func</em> must not modify the list (eg, by removing the freed element from it).</p><pre class="pod-block-code">method free-full ( GDestroyNotify $free_func )</pre><ul>
<li><p>GDestroyNotify $free_func; the function to be called to free each element's data</p></li>
</ul>

<h2 id="index"><a href="#Gnome::Glib::List" class="u" title="go to top of document">index</a></h2>
<p>Gets the position of the element containing the given data (starting from 0).</p><p>Returns: the index of the element containing the data, or -1 if the data is not found</p><pre class="pod-block-code">method index ( Pointer $data --&gt; Int )</pre><ul>
<li><p>Pointer $data; the data to find</p></li>
</ul>

<h2 id="insert"><a href="#Gnome::Glib::List" class="u" title="go to top of document">insert</a></h2>
<p>Inserts a new element into the list at the given position.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method insert ( Pointer $data, Int $position --&gt; Gnome::Glib::List )</pre><ul>
<li><p>Pointer $data; the data for the new element</p></li>
<li><p>Int $position; the position to insert the element. If this is negative, or is larger than the number of elements in the list, the new element is added on to the end of the list.</p></li>
</ul>

<h2 id="insert-before"><a href="#Gnome::Glib::List" class="u" title="go to top of document">insert-before</a></h2>
<p>Inserts a new element into the list before the given position.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method insert-before ( N-GList $sibling, Pointer $data --&gt; Gnome::Glib::List )</pre><ul>
<li><p>N-GList $sibling; the list element before which the new element is inserted or <code>undefined</code> to insert at the end of the list</p></li>
<li><p>Pointer $data; the data for the new element</p></li>
</ul>

<h2 id="insert-sorted"><a href="#Gnome::Glib::List" class="u" title="go to top of document">insert-sorted</a></h2>
<p>Inserts a new element into the list, using the given comparison function to determine its position.</p><p>If you are adding many new elements to a list, and the number of new elements is much larger than the length of the list, use <code>prepend()</code> to add the new items and sort the list afterwards with <code>sort()</code>.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method insert-sorted ( Pointer $data, GCompareFunc $func --&gt; N-GList )</pre><ul>
<li><p>Pointer $data; the data for the new element</p></li>
<li><p>GCompareFunc $func; the function to compare elements in the list. It should return a number &gt; 0 if the first parameter comes after the second parameter in the sort order.</p></li>
</ul>

<h2 id="insert-sorted-with-data"><a href="#Gnome::Glib::List" class="u" title="go to top of document">insert-sorted-with-data</a></h2>
<p>Inserts a new element into the list, using the given comparison function to determine its position.</p><p>If you are adding many new elements to a list, and the number of new elements is much larger than the length of the list, use <code>prepend()</code> to add the new items and sort the list afterwards with <code>g-list-sort()</code>.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method insert-sorted-with-data ( Pointer $data, GCompareDataFunc $func, Pointer $user_data --&gt; N-GList )</pre><ul>
<li><p>Pointer $data; the data for the new element</p></li>
<li><p>GCompareDataFunc $func; the function to compare elements in the list. It should return a number &gt; 0 if the first parameter comes after the second parameter in the sort order.</p></li>
<li><p>Pointer $user_data; user data to pass to comparison function</p></li>
</ul>

<h2 id="last"><a href="#Gnome::Glib::List" class="u" title="go to top of document">last</a></h2>
<p>Gets the last element in a <strong>Gnome::Glib::List</strong>.</p><p>Returns: the last element in the <strong>Gnome::Glib::List</strong>, or <code>invalid</code> if the <strong>Gnome::Glib::List</strong> has no elements</p><pre class="pod-block-code">method last ( --&gt; Gnome::Glib::List )</pre>
<h2 id="length"><a href="#Gnome::Glib::List" class="u" title="go to top of document">length</a></h2>
<p>Gets the number of elements in a <strong>Gnome::Glib::List</strong>.</p><p>This function iterates over the whole list to count its elements.</p><p>Returns: the number of elements in the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method length ( --&gt; UInt )</pre>
<h2 id="next"><a href="#Gnome::Glib::List" class="u" title="go to top of document">next</a></h2>
<p>Gets the next element in a <strong>Gnome::Glib::List</strong>, or undefined if the <strong>Gnome::Glib::List</strong> has no more elements.</p><pre class="pod-block-code">method next ( --&gt; Gnome::Glib::List )</pre>
<h2 id="nth"><a href="#Gnome::Glib::List" class="u" title="go to top of document">nth</a></h2>
<p>Gets the element at the given position in a <strong>Gnome::Glib::List</strong>.</p><p>This iterates over the list until it reaches the <em>n</em>-th position. If you intend to iterate over every element, it is better to use a for-loop as described in the <strong>Gnome::Glib::List</strong> introduction.</p><p>Returns: the element, or <code>invalid</code> if the position is off the end of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method nth ( UInt $n --&gt; Gnome::Glib::List )</pre><ul>
<li><p>UInt $n; the position of the element, counting from 0</p></li>
</ul>

<h2 id="nth-data"><a href="#Gnome::Glib::List" class="u" title="go to top of document">nth-data</a></h2>
<p>Gets the data of the element at the given position.</p><p>This iterates over the list until it reaches the <em>n</em>-th position. If you intend to iterate over every element, it is better to use a for-loop as described in the <strong>Gnome::Glib::List</strong> introduction.</p><p>Returns: the element's data, or <code>undefined</code> if the position is off the end of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method nth-data ( UInt $n --&gt; Pointer )</pre><ul>
<li><p>UInt $n; the position of the element</p></li>
</ul>

<h2 id="nth-prev"><a href="#Gnome::Glib::List" class="u" title="go to top of document">nth-prev</a></h2>
<p>Gets the element <em>n</em> places before <em>list</em>.</p><p>Returns: the element, or <code>invalid</code> if the position is off the end of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method nth-prev ( UInt $n --&gt; Gnome::Glib::List )</pre><ul>
<li><p>UInt $n; the position of the element, counting from 0</p></li>
</ul>

<h2 id="position"><a href="#Gnome::Glib::List" class="u" title="go to top of document">position</a></h2>
<p>Gets the position of the given element in the <strong>Gnome::Glib::List</strong> (starting from 0).</p><p>Returns: the position of the element in the <strong>Gnome::Glib::List</strong>, or -1 if the element is not found</p><pre class="pod-block-code">method position ( N-GList $llink --&gt; Int )</pre><ul>
<li><p>N-GList $llink; an element in the <strong>Gnome::Glib::List</strong></p></li>
</ul>

<h2 id="prepend"><a href="#Gnome::Glib::List" class="u" title="go to top of document">prepend</a></h2>
<p>Prepends a new element on to the start of the list.</p><p>Note that the return value is the new start of the list, which will have changed, so make sure you store the new value. Do not use this function to prepend a new element to a different element than the start of the list. (Note; probably the list before insertion point gets cut off and then there is a memory leak). Use <code>g-list-insert-before()</code> instead.</p><p>Returns: a pointer to the newly prepended element, which is the new start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method prepend ( Pointer $data --&gt; Gnome::Glib::List )</pre><ul>
<li><p>Pointer $data; the data for the new element</p></li>
</ul>

<h3 id="Example_0"><a href="#Gnome::Glib::List" class="u" title="go to top of document">Example</a></h3>
<pre class="pod-block-code">my Gnome::Glib::List $list .= new;

$list .= prepend(CArray[Str].new(&quot;last&quot;));
$list .= prepend(CArray[Str].new(&quot;first&quot;));</pre>
<h2 id="previous"><a href="#Gnome::Glib::List" class="u" title="go to top of document">previous</a></h2>
<p>Gets the previous element in a <strong>Gnome::Glib::List</strong>, or <code>invalif</code> if the <strong>Gnome::Glib::List</strong> is at the beginning of the list.</p><pre class="pod-block-code">method previous ( --&gt; Gnome::Glib::List )</pre>
<h2 id="remove"><a href="#Gnome::Glib::List" class="u" title="go to top of document">remove</a></h2>
<p>Removes an element from a <strong>Gnome::Glib::List</strong>. If two elements contain the same data, only the first is removed. If none of the elements contain the data, the <strong>Gnome::Glib::List</strong> is unchanged.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method remove ( Pointer $data --&gt; Gnome::Glib::List )</pre><ul>
<li><p>Pointer $data; the data of the element to remove</p></li>
</ul>

<h2 id="remove-all"><a href="#Gnome::Glib::List" class="u" title="go to top of document">remove-all</a></h2>
<p>Removes all list nodes with data equal to <em>data</em>. Returns the new head of the list. Contrast with <code>remove()</code> which removes only the first node matching the given data.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method remove-all ( Pointer $data --&gt; Gnome::Glib::List )</pre><ul>
<li><p>Pointer $data; data to remove</p></li>
</ul>

<h2 id="remove-link"><a href="#Gnome::Glib::List" class="u" title="go to top of document">remove-link</a></h2>
<p>Removes an element from a <strong>Gnome::Glib::List</strong>, without freeing the element. The removed element's prev and next links are set to <code>invalid</code>, so that it becomes a self-contained list with one element.</p><p>This function is for example used to move an element in the list (see the example for <code>concat()</code>) or to remove an element in the list before freeing its data.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method remove-link ( N-GList $llink --&gt; Gnome::Glib::List )</pre><ul>
<li><p>N-GList $llink; an element in the <strong>Gnome::Glib::List</strong></p></li>
</ul>

<h2 id="reverse"><a href="#Gnome::Glib::List" class="u" title="go to top of document">reverse</a></h2>
<p>Reverses a <strong>Gnome::Glib::List</strong>. It simply switches the next and prev pointers of each element.</p><p>Returns: the start of the reversed <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method reverse ( --&gt; Gnome::Glib::List )</pre>
<h2 id="sort"><a href="#Gnome::Glib::List" class="u" title="go to top of document">sort</a></h2>
<p>Sorts a <strong>Gnome::Glib::List</strong> using the given comparison function. The algorithm used is a stable sort.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method sort (
  Any:D $user-object, Str:D $method
  --&gt; Gnome::Glib::List
)</pre><ul>
<li><p>$user-object is object wherein the compare method is defined.</p></li>
<li><p>$method is the the comparison function used to sort the <strong>Gnome::Glib::List</strong>. This function is passed the data from 2 elements of the <strong>Gnome::Glib::List</strong> and should return 0 if they are equal, a negative value if the first element comes before the second, or a positive value if the first element comes after the second.</p></li>
</ul>
<p>The method must be defined as follows;</p><pre class="pod-block-code">method compare-handler ( Pointer $a, Pointer $b --&gt; int )</pre><p>The method must return -1 when $a is less than $b, 0 when equal or 1 when $a is greater than $b.</p>
<h2 id="sort-with-data"><a href="#Gnome::Glib::List" class="u" title="go to top of document">sort-with-data</a></h2>
<p>Like <code>sort()</code>, but the comparison function accepts a user data argument.</p><p>Returns: the (possibly changed) start of the <strong>Gnome::Glib::List</strong></p><pre class="pod-block-code">method sort-with-data ( GCompareDataFunc $compare_func, Pointer $user_data --&gt; N-GList )</pre><ul>
<li><p>GCompareDataFunc $compare_func; comparison function</p></li>
<li><p>Pointer $user_data; user data to pass to comparison function</p></li>
</ul>
</section>		</div>
</div><footer><div>Rendered from <span class="path">/home/marcel/Languages/Raku/Projects/gnome-api1/gnome-glib/lib/Gnome/Glib/List.rakumod</span></div><div>at <span class="time">2025-07-20T17:01:51Z</span></div></footer>
	</body>
</html>
