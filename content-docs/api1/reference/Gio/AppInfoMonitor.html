---
---
<!doctype html>
<html lang="en">
<head>
<title>Gnome::Gio::AppInfoMonitor</title>
<meta charset="UTF-8" />

<link href="asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />

</head>
	<body class="pod">
<header><img src="asset_files/images/gtk-raku.png" id="Camelia_bug"><h2 class="title" id="Gnome::Gio::AppInfoMonitor">Gnome::Gio::AppInfoMonitor</h2></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#Description">Description</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#See_Also">See Also</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Synopsis">Synopsis</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Declaration">Declaration</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Uml_Diagram">Uml Diagram</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#"></a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class_N-GAppLaunchContext">class N-GAppLaunchContext</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#new">new</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#default,_no_options">default, no options</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#:native-object">:native-object</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get">get</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-type">get-type</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Signals">Signals</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#First_method">First method</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Second_method">Second method</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Supported_signals">Supported signals</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#changed">changed</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top"><p>Monitor application information for changes</p>
<h1 id="Description"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">Description</a></h1>
<p><strong>Gnome::Gio::AppInfoMonito</strong>r is a very simple object used for monitoring the app info database for changes (ie: newly installed or removed applications). Call <code>Gnome::Gio::AppInfo.monitor_get()</code> to get a <strong>Gnome::Gio::AppInfoMonitor</strong> and connect to the &quot;changed&quot; signal.</p><p>In the usual case, applications should try to make note of the change (doing things like invalidating caches) but not act on it. In particular, applications should avoid making calls to <strong>Gnome::Gio::AppInfo</strong> APIs in response to the change signal, deferring these until the time that the data is actually required. The exception to this case is when application information is actually being displayed on the screen (eg: during a search or when the list of all applications is shown). The reason for this is that changes to the list of installed applications often come in groups (like during system updates) and rescanning the list on every change is pointless and expensive.</p>
<h2 id="See_Also"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">See Also</a></h2>
<p><strong>Gnome::Gio::AppInfo</strong></p>
<h1 id="Synopsis"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">Synopsis</a></h1>

<h2 id="Declaration"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">Declaration</a></h2>
<pre class="pod-block-code">unit class Gnome::Gio::AppInfoMonitor;
also is Gnome::GObject::Object</pre>
<h2 id="Uml_Diagram"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">Uml Diagram</a></h2>
<div class="image-container inline"><img src="asset_files/images/plantuml/AppInfo.svg" width="60%" height="auto" alt="No caption"></div>

<h2 id="class_N-GAppLaunchContext"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">class N-GAppLaunchContext</a></h2>
<p>Integrating the launch with the launching application. This is used to handle for instance startup notification and launching the new application on the same screen as the launching window.</p>
<h1 id="Methods"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">Methods</a></h1>

<h2 id="new"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">new</a></h2>

<h3 id="default,_no_options"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">default, no options</a></h3>
<p>Creates the <strong>Gnome::Gio::AppInfoMonitor</strong> for the current thread-default main context.</p><p>The <strong>Gnome::Gio::AppInfoMonitor</strong> will emit a &quot;changed&quot; signal in the thread-default main context whenever the list of installed applications (as reported by <code>Gnome::Gio::AppInfo.get-all()</code>) may have changed.</p><p>You must only call <code>.clear-object()</code> on the return value from under the same main context as you created it.</p><pre class="pod-block-code">multi method new ( )</pre>
<h3 id=":native-object"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">:native-object</a></h3>
<p>Create a AppInfoMonitor object using a native object from elsewhere. See also <strong>Gnome::N::TopLevelClassSupport</strong>.</p><pre class="pod-block-code">multi method new ( N-GObject :$native-object! )</pre>
<h2 id="get"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">get</a></h2>
<p>Gets the <strong>Gnome::Gio::AppInfoMonitor</strong> for the current thread-default main context.</p><p>The <strong>Gnome::Gio::AppInfoMonitor</strong> will emit a &quot;changed&quot; signal in the thread-default main context whenever the list of installed applications (as reported by <code>g-app-info-get-all()</code>) may have changed.</p><p>You must only call <code>g-object-unref()</code> on the return value from under the same main context as you created it.</p><p>Returns: a reference to a <strong>Gnome::Gio::AppInfoMonitor</strong></p><pre class="pod-block-code">method get ( --&gt; GAppInfoMonitor )</pre>
<h2 id="get-type"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">get-type</a></h2>
<p>Type of a GAppInfoMonitor</p><pre class="pod-block-code">method get-type ( --&gt; N-GObject )</pre>
<h1 id="Signals"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">Signals</a></h1>
<p>There are two ways to connect to a signal. The first option you have is to use <code>register-signal()</code> from <strong>Gnome::GObject::Object</strong>. The second option is to use <code>connect-object()</code> directly from <strong>Gnome::GObject::Signal</strong>.</p>
<h2 id="First_method"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">First method</a></h2>
<p>The positional arguments of the signal handler are all obligatory as well as their types. The named attributes <code>:$widget</code> and user data are optional.</p><pre class="pod-block-code"># handler method
method mouse-event ( GdkEvent $event, :$widget ) { ... }

# connect a signal on window object
my Gnome::Gtk3::Window $w .= new( ... );
$w.register-signal( self, 'mouse-event', 'button-press-event');</pre>
<h2 id="Second_method"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">Second method</a></h2>
<pre class="pod-block-code">my Gnome::Gtk3::Window $w .= new( ... );
my Callable $handler = sub (
  N-GObject $native, GdkEvent $event, OpaquePointer $data
) {
  ...
}

$w.connect-object( 'button-press-event', $handler);</pre><p>Also here, the types of positional arguments in the signal handler are important. This is because both methods <code>register-signal()</code> and <code>connect-object()</code> are using the signatures of the handler routines to setup the native call interface.</p>
<h2 id="Supported_signals"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">Supported signals</a></h2>

<h3 id="changed"><a href="#Gnome::Gio::AppInfoMonitor" class="u" title="go to top of document">changed</a></h3>
<pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($appinfomonitor),
  *%user-options
);</pre><ul>
<li><p>$appinfomonitor; the registered info moditor object</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
</ul>
</section>		</div>
</div><footer><div>Rendered from <span class="path">/home/marcel/Languages/Raku/Projects/gnome-api1/gnome-gio/lib/Gnome/Gio/AppInfoMonitor.rakumod</span></div><div>at <span class="time">2025-07-20T10:56:53Z</span></div></footer>
	</body>
</html>
