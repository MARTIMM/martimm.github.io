---
---
<!doctype html>
<html lang="en">
<head>
<title>Gnome::Gtk3::Container</title>
<meta charset="UTF-8" />

<link href="asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />

</head>
	<body class="pod">
<header><img src="asset_files/images/gtk-raku.png" id="Camelia_bug"><h2 class="title" id="Gnome::Gtk3::Container">Gnome::Gtk3::Container</h2></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#Description">Description</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Height_for_width_geometry_management">Height for width geometry management</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Gnome::Gtk3::Container_as_Gnome::Gtk3::Buildable">Gnome::Gtk3::Container as Gnome::Gtk3::Buildable</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Synopsis">Synopsis</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Declaration">Declaration</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Uml_Diagram">Uml Diagram</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#"></a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#new">new</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#multi_method_new_(_N-GObject_:$native-object!_)">multi method new ( N-GObject :$native-object! )</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#multi_method_new_(_Str_:$build-id!_)">multi method new ( Str :$build-id! )</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add">add</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-with-properties">add-with-properties</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#check-resize">check-resize</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-get">child-get</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-get-property">child-get-property</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Example">Example</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-get-valist">child-get-valist</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-notify">child-notify</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-notify-by-pspec">child-notify-by-pspec</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-set">child-set</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-set-property">child-set-property</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-set-valist">child-set-valist</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-type">child-type</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-find-child-property">class-find-child-property</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-handle-border-width">class-handle-border-width</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-install-child-properties">class-install-child-properties</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-install-child-property">class-install-child-property</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-list-child-properties">class-list-child-properties</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#forall">forall</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#foreach">foreach</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Example_0">Example</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-border-width">get-border-width</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-children">get-children</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-focus-child">get-focus-child</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-focus-hadjustment">get-focus-hadjustment</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-focus-vadjustment">get-focus-vadjustment</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-path-for-child">get-path-for-child</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#propagate-draw">propagate-draw</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove">remove</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-border-width">set-border-width</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-focus-child">set-focus-child</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-focus-hadjustment">set-focus-hadjustment</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-focus-vadjustment">set-focus-vadjustment</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Signals">Signals</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add_0">add</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#check-resize_0">check-resize</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove_0">remove</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-focus-child_0">set-focus-child</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Signals_0">Signals</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#First_method">First method</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Second_method">Second method</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Supported_signals">Supported signals</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#ade">add</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#removf">remove</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#set-focus-chile">set-focus-child</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Properties">Properties</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#border-width">border-width</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top"><p>Base class for widgets which contain other widgets</p>
<h1 id="Description"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Description</a></h1>
<p>A GTK+ user interface is constructed by nesting widgets inside widgets. Container widgets are the inner nodes in the resulting tree of widgets: they contain other widgets. So, for example, you might have a <strong>Gnome::Gtk3::Window</strong> containing a <strong>Gnome::Gtk3::Frame</strong> containing a <strong>Gnome::Gtk3::Label</strong>. If you wanted an image instead of a textual label inside the frame, you might replace the <strong>Gnome::Gtk3::Label</strong> widget with a <strong>Gnome::Gtk3::Image</strong> widget.</p><p>There are two major kinds of container widgets in GTK+. Both are subclasses of the abstract <strong>Gnome::Gtk3::Container</strong> base class.</p><p>The first type of container widget has a single child widget and derives from <strong>Gnome::Gtk3::Bin</strong>. These containers are decorators, which add some kind of functionality to the child. For example, a <strong>Gnome::Gtk3::Button</strong> makes its child into a clickable button; a <strong>Gnome::Gtk3::Frame</strong> draws a frame around its child and a <strong>Gnome::Gtk3::Window</strong> places its child widget inside a top-level window.</p><p>The second type of container can have more than one child; its purpose is to manage layout. This means that these containers assign sizes and positions to their children. For example, a <strong>Gnome::Gtk3::HBox</strong> arranges its children in a horizontal row, and a <strong>Gnome::Gtk3::Grid</strong> arranges the widgets it contains in a two-dimensional grid.</p>
<h2 id="Height_for_width_geometry_management"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Height for width geometry management</a></h2>
<p>GTK+ uses a height-for-width (and width-for-height) geometry management system. Height-for-width means that a widget can change how much vertical space it needs, depending on the amount of horizontal space that it is given (and similar for width-for-height).</p><p>There are some things to keep in mind when implementing container widgets that make use of GTK+’s height for width geometry management system. First, it’s important to note that a container must prioritize one of its dimensions, that is to say that a widget or container can only have a <strong>Gnome::Gtk3::SizeRequestMode</strong> that is <code>GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH</code> or <code>GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT</code>. However, every widget and container must be able to respond to the APIs for both dimensions, i.e. even if a widget has a request mode that is height-for-width, it is possible that its parent will request its sizes using the width-for-height APIs.</p><p>To ensure that everything works properly, here are some guidelines to follow when implementing height-for-width (or width-for-height) containers.</p><p>Each request mode involves 2 virtual methods. Height-for-width apis run through <code>gtk_widget_get_preferred_width()</code> and then through <code>gtk_widget_get_preferred_height_for_width()</code>. When handling requests in the opposite <strong>Gnome::Gtk3::SizeRequestMode</strong> it is important that every widget request at least enough space to display all of its content at all times.</p><p>When <code>gtk_widget_get_preferred_height()</code> is called on a container that is height-for-width, the container must return the height for its minimum width. This is easily achieved by simply calling the reverse apis implemented for itself.</p><p>Similarly, when <code>gtk_widget_get_preferred_width_for_height()</code> is called for a container or widget that is height-for-width, it then only needs to return the base minimum width</p><p>Height for width requests are generally implemented in terms of a virtual allocation of widgets in the input orientation. Assuming an height-for-width request mode, a container would implement the <code>get_preferred_height_for_width()</code> virtual function by first calling <code>gtk_widget_get_preferred_width()</code> for each of its children.</p><p>For each potential group of children that are lined up horizontally, the values returned by <code>gtk_widget_get_preferred_width()</code> should be collected in an array of <strong>Gnome::Gtk3::RequestedSize</strong> structures. Any child spacing should be removed from the input <em>for_width</em> and then the collective size should be allocated using the <code>gtk_distribute_natural_allocation()</code> convenience function.</p><p>The container will then move on to request the preferred height for each child by using <code>gtk_widget_get_preferred_height_for_width()</code> and using the sizes stored in the <strong>Gnome::Gtk3::RequestedSize</strong> array.</p><p>To allocate a height-for-width container, it’s again important to consider that a container must prioritize one dimension over the other. So if a container is a height-for-width container it must first allocate all widgets horizontally using a <strong>Gnome::Gtk3::RequestedSize</strong> array and <code>gtk_distribute_natural_allocation()</code> and then add any extra space (if and where appropriate) for the widget to expand.</p><p>After adding all the expand space, the container assumes it was allocated sufficient height to fit all of its content. At this time, the container must use the total horizontal sizes of each widget to request the height-for-width of each of its children and store the requests in a <strong>Gnome::Gtk3::RequestedSize</strong> array for any widgets that stack vertically (for tabular containers this can be generalized into the heights and widths of rows and columns). The vertical space must then again be distributed using <code>gtk_distribute_natural_allocation()</code> while this time considering the allocated height of the widget minus any vertical spacing that the container adds. Then vertical expand space should be added where appropriate and available and the container should go on to actually allocating the child widgets.</p><p>See [<strong>Gnome::Gtk3::Widget</strong>’s geometry management section](https://developer.gnome.org/gtk3/3.24/GtkWidget.html#geometry-managementgeometry-management) to learn more about implementing height-for-width geometry management for widgets.</p>
<h2 id="Gnome::Gtk3::Container_as_Gnome::Gtk3::Buildable"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Gnome::Gtk3::Container as Gnome::Gtk3::Buildable</a></h2>
<p>The <strong>Gnome::Gtk3::Container</strong> implementation of the <strong>Gnome::Gtk3::Buildable</strong> interface supports a &lt;packing&gt; element for children, which can contain multiple &lt;property&gt; elements that specify child properties for the child.</p><p>Since 2.16, child properties can also be marked as translatable using the same “translatable”, “comments” and “context” attributes that are usedfor regular properties.</p><p>Since 3.16, containers can have a &lt;focus-chain&gt; element containing multiple &lt;widget&gt; elements, one for each child that should be added to the focus chain. The ”name” attribute gives the id of the widget.</p><p>An example of these properties in UI definitions:</p><pre class="pod-block-code">&lt;object class=&quot;GtkBox&gt;&quot;&gt;
  &lt;child&gt;
    &lt;object class=&quot;GtkEntry&gt;&quot; id=&quot;entry1&quot;/&gt;
    &lt;packing&gt;
      &lt;property name=&quot;pack-type&quot;&gt;start&lt;/property&gt;
    &lt;/packing&gt;
  &lt;/child&gt;
  &lt;child&gt;
    &lt;object class=&quot;GtkEntry&gt;&quot; id=&quot;entry2&quot;/&gt;
  &lt;/child&gt;
  &lt;focus-chain&gt;
    &lt;widget name=&quot;entry1&quot;/&gt;
    &lt;widget name=&quot;entry2&quot;/&gt;
  &lt;/focus-chain&gt;
&lt;/object&gt;</pre>
<h1 id="Synopsis"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Synopsis</a></h1>

<h2 id="Declaration"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Declaration</a></h2>
<pre class="pod-block-code">unit class Gnome::Gtk3::Container;
also is Gnome::Gtk3::Widget;</pre>
<h2 id="Uml_Diagram"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Uml Diagram</a></h2>
<div class="image-container inline"><img src="asset_files/images/plantuml/Container.svg" width="60%" height="auto" alt="No caption"></div>

<h1 id="Methods"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Methods</a></h1>

<h2 id="new"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">new</a></h2>

<h3 id="multi_method_new_(_N-GObject_:$native-object!_)"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">multi method new ( N-GObject :$native-object! )</a></h3>
<p>Create an object using a native object from elsewhere. See also <strong>Gnome::GObject::Object</strong>.</p>
<h3 id="multi_method_new_(_Str_:$build-id!_)"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">multi method new ( Str :$build-id! )</a></h3>
<p>Create an object using a native object from a builder. See also <strong>Gnome::GObject::Object</strong>.</p>
<h2 id="add"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">add</a></h2>
<p>Adds <em>$widget</em> to this container. Typically used for simple containers such as <strong>Gnome::Gtk3::Window</strong>, <strong>Gnome::Gtk3::Frame</strong>, or <strong>Gnome::Gtk3::Button</strong>; for more complicated layout containers such as <strong>Gnome::Gtk3::Box</strong> or <strong>Gnome::Gtk3::Grid</strong>, this function will pick default packing parameters that may not be correct. So consider functions such as <code>Gnome::Gtk3::Box.pack-start()</code> and <code>Gnome::Gtk3::Grid.attach()</code> as an alternative to <code>add()</code> in those cases. A widget may be added to only one container at a time; you can’t place the same widget inside two different containers.</p><p>Note that some containers, such as <strong>Gnome::Gtk3::ScrolledWindow</strong> or <strong>Gnome::Gtk3::ListBox</strong>, may add intermediate children between the added widget and the container.</p><pre class="pod-block-code">method add ( N-GObject() $widget )</pre><ul>
<li><p>$widget; a widget to be placed inside this container</p></li>
</ul>

<h2 id="add-with-properties"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">add-with-properties</a></h2>
<p>Adds <em>widget</em> to this container, setting child properties at the same time. See <code>add()</code> and <code>gtk-container-child-set()</code> for more details.</p><pre class="pod-block-code">method add-with-properties ( N-GObject() $widget, Str $first_prop_name )</pre><ul>
<li><p>$widget; a widget to be placed inside this container</p></li>
<li><p>$first_prop_name; the name of the first child property to set @...: a <code>undefined</code>-terminated list of property names and values, starting with <em>first-prop-name</em></p></li>
</ul>

<h2 id="check-resize"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">check-resize</a></h2>
<pre class="pod-block-code">method check-resize ( )</pre>
<h2 id="child-get"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-get</a></h2>
<p>Gets the values of one or more child properties for <em>child</em> and this container.</p><pre class="pod-block-code">method child-get ( N-GObject() $child, Str $first_prop_name )</pre><ul>
<li><p>$child; a widget which is a child of this container</p></li>
<li><p>$first_prop_name; the name of the first property to get @...: return location for the first property, followed optionally by more name/return location pairs, followed by <code>undefined</code></p></li>
</ul>

<h2 id="child-get-property"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-get-property</a></h2>
<p>Gets the value of a child property for <em>child</em> and this container. It returns an undefined value if $property-type can't be processed or when $property-name does not exist.</p><pre class="pod-block-code">method child-get-property (
  N-GObject() $child, Str $property-name, $property-type
  --&gt; Any
)</pre><ul>
<li><p>$child; a widget which is a child of this container.</p></li>
<li><p>$property-name; the name of the property to get.</p></li>
<li><p>The type for the return value, e.g. G_TYPE_INT32. See also <strong>Gnome::GObject::Type</strong>.</p></li>
</ul>

<h3 id="Example"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Example</a></h3>
<p>The <strong>Gnome::Gtk3::Fixed</strong> can contain widgets at fixed locations. The locations of each widget can be asked for using this call.</p><pre class="pod-block-code">my Gnome::Gtk3::Fixed $f .= new;
my Gnome::Gtk3::Button $b .= new(:label&lt;Some Button On The Fixed Field&gt;);
$f.put( $b, 10, 10);

# somewhat later
my Int $x = $f.child-get-property( $b, 'x', G_TYPE_INT);
my Int $y = $f.child-get-property( $b, 'y', G_TYPE_INT);

say &quot;Widget is at ($x, $y)&quot;;</pre>
<h2 id="child-get-valist"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-get-valist</a></h2>
<p>Gets the values of one or more child properties for <em>child</em> and this container.</p><pre class="pod-block-code">method child-get-valist (
  N-GObject() $child, Str $first_property_name, va_list $var_args
)</pre><ul>
<li><p>$child; a widget which is a child of this container</p></li>
<li><p>$first_property_name; the name of the first property to get</p></li>
<li><p>$var_args; return location for the first property, followed optionally by more name/return location pairs, followed by <code>undefined</code></p></li>
</ul>

<h2 id="child-notify"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-notify</a></h2>
<p>Emits a <em>child-notify</em> signal for the child property <em>$child-property</em> on the child.</p><p>This is an analogue of <code>g-object-notify()</code> for child properties.</p><p>Also see <code>gtk-widget-child-notify()</code>.</p><pre class="pod-block-code">method child-notify ( N-GObject() $child, Str $child-property )</pre><ul>
<li><p>$child; the child widget</p></li>
<li><p>$child-property; the name of a child property installed on the class of this container</p></li>
</ul>

<h2 id="child-notify-by-pspec"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-notify-by-pspec</a></h2>
<p>Emits a <em>child-notify</em> signal for the [child property][child-properties] specified by <em>pspec</em> on the child.</p><p>This is an analogue of <code>g-object-notify-by-pspec()</code> for child properties.</p><pre class="pod-block-code">method child-notify-by-pspec ( N-GObject() $child, GParamSpec $pspec )</pre><ul>
<li><p>$child; the child widget</p></li>
<li><p>$pspec; the <strong>Gnome::Gtk3::ParamSpec</strong> of a child property instealled on the class of this container</p></li>
</ul>

<h2 id="child-set"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-set</a></h2>
<p>Sets one or more child properties for <em>child</em> and this container.</p><pre class="pod-block-code">method child-set ( N-GObject() $child, Str $first_prop_name )</pre><ul>
<li><p>$child; a widget which is a child of this container</p></li>
<li><p>$first_prop_name; the name of the first property to set @...: a <code>undefined</code>-terminated list of property names and values, starting with <em>first-prop-name</em></p></li>
</ul>

<h2 id="child-set-property"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-set-property</a></h2>
<p>Sets a child property for <em>child</em> and this container.</p><pre class="pod-block-code">method child-set-property (
  N-GObject() $child, Str $property_name, N-GObject() $value
)</pre><ul>
<li><p>$child; a widget which is a child of this container</p></li>
<li><p>$property_name; the name of the property to set</p></li>
<li><p>$value; the value to set the property to</p></li>
</ul>

<h2 id="child-set-valist"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-set-valist</a></h2>
<p>Sets one or more child properties for <em>child</em> and this container.</p><pre class="pod-block-code">method child-set-valist (
  N-GObject() $child, Str $first_property_name, va_list $var_args
)</pre><ul>
<li><p>$child; a widget which is a child of this container</p></li>
<li><p>$first_property_name; the name of the first property to set</p></li>
<li><p>$var_args; a <code>undefined</code>-terminated list of property names and values, starting with <em>first-prop-name</em></p></li>
</ul>

<h2 id="child-type"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">child-type</a></h2>
<p>Returns the type of the children supported by the container.</p><p>Note that this may return <code>G-TYPE-NONE</code> to indicate that no more children can be added, e.g. for a <strong>Gnome::Gtk3::Paned</strong> which already has two children.</p><p>Returns: a <strong>Gnome::Gtk3::Type</strong>.</p><pre class="pod-block-code">method child-type ( --&gt; N-GObject )</pre>
<h2 id="class-find-child-property"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">class-find-child-property</a></h2>
<p>Finds a child property of a container class by name.</p><p>Returns: the <strong>Gnome::Gtk3::ParamSpec</strong> of the child property or <code>undefined</code> if <em>class</em> has no child property with that name.</p><pre class="pod-block-code">method class-find-child-property (
  GObjectClass $cclass, Str $property_name --&gt; GParamSpec
)</pre><ul>
<li><p>$cclass; (type GtkContainerClass): a <strong>Gnome::Gtk3::ContainerClass</strong></p></li>
<li><p>$property_name; the name of the child property to find</p></li>
</ul>

<h2 id="class-handle-border-width"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">class-handle-border-width</a></h2>
<p>Modifies a subclass of <strong>Gnome::Gtk3::ContainerClass</strong> to automatically add and remove the border-width setting on GtkContainer. This allows the subclass to ignore the border width in its size request and allocate methods. The intent is for a subclass to invoke this in its class-init function.</p><p><code>class-handle-border-width()</code> is necessary because it would break API too badly to make this behavior the default. So subclasses must “opt in” to the parent class handling border-width for them.</p><pre class="pod-block-code">method class-handle-border-width ( GtkContainerClass $klass )</pre><ul>
<li><p>$klass; the class struct of a <strong>Gnome::Gtk3::Container</strong> subclass</p></li>
</ul>

<h2 id="class-install-child-properties"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">class-install-child-properties</a></h2>
<p>Installs child properties on a container class.</p><pre class="pod-block-code">method class-install-child-properties (
  GtkContainerClass $cclass, UInt $n_pspecs, GParamSpec $pspecs
)</pre><ul>
<li><p>$cclass; a <strong>Gnome::Gtk3::ContainerClass</strong></p></li>
<li><p>$n_pspecs; the length of the <strong>Gnome::Gtk3::ParamSpec</strong> array</p></li>
<li><p>$pspecs; (array length=n-pspecs): the <strong>Gnome::Gtk3::ParamSpec</strong> array defining the new child properties</p></li>
</ul>

<h2 id="class-install-child-property"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">class-install-child-property</a></h2>
<p>Installs a child property on a container class.</p><pre class="pod-block-code">method class-install-child-property ( GtkContainerClass $cclass, UInt $property_id, GParamSpec $pspec )</pre><ul>
<li><p>$cclass; a <strong>Gnome::Gtk3::ContainerClass</strong></p></li>
<li><p>$property_id; the id for the property</p></li>
<li><p>$pspec; the <strong>Gnome::Gtk3::ParamSpec</strong> for the property</p></li>
</ul>

<h2 id="class-list-child-properties"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">class-list-child-properties</a></h2>
<p>Returns all child properties of a container class.</p><p>Returns: (array length=n-properties) (transfer container): a newly allocated <code>undefined</code>-terminated array of <strong>Gnome::Gtk3::ParamSpec</strong>*. The array must be freed with <code>g-free()</code>.</p><pre class="pod-block-code">method class-list-child-properties ( GObjectClass $cclass, guInt-ptr $n_properties --&gt; GParamSpec )</pre><ul>
<li><p>$cclass; (type GtkContainerClass): a <strong>Gnome::Gtk3::ContainerClass</strong></p></li>
<li><p>$n_properties; location to return the number of child properties found</p></li>
</ul>

<h2 id="forall"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">forall</a></h2>
<p>Invokes <em>callback</em> on each direct child of this container, including children that are considered “internal” (implementation details of the container). “Internal” children generally weren’t added by the user of the container, but were added by the container implementation itself.</p><p>Most applications should use <code>foreach()</code>, rather than <code>gtk-container-forall()</code>.</p><pre class="pod-block-code">method forall ( GtkCallback $callback, Pointer $callback_data )</pre><ul>
<li><p>$callback; (scope call) (closure callback-data): a callback</p></li>
<li><p>$callback_data; callback user data</p></li>
</ul>

<h2 id="foreach"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">foreach</a></h2>
<p>Invokes a callback method on each child of this container. For all practical purposes, this function should iterate over precisely those child widgets that were added to the container by the application with explicit <code>add()</code> calls.</p><pre class="pod-block-code">method foreach (
  Any:D $callback-object, Str:D $callback-name, *%user-options
)</pre><ul>
<li><p>$callback-object; An object where the callback method is defined</p></li>
<li><p>$callback-name; method name of the callback.</p></li>
<li><p>%user-options; A list of named arguments which are provided to the callback.</p></li>
</ul>

<h3 id="Example_0"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Example</a></h3>
<p>An example from the <code>t/Container.t</code> test program where both methods are used;</p><pre class="pod-block-code">class X {
  method cb2 ( Gnome::Gtk3::Label() $rk, :$label ) {
    is $rk.get-name, 'GtkLabel', '.foreach(): cb2()';
    is $rk.get-text, $label, 'label text';
  }

  method cb3 ( N-GObject $o, Str :$label ) {
    is $o.().get-name, 'GtkLabel', '.foreach(): cb3()';
    is $o.().get-text, $label, 'label text';
  }
}

$b .= new(:label&lt;some-text&gt;);
$b.foreach( X.new, 'cb2', :label&lt;some-text&gt;);
$b.foreach( X.new, 'cb3', :label&lt;some-text&gt;);</pre>
<h2 id="get-border-width"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">get-border-width</a></h2>
<p>Retrieves the border width of the container. See <code>set-border-width()</code>.</p><p>Returns: the current border width</p><pre class="pod-block-code">method get-border-width ( --&gt; UInt )</pre>
<h2 id="get-children"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">get-children</a></h2>
<p>Returns the container’s non-internal children. See <code>forall()</code> for details on what constitutes an &quot;internal&quot; child.</p><p>Returns: a newly-allocated list of the container’s non-internal children.</p><pre class="pod-block-code">method get-children ( --&gt; N-GList )</pre>
<h2 id="get-focus-child"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">get-focus-child</a></h2>
<p>Returns the current focus child widget inside this container. This is not the currently focused widget. That can be obtained by calling <code>Gnome::Gtk3::Window.get-focus()</code>.</p><p>Returns: The child widget which will receive the focus inside this container when the this container is focused, or <code>undefined</code> if none is set.</p><pre class="pod-block-code">method get-focus-child ( --&gt; N-GObject )</pre>
<h2 id="get-focus-hadjustment"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">get-focus-hadjustment</a></h2>
<p>Retrieves the horizontal focus adjustment for the container. See <code>set-focus-hadjustment()</code>.</p><p>Returns: the horizontal focus adjustment, or <code>undefined</code> if none has been set.</p><pre class="pod-block-code">method get-focus-hadjustment ( --&gt; N-GObject )</pre>
<h2 id="get-focus-vadjustment"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">get-focus-vadjustment</a></h2>
<p>Retrieves the vertical focus adjustment for the container. See <code>set-focus-vadjustment()</code>.</p><p>Returns: the vertical focus adjustment, or <code>undefined</code> if none has been set. It is a native object for <strong>Gnome::Gtk3::Adjustment</strong>.</p><pre class="pod-block-code">method get-focus-vadjustment ( --&gt; N-GObject )</pre>
<h2 id="get-path-for-child"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">get-path-for-child</a></h2>
<p>Returns a newly created widget path representing all the widget hierarchy from the toplevel down to and including <em>child</em>.</p><p>Returns: A native object for <strong>Gnome::Gtk3::WidgetPath</strong></p><pre class="pod-block-code">method get-path-for-child ( N-GObject() $child --&gt; N-GObject )</pre><ul>
<li><p>$child; a child of this container</p></li>
</ul>

<h2 id="propagate-draw"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">propagate-draw</a></h2>
<p>When a container receives a call to the draw function, it must send synthetic <em>draw</em> calls to all children that don’t have their own <strong>Gnome::Gtk3::Windows</strong>. This function provides a convenient way of doing this. A container, when it receives a call to its <em>draw</em> function, calls <code>propagate-draw()</code> once for each child, passing in the <em>cr</em> the container received.</p><p><code>gtk-container-propagate-draw()</code> takes care of translating the origin of <em>cr</em>, and deciding whether the draw needs to be sent to the child. It is a convenient and optimized way of getting the same effect as calling <code>gtk-widget-draw()</code> on the child directly.</p><p>In most cases, a container can simply either inherit the <em>draw</em> implementation from <strong>Gnome::Gtk3::Container</strong>, or do some drawing and then chain to the <em>draw</em> implementation from <strong>Gnome::Gtk3::Container</strong>.</p><pre class="pod-block-code">method propagate-draw ( N-GObject() $child, cairo_t $cr )</pre><ul>
<li><p>$child; a child of this container</p></li>
<li><p>$cr; Cairo context as passed to the container. If you want to use <em>cr</em> in container’s draw function, consider using <code>cairo-save()</code> and <code>cairo-restore()</code> before calling this function.</p></li>
</ul>

<h2 id="remove"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">remove</a></h2>
<p>Removes <em>widget</em> from this container. <em>widget</em> must be inside this container. Note that this container will own a reference to <em>widget</em>, and that this may be the last reference held; so removing a widget from its container can destroy that widget. If you want to use <em>widget</em> again, you need to add a reference to it before removing it from a container, using <code>g-object-ref()</code>. If you don’t want to use <em>widget</em> again it’s usually more efficient to simply destroy it directly using <code>gtk-widget-destroy()</code> since this will remove it from the container and help break any circular reference count cycles.</p><pre class="pod-block-code">method remove ( N-GObject() $widget )</pre><ul>
<li><p>$widget; a current child of this container</p></li>
</ul>

<h2 id="set-border-width"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">set-border-width</a></h2>
<p>Sets the border width of the container.</p><p>The border width of a container is the amount of space to leave around the outside of the container. The only exception to this is <strong>Gnome::Gtk3::Window</strong>; because toplevel windows can’t leave space outside, they leave the space inside. The border is added on all sides of the container. To add space to only one side, use a specific <em>margin</em> property on the child widget, for example <em>margin-top</em>.</p><pre class="pod-block-code">method set-border-width ( UInt $border_width )</pre><ul>
<li><p>$border_width; amount of blank space to leave outside the container. Valid values are in the range 0-65535 pixels.</p></li>
</ul>

<h2 id="set-focus-child"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">set-focus-child</a></h2>
<p>Sets, or unsets if <em>child</em> is <code>undefined</code>, the focused child of this container.</p><p>This function emits the GtkContainer::set-focus-child signal of this container. Implementations of <strong>Gnome::Gtk3::Container</strong> can override the default behaviour by overriding the class closure of this signal.</p><p>This is function is mostly meant to be used by widgets. Applications can use <code>gtk-widget-grab-focus()</code> to manually set the focus to a specific widget.</p><pre class="pod-block-code">method set-focus-child ( N-GObject() $child )</pre><ul>
<li><p>$child; a <strong>Gnome::Gtk3::Widget</strong>, or <code>undefined</code></p></li>
</ul>

<h2 id="set-focus-hadjustment"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">set-focus-hadjustment</a></h2>
<p>Hooks up an adjustment to focus handling in a container, so when a child of the container is focused, the adjustment is scrolled to show that widget. This function sets the horizontal alignment. See <code>gtk-scrolled-window-get-hadjustment()</code> for a typical way of obtaining the adjustment and <code>set-focus-vadjustment()</code> for setting the vertical adjustment.</p><p>The adjustments have to be in pixel units and in the same coordinate system as the allocation for immediate children of the container.</p><pre class="pod-block-code">method set-focus-hadjustment ( N-GObject() $adjustment )</pre><ul>
<li><p>$adjustment; an adjustment which should be adjusted when the focus is moved among the descendents of this container</p></li>
</ul>

<h2 id="set-focus-vadjustment"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">set-focus-vadjustment</a></h2>
<p>Hooks up an adjustment to focus handling in a container, so when a child of the container is focused, the adjustment is scrolled to show that widget. This function sets the vertical alignment. See <code>gtk-scrolled-window-get-vadjustment()</code> for a typical way of obtaining the adjustment and <code>set-focus-hadjustment()</code> for setting the horizontal adjustment.</p><p>The adjustments have to be in pixel units and in the same coordinate system as the allocation for immediate children of the container.</p><pre class="pod-block-code">method set-focus-vadjustment ( N-GObject() $adjustment )</pre><ul>
<li><p>$adjustment; an adjustment which should be adjusted when the focus is moved among the descendents of this container</p></li>
</ul>

<h1 id="Signals"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Signals</a></h1>

<h2 id="add_0"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">add</a></h2>
<pre class="pod-block-code">method handler (
  N-GObject #`{ native widget } $n-widget,
  Gnome::Gtk3::Container :_widget($container),
  Int :$_handler-id,
  N-GObject :$_native-object,
  *%user-options
)</pre><ul>
<li><p>$n-widget; the added widget</p></li>
<li><p>$container; The instance which registered the signal</p></li>
<li><p>$_handler-id; The handler id which is returned from the registration</p></li>
<li><p>$_native-object; The native object provided by the caller wrapped in the Raku object.</p></li>
<li><p>%user-options; A list of named arguments provided at the <code>register-signal()</code> method</p></li>
</ul>

<h2 id="check-resize_0"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">check-resize</a></h2>
<pre class="pod-block-code">method handler (
  Gnome::Gtk3::Container :_widget($container),
  Int :$_handler-id,
  N-GObject :$_native-object,
  *%user-options
)</pre><ul>
<li><p>$container; The instance which registered the signal</p></li>
<li><p>$_handler-id; The handler id which is returned from the registration</p></li>
<li><p>$_native-object; The native object provided by the caller wrapped in the Raku object.</p></li>
<li><p>%user-options; A list of named arguments provided at the <code>register-signal()</code> method</p></li>
</ul>

<h2 id="remove_0"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">remove</a></h2>
<pre class="pod-block-code">method handler (
  N-GObject #`{ native widget } $n-widget,
  Gnome::Gtk3::Container :_widget($container),
  Int :$_handler-id,
  N-GObject :$_native-object,
  *%user-options
)</pre><ul>
<li><p>$n-widget; The removed widget</p></li>
<li><p>$container; The instance which registered the signal</p></li>
<li><p>$_handler-id; The handler id which is returned from the registration</p></li>
<li><p>$_native-object; The native object provided by the caller wrapped in the Raku object.</p></li>
<li><p>%user-options; A list of named arguments provided at the <code>register-signal()</code> method</p></li>
</ul>

<h2 id="set-focus-child_0"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">set-focus-child</a></h2>
<pre class="pod-block-code">method handler (
  N-GObject #`{ native widget } $widget,
  Gnome::Gtk3::Container :_widget($container),
  Int :$_handler-id,
  N-GObject :$_native-object,
  *%user-options
)</pre><ul>
<li><p>$widget; The focussed child</p></li>
<li><p>$container; The instance which registered the signal</p></li>
<li><p>$_handler-id; The handler id which is returned from the registration</p></li>
<li><p>$_native-object; The native object provided by the caller wrapped in the Raku object.</p></li>
<li><p>%user-options; A list of named arguments provided at the <code>register-signal()</code> method</p></li>
</ul>

<h1 id="Signals_0"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Signals</a></h1>
<p>There are two ways to connect to a signal. The first option you have is to use <code>register-signal()</code> from <strong>Gnome::GObject::Object</strong>. The second option is to use <code>connect-object()</code> directly from <strong>Gnome::GObject::Signal</strong>.</p>
<h2 id="First_method"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">First method</a></h2>
<p>The positional arguments of the signal handler are all obligatory as well as their types. The named attributes <code>:$widget</code> and user data are optional.</p><pre class="pod-block-code"># handler method
method mouse-event ( GdkEvent $event, :$widget ) { ... }

# connect a signal on window object
my Gnome::Gtk3::Window $w .= new( ... );
$w.register-signal( self, 'mouse-event', 'button-press-event');</pre>
<h2 id="Second_method"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Second method</a></h2>
<pre class="pod-block-code">my Gnome::Gtk3::Window $w .= new( ... );
my Callable $handler = sub (
  N-GObject $native, GdkEvent $event, OpaquePointer $data
) {
  ...
}

$w.connect-object( 'button-press-event', $handler);</pre><p>Also here, the types of positional arguments in the signal handler are important. This is because both methods <code>register-signal()</code> and <code>connect-object()</code> are using the signatures of the handler routines to setup the native call interface.</p>
<h2 id="Supported_signals"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Supported signals</a></h2>

<h3 id="ade"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">add</a></h3>
<pre class="pod-block-code">method handler (
  N-GObject $n-gobject,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($container),
  *%user-options
);</pre><ul>
<li><p>$container;</p></li>
<li><p>$n-gobject; is added widget</p></li>
</ul>

<h3 id="removf"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">remove</a></h3>
<pre class="pod-block-code">method handler (
  N-GObject #`{ is widget } $n-gobject #`{ is widget },
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($container),
  *%user-options
);</pre><ul>
<li><p>$container;</p></li>
<li><p>$n-gobject #`{ is widget };</p></li>
</ul>

<h3 id="set-focus-chile"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">set-focus-child</a></h3>
<pre class="pod-block-code">method handler (
  N-GObject #`{ is widget } $n-gobject #`{ is widget },
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($container),
  *%user-options
);</pre><ul>
<li><p>$container;</p></li>
<li><p>$n-gobject #`{ is widget };</p></li>
</ul>

<h1 id="Properties"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">Properties</a></h1>

<h2 id="border-width"><a href="#Gnome::Gtk3::Container" class="u" title="go to top of document">border-width</a></h2>
<p>The width of the empty border outside the containers children</p><ul>
<li><p><strong>Gnome::GObject::Value</strong> type of this property is G_TYPE_UINT</p></li>
<li><p>Parameter is readable and writable.</p></li>
<li><p>Minimum value is 0.</p></li>
<li><p>Maximum value is 65535.</p></li>
<li><p>Default value is 0.</p></li>
</ul>
</section>		</div>
</div><footer><div>Rendered from <span class="path">/home/marcel/Languages/Raku/Projects/gnome-api1/gnome-gtk3/lib/Gnome/Gtk3/Container.rakumod</span></div><div>at <span class="time">2025-07-18T18:33:06Z</span></div></footer>
	</body>
</html>
