---
---
<!doctype html>
<html lang="en">
<head>
<title>Gnome::Gtk3::Widget</title>
<meta charset="UTF-8" />

<link href="asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />

</head>
	<body class="pod">
<header><img src="asset_files/images/gtk-raku.png" id="Camelia_bug"><h2 class="title" id="Gnome::Gtk3::Widget">Gnome::Gtk3::Widget</h2></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#Description">Description</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Height-for-width_Geometry_Management">Height-for-width Geometry Management</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Style_Properties">Style Properties</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Gnome::Gtk3::Widget_as_Gnome::Gtk3::Buildable">Gnome::Gtk3::Widget as Gnome::Gtk3::Buildable</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Synopsis">Synopsis</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Declaration">Declaration</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Uml_Diagram">Uml Diagram</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#"></a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Example">Example</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Types">Types</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#enum_GtkWidgetHelpType">enum GtkWidgetHelpType</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class_N-GtkRequisition">class N-GtkRequisition</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class_N-GtkAllocation">class N-GtkAllocation</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#activate">activate</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-accelerator">add-accelerator</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-device-events">add-device-events</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-events">add-events</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-mnemonic-label">add-mnemonic-label</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#add-tick-callback">add-tick-callback</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#can-activate-accel">can-activate-accel</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-focus">child-focus</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#child-notify">child-notify</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-bind-template-callback-full">class-bind-template-callback-full</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-bind-template-child-full">class-bind-template-child-full</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-find-style-property">class-find-style-property</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-get-css-name">class-get-css-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-install-style-property">class-install-style-property</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-install-style-property-parser">class-install-style-property-parser</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-list-style-properties">class-list-style-properties</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-set-accessible-role">class-set-accessible-role</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-set-accessible-type">class-set-accessible-type</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-set-connect-func">class-set-connect-func</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-set-css-name">class-set-css-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-set-template">class-set-template</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#class-set-template-from-resource">class-set-template-from-resource</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#compute-expand">compute-expand</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#create-pango-context">create-pango-context</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Example_0">Example</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#create-pango-layout">create-pango-layout</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#destroy">destroy</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#destroyed">destroyed</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#device-is-shadowed">device-is-shadowed</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#draw">draw</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#error-bell">error-bell</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#event">event</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#freeze-child-notify">freeze-child-notify</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-accessible">get-accessible</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-action-group">get-action-group</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-allocated-baseline">get-allocated-baseline</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-allocated-height">get-allocated-height</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-allocated-size">get-allocated-size</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-allocated-width">get-allocated-width</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-allocation">get-allocation</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-ancestor,_get-ancestor-rk">get-ancestor, get-ancestor-rk</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Examplf">Example</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-app-paintable">get-app-paintable</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-can-default">get-can-default</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-can-focus">get-can-focus</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-child-visible">get-child-visible</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-clip">get-clip</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-clipboard">get-clipboard</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-default-direction">get-default-direction</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-device-enabled">get-device-enabled</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-device-events">get-device-events</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-direction">get-direction</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-display,_get-display-rk">get-display, get-display-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-events">get-events</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-focus-on-click">get-focus-on-click</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-font-map">get-font-map</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-font-options">get-font-options</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-frame-clock">get-frame-clock</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-halign">get-halign</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-has-tooltip">get-has-tooltip</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-has-window">get-has-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-hexpand">get-hexpand</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-hexpand-set">get-hexpand-set</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-mapped">get-mapped</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-margin-bottom">get-margin-bottom</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-margin-end">get-margin-end</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-margin-start">get-margin-start</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-margin-top">get-margin-top</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-modifier-mask">get-modifier-mask</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-name">get-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-no-show-all">get-no-show-all</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-opacity">get-opacity</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-pango-context">get-pango-context</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-parent,_get-parent-rk">get-parent, get-parent-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-parent-window,_get-parent-window-rk">get-parent-window, get-parent-window-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-path,_get-path-rk">get-path, get-path-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-preferred-height">get-preferred-height</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-preferred-height-and-baseline-for-width">get-preferred-height-and-baseline-for-width</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-preferred-height-for-width">get-preferred-height-for-width</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-preferred-size">get-preferred-size</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-preferred-width">get-preferred-width</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-preferred-width-for-height">get-preferred-width-for-height</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-realized">get-realized</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-receives-default">get-receives-default</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-request-mode">get-request-mode</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-scale-factor">get-scale-factor</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-screen,_get-screen-rk">get-screen, get-screen-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-sensitive">get-sensitive</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-settings">get-settings</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-size-request">get-size-request</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-state-flags">get-state-flags</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-style-context,_get-style-context-rk">get-style-context, get-style-context-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-support-multidevice">get-support-multidevice</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-template-child">get-template-child</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-tooltip-markup">get-tooltip-markup</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-tooltip-text">get-tooltip-text</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-tooltip-window,_get-tooltip-window-rk">get-tooltip-window, get-tooltip-window-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-toplevel,_get-toplevel-rk">get-toplevel, get-toplevel-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-valign">get-valign</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-valign-with-baseline">get-valign-with-baseline</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-vexpand">get-vexpand</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-vexpand-set">get-vexpand-set</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-visible">get-visible</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-visual,_get-visual-rk">get-visual, get-visual-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-window">get-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#grab-default">grab-default</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#grab-focus">grab-focus</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#gtk-cairo-should-draw-window">gtk-cairo-should-draw-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#gtk-cairo-transform-to-window">gtk-cairo-transform-to-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#gtk-requisition-copy">gtk-requisition-copy</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#gtk-requisition-free">gtk-requisition-free</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#gtk-requisition-new">gtk-requisition-new</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#has-default">has-default</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#has-focus">has-focus</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#has-grab">has-grab</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#has-screen">has-screen</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#has-visible-focus">has-visible-focus</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#hide">hide</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#hide-on-delete">hide-on-delete</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#in-destruction">in-destruction</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#init-template">init-template</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#input-shape-combine-region">input-shape-combine-region</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#insert-action-group">insert-action-group</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#intersect">intersect</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#is-ancestor">is-ancestor</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#is-drawable">is-drawable</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#is-focus">is-focus</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#is-sensitive">is-sensitive</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#is-toplevel">is-toplevel</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#is-visible">is-visible</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#keynav-failed">keynav-failed</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#list-accel-closures">list-accel-closures</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#list-action-prefixes">list-action-prefixes</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#list-mnemonic-labels,_list-mnemonic-labels-rk">list-mnemonic-labels, list-mnemonic-labels-rk</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#map">map</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#mnemonic-activate">mnemonic-activate</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#queue-allocate">queue-allocate</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#queue-compute-expand">queue-compute-expand</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#queue-draw">queue-draw</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#queue-draw-area">queue-draw-area</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#queue-draw-region">queue-draw-region</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#queue-resize">queue-resize</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#queue-resize-no-redraw">queue-resize-no-redraw</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#realize">realize</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#register-window">register-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-accelerator">remove-accelerator</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-mnemonic-label">remove-mnemonic-label</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#remove-tick-callback">remove-tick-callback</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#reset-style">reset-style</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#send-focus-change">send-focus-change</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-accel-path">set-accel-path</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-allocation">set-allocation</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-app-paintable">set-app-paintable</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-can-default">set-can-default</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-can-focus">set-can-focus</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-child-visible">set-child-visible</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-clip">set-clip</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-default-direction">set-default-direction</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-device-enabled">set-device-enabled</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-device-events">set-device-events</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-direction">set-direction</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-events">set-events</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-focus-on-click">set-focus-on-click</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-font-map">set-font-map</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-font-options">set-font-options</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-halign">set-halign</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-has-tooltip">set-has-tooltip</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-has-window">set-has-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-hexpand">set-hexpand</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-hexpand-set">set-hexpand-set</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-mapped">set-mapped</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-margin-bottom">set-margin-bottom</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-margin-end">set-margin-end</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-margin-start">set-margin-start</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-margin-top">set-margin-top</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-name">set-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-no-show-all">set-no-show-all</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-opacity">set-opacity</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-parent">set-parent</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-parent-window">set-parent-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-realized">set-realized</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-receives-default">set-receives-default</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-redraw-on-allocate">set-redraw-on-allocate</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-sensitive">set-sensitive</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-size-request">set-size-request</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-state-flags">set-state-flags</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-support-multidevice">set-support-multidevice</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-tooltip-markup">set-tooltip-markup</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-tooltip-text">set-tooltip-text</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-tooltip-window">set-tooltip-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-valign">set-valign</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-vexpand">set-vexpand</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-vexpand-set">set-vexpand-set</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-visible">set-visible</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-visual">set-visual</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-window">set-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#shape-combine-region">shape-combine-region</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#show">show</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#show-all">show-all</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#show-now">show-now</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#size-allocate">size-allocate</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#size-allocate-with-baseline">size-allocate-with-baseline</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#style-get">style-get</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#style-get-property">style-get-property</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#style-get-valist">style-get-valist</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#thaw-child-notify">thaw-child-notify</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#translate-coordinates">translate-coordinates</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#trigger-tooltip-query">trigger-tooltip-query</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#unmap">unmap</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#unparent">unparent</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#unrealize">unrealize</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#unregister-window">unregister-window</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#unset-state-flags">unset-state-flags</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#_gtk_widget_new">_gtk_widget_new</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Signals">Signals</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#First_method">First method</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Second_method">Second method</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Supported_signals">Supported signals</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#accel-closures-changed">accel-closures-changed</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#button-press-event">button-press-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#button-release-event">button-release-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#configure-event">configure-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#damage-event">damage-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#delete-event">delete-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#destroy_0">destroy</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#destroy-event">destroy-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#direction-changed">direction-changed</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-begin">drag-begin</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-data-delete">drag-data-delete</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-data-get">drag-data-get</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-data-received">drag-data-received</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-drop">drag-drop</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-end">drag-end</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-failed">drag-failed</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-leave">drag-leave</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#drag-motion">drag-motion</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#draw_0">draw</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#enter-notify-event">enter-notify-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#event_0">event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#event-after">event-after</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#focus">focus</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#focus-in-event">focus-in-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#focus-out-event">focus-out-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#grab-broken-event">grab-broken-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#grab-focus_0">grab-focus</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#grab-notify">grab-notify</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#hide_0">hide</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#hierarchy-changed">hierarchy-changed</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#key-press-event">key-press-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#key-release-event">key-release-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#keynav-failed_0">keynav-failed</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#leave-notify-event">leave-notify-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#map_0">map</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#map-event">map-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#mnemonic-activate_0">mnemonic-activate</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#motion-notify-event">motion-notify-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#move-focus">move-focus</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#parent-set">parent-set</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#popup-menu">popup-menu</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#property-notify-event">property-notify-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#proximity-in-event">proximity-in-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#proximity-out-event">proximity-out-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#query-tooltip">query-tooltip</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#realize_0">realize</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#screen-changed">screen-changed</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#scroll-event">scroll-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#selection-clear-event">selection-clear-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#selection-get">selection-get</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#selection-notify-event">selection-notify-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#selection-received">selection-received</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#selection-request-event">selection-request-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#show_0">show</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#show-help">show-help</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#size-allocate_0">size-allocate</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#state-flags-changed">state-flags-changed</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#style-updated">style-updated</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#unmap_0">unmap</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#unmap-event">unmap-event</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#unrealize_0">unrealize</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#window-state-event">window-state-event</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Properties">Properties</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Supported_properties">Supported properties</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Application_paintable:_app-paintable">Application paintable: app-paintable</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Can_default:_can-default">Can default: can-default</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Can_focus:_can-focus">Can focus: can-focus</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Composite_child:_composite-child">Composite child: composite-child</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Events:_events">Events: events</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Expand_Both:_expand">Expand Both: expand</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Focus_on_click:_focus-on-click">Focus on click: focus-on-click</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Horizontal_Alignment:_halign">Horizontal Alignment: halign</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Has_default:_has-default">Has default: has-default</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Has_focus:_has-focus">Has focus: has-focus</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Has_tooltip:_has-tooltip">Has tooltip: has-tooltip</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Height_request:_height-request">Height request: height-request</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Horizontal_Expand:_hexpand">Horizontal Expand: hexpand</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Horizontal_Expand_Set:_hexpand-set">Horizontal Expand Set: hexpand-set</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Is_focus:_is-focus">Is focus: is-focus</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#All_Margins:_margin">All Margins: margin</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Margin_on_Bottom:_margin-bottom">Margin on Bottom: margin-bottom</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Margin_on_End:_margin-end">Margin on End: margin-end</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Margin_on_Start:_margin-start">Margin on Start: margin-start</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Margin_on_Top:_margin-top">Margin on Top: margin-top</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Widget_name:_name">Widget name: name</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#No_show_all:_no-show-all">No show all: no-show-all</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Opacity_for_Widget:_opacity">Opacity for Widget: opacity</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Parent_widget:_parent">Parent widget: parent</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Receives_default:_receives-default">Receives default: receives-default</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Scale_factor:_scale-factor">Scale factor: scale-factor</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Sensitive:_sensitive">Sensitive: sensitive</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Tooltip_markup:_tooltip-markup">Tooltip markup: tooltip-markup</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Tooltip_Text:_tooltip-text">Tooltip Text: tooltip-text</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Vertical_Alignment:_valign">Vertical Alignment: valign</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Vertical_Expand:_vexpand">Vertical Expand: vexpand</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Vertical_Expand_Set:_vexpand-set">Vertical Expand Set: vexpand-set</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Visible:_visible">Visible: visible</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Width_request:_width-request">Width request: width-request</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Window:_window">Window: window</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top"><p>Base class for all widgets</p>
<h1 id="Description"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Description</a></h1>
<p><strong>Gnome::Gtk3::Widget</strong> is the base class all widgets in this package derive from. It manages the widget lifecycle, states and style.</p>
<h2 id="Height-for-width_Geometry_Management"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Height-for-width Geometry Management</a></h2>
<p>GTK+ uses a height-for-width (and width-for-height) geometry management system. Height-for-width means that a widget can change how much vertical space it needs, depending on the amount of horizontal space that it is given (and similar for width-for-height). The most common example is a label that reflows to fill up the available width, wraps to fewer lines, and therefore needs less height.</p><p>Height-for-width geometry management is implemented in GTK+ by way of five virtual methods:</p><ul>
<li><p><code>get_request_mode()</code></p></li>
<li><p><code>get_preferred_width()</code></p></li>
<li><p><code>get_preferred_height()</code></p></li>
<li><p><code>get_preferred_height_for_width()</code></p></li>
<li><p><code>get_preferred_width_for_height()</code></p></li>
<li><p><code>get_preferred_height_and_baseline_for_width()</code></p></li>
</ul>
<p>There are some important things to keep in mind when implementing height-for-width and when using it in container implementations.</p><p>The geometry management system will query a widget hierarchy in only one orientation at a time. When widgets are initially queried for their minimum sizes it is generally done in two initial passes in the <code>GtkSizeRequestMode</code> chosen by the toplevel.</p><p>For example, when queried in the normal <code>GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH</code> mode:</p><ul>
<li><p>First, the default minimum and natural width for each widget in the interface will be computed using <code>gtk_widget_get_preferred_width()</code>. Because the preferred widths for each container depend on the preferre1d widths of their children, this information propagates up the hierarchy, and finally a minimum and natural width is determined for the entire toplevel.</p></li>
<li><p>Next, the toplevel will use the minimum width to query for the minimum height contextual to that width using <code>gtk_widget_get_preferred_height_for_width()</code>, which will also be a highly recursive operation. The minimum height for the minimum width is normally used to set the minimum size constraint on the toplevel (unless <code>gtk_window_set_geometry_hints()</code> is explicitly used instead).</p></li>
</ul>
<p>After the toplevel window has initially requested its size in both dimensions it can go on to allocate itself a reasonable size (or a size previously specified with <code>gtk_window_set_default_size()</code>). During the recursive allocation process it’s important to note that request cycles will be recursively executed while container widgets allocate their children. Each container widget, once allocated a size, will go on to first share the space in one orientation among its children and then request each child's height for its target allocated width or its width for allocated height, depending.</p><p>In this way a <strong>Gnome::Gtk3::Widget</strong> will typically be requested its size a number of times before actually being allocated a size. The size a widget is finally allocated can of course differ from the size it has requested. For this reason, <strong>Gnome::Gtk3::Widget</strong> caches a small number of results to avoid re-querying for the same sizes in one allocation cycle.</p><p>See [Gnome::Gtk3::Container’s geometry management section](https://developer.gnome.org/gtk3/stable/GtkContainer.html) to learn more about how height-for-width allocations are performed by container widgets.</p><p>If a widget does move content around to intelligently use up the allocated size then it must support the request in both <code>GtkSizeRequestMode</code>s even if the widget in question only trades sizes in a single orientation.</p><p>For instance, a <strong>Gnome::Gtk3::Label</strong> that does height-for-width word wrapping will not expect to have <code>get_preferred_height()</code> called because that call is specific to a width-for-height request. In this case the label must return the height required for its own minimum possible width. By following this rule any widget that handles height-for-width or width-for-height requests will always be allocated at least enough space to fit its own content.</p><p>Since 3.10 GTK+ also supports baseline vertical alignment of widgets. This means that widgets are positioned such that the typographical baseline of widgets in the same row are aligned. This happens if a widget supports baselines, has a vertical alignment of <code>GTK_ALIGN_BASELINE</code>, and is inside a container that supports baselines and has a natural “row” that it aligns to the baseline, or a baseline assigned to it by the grandparent.</p><p>Baseline alignment support for a widget is done by the <code>get_preferred_height_and_baseline_for_width()</code> virtual function. It allows you to report a baseline in combination with the minimum and natural height. If there is no baseline you can return -1 to indicate this. The default implementation of this virtual function calls into the <code>get_preferred_height()</code> and <code>get_preferred_height_for_width()</code>, so if baselines are not supported it doesn’t need to be implemented.</p><p>If a widget ends up baseline aligned it will be allocated all the space in the parent as if it was <code>GTK_ALIGN_FILL</code>, but the selected baseline can be found via <code>gtk_widget_get_allocated_baseline()</code>. If this has a value other than -1 you need to align the widget such that the baseline appears at the position.</p>
<h2 id="Style_Properties"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Style Properties</a></h2>
<p><strong>Gnome::Gtk3::Widget</strong> introduces “style properties” - these are basically object properties that are stored not on the object, but in the style object associated to the widget. Style properties are set in gtk resource files. This mechanism is used for configuring such things as the location of the scrollbar arrows through the theme, giving theme authors more control over the look of applications without the need to write a theme engine in C.</p><p>Use <code>gtk_widget_class_install_style_property()</code> to install style properties for a widget class, <code>gtk_widget_class_find_style_property()</code> or <code>gtk_widget_class_list_style_properties()</code> to get information about existing style properties and <code>gtk_widget_style_get_property()</code>, <code>gtk_widget_style_get()</code> or <code>gtk_widget_style_get_valist()</code> to obtain the value of a style property.</p>
<h2 id="Gnome::Gtk3::Widget_as_Gnome::Gtk3::Buildable"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Gnome::Gtk3::Widget as Gnome::Gtk3::Buildable</a></h2>
<p>The <strong>Gnome::Gtk3::Widget</strong> implementation of the <strong>Gnome::Gtk3::Buildable</strong> interface supports a custom &lt;accelerator&gt; element, which has attributes named ”key”, ”modifiers” and ”signal” and allows to specify accelerators.</p><p>An example of a UI definition fragment specifying an accelerator (please note that in this XML the C-Source widget class names must be used; GtkButton instead of Gnome::Gtk3::Button):</p><pre class="pod-block-code">&lt;object class=&quot;GtkButton&quot;&gt;
  &lt;accelerator key=&quot;q&quot; modifiers=&quot;GDK_CONTROL_MASK&quot; signal=&quot;clicked&quot;/&gt;
&lt;/object&gt;</pre><p>In addition to accelerators, <strong>Gnome::Gtk3::Widget</strong> also support a custom &lt;accessible&gt; element, which supports actions and relations. Properties on the accessible implementation of an object can be set by accessing the internal child “accessible” of a <strong>Gnome::Gtk3::Widget</strong>.</p><p>An example of a UI definition fragment specifying an accessible:</p><pre class="pod-block-code">&lt;object class=&quot;GtkButton&quot; id=&quot;label1&quot;/&gt;
  &lt;property name=&quot;label&quot;&gt;I am a Label for a Button&lt;/property&gt;
&lt;/object&gt;
&lt;object class=&quot;GtkButton&quot; id=&quot;button1&quot;&gt;
  &lt;accessibility&gt;
    &lt;action action_name=&quot;click&quot; translatable=&quot;yes&quot;&gt;
      Click the button.
    &lt;/action&gt;
    &lt;relation target=&quot;label1&quot; type=&quot;labelled-by&quot;/&gt;
  &lt;/accessibility&gt;
  &lt;child internal-child=&quot;accessible&quot;&gt;
    &lt;object class=&quot;AtkObject&quot; id=&quot;a11y-button1&quot;&gt;
      &lt;property name=&quot;accessible-name&quot;&gt;
        Clickable Button
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/child&gt;
&lt;/object&gt;</pre><p>Finally, <strong>Gnome::Gtk3::Widget</strong> allows style information such as style classes to be associated with widgets, using the custom &lt;style&gt; element:</p><pre class="pod-block-code">&lt;object class=&quot;GtkButton&gt;&quot; id=&quot;button1&quot;&gt;
  &lt;style&gt;
    &lt;class name=&quot;my-special-button-class&quot;/&gt;
    &lt;class name=&quot;dark-button&quot;/&gt;
  &lt;/style&gt;
&lt;/object&gt;</pre>
<h1 id="Synopsis"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Synopsis</a></h1>

<h2 id="Declaration"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Declaration</a></h2>
<pre class="pod-block-code">unit class Gnome::Gtk3::Widget;
also is Gnome::GObject::InitiallyUnowned;
also does Gnome::Gtk3::Buildable;</pre>
<h2 id="Uml_Diagram"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Uml Diagram</a></h2>
<div class="image-container inline"><img src="asset_files/images/plantuml/Widget.svg" width="60%" height="auto" alt="No caption"></div>

<h2 id="Example"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Example</a></h2>
<pre class="pod-block-code"># create a button and set a tooltip
my Gnome::Gtk3::Button $start-button .= new(:label&lt;Start&gt;);
$start-button.set-tooltip-text('Nooooo don\'t touch that button!!!!!!!');</pre>
<h1 id="Types"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Types</a></h1>

<h2 id="enum_GtkWidgetHelpType"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">enum GtkWidgetHelpType</a></h2>
<p>Kinds of widget-specific help. Used by the ::show-help signal.</p><ul>
<li><p>GTK_WIDGET_HELP_TOOLTIP: Tooltip.</p></li>
<li><p>GTK_WIDGET_HELP_WHATS_THIS: What’s this.</p></li>
</ul>

<h2 id="class_N-GtkRequisition"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class N-GtkRequisition</a></h2>
<p>A <strong>Gnome::Gtk3::Requisition</strong>-struct represents the desired size of a widget. See [<strong>Gnome::Gtk3::Widget</strong>’s geometry management section][geometry-management] for more information.</p><ul>
<li><p>Int $.width: the widget’s desired width</p></li>
<li><p>Int $.height: the widget’s desired height</p></li>
</ul>

<h2 id="class_N-GtkAllocation"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class N-GtkAllocation</a></h2>
<p>A N-GtkAllocation of a widget represents a region which has been allocated to the widget by its parent. It is a subregion of its parents allocation. See GtkWidget’s geometry management section for more information.</p><ul>
<li><p>Int $.x;</p></li>
<li><p>Int $.y;</p></li>
<li><p>Int $.width;</p></li>
<li><p>Int $.height;</p></li>
</ul>

<h1 id="Methods"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Methods</a></h1>

<h2 id="activate"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">activate</a></h2>
<p>For widgets that can be “activated” (buttons, menu items, etc.) this function activates them. Activation is what happens when you press Enter on a widget during key navigation. If <em>widget</em> isn't activatable, the function returns <code>False</code>.</p><p>Returns: <code>True</code> if the widget was activatable</p><pre class="pod-block-code">method activate ( --&gt; Bool )</pre>
<h2 id="add-accelerator"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">add-accelerator</a></h2>
<p>Installs an accelerator for this <em>widget</em> in <em>accel-group</em> that causes <em>accel-signal</em> to be emitted if the accelerator is activated. The <em>accel-group</em> needs to be added to the widget’s toplevel via <code>gtk-window-add-accel-group()</code>, and the signal must be of type <code>G-SIGNAL-ACTION</code>. Accelerators added through this function are not user changeable during runtime. If you want to support accelerators that can be changed by the user, use <code>gtk-accel-map-add-entry()</code> and <code>set-accel-path()</code> or <code>gtk-menu-item-set-accel-path()</code> instead.</p><pre class="pod-block-code">method add-accelerator ( Str $accel_signal, N-GObject $accel_group, UInt $accel_key, GdkModifierType $accel_mods, GtkAccelFlags $accel_flags )</pre><ul>
<li><p>Str $accel_signal; widget signal to emit on accelerator activation</p></li>
<li><p>N-GObject $accel_group; accel group for this widget, added to its toplevel</p></li>
<li><p>UInt $accel_key; GDK keyval of the accelerator</p></li>
<li><p>GdkModifierType $accel_mods; modifier key combination of the accelerator</p></li>
<li><p>GtkAccelFlags $accel_flags; flag accelerators, e.g. <code>GTK-ACCEL-VISIBLE</code></p></li>
</ul>

<h2 id="add-device-events"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">add-device-events</a></h2>
<p>Adds the device events in the bitfield <em>events</em> to the event mask for <em>widget</em>. See <code>set-device-events()</code> for details.</p><pre class="pod-block-code">method add-device-events ( N-GObject $device, Int $events )</pre><ul>
<li><p>N-GObject $device; a <strong>Gnome::Gdk3::Device</strong></p></li>
<li><p>Int $events; an event mask. Mask bit values are from GdkEventMask.</p></li>
</ul>

<h2 id="add-events"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">add-events</a></h2>
<p>Adds the events in the bitfield <em>$events</em> to the event mask for <em>widget</em>. See <code>set-events()</code> and the <a href="https://developer.gnome.org/gtk3/stable/chap-input-handling.html#event-masks">input handling overview</a> for details.</p><pre class="pod-block-code">method add-events ( Int $events )</pre><ul>
<li><p>Int $events; an event mask, see GdkEventMask in <strong>Gnome::Gdk3::Types</strong>.</p></li>
</ul>

<h2 id="add-mnemonic-label"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">add-mnemonic-label</a></h2>
<p>Adds a widget to the list of mnemonic labels for this widget. (See <code>list-mnemonic-labels()</code>). Note the list of mnemonic labels for the widget is cleared when the widget is destroyed, so the caller must make sure to update its internal state at this point as well, by using a connection to the <em>destroy</em> signal or a weak notifier.</p><pre class="pod-block-code">method add-mnemonic-label ( N-GObject $label )</pre><ul>
<li><p>N-GObject $label; a <strong>Gnome::Gtk3::Widget</strong> that acts as a mnemonic label for <em>widget</em></p></li>
</ul>

<h2 id="add-tick-callback"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">add-tick-callback</a></h2>
<p>Queues an animation frame update and adds a callback to be called before each frame. Until the tick callback is removed, it will be called frequently (usually at the frame rate of the output device or as quickly as the application can be repainted, whichever is slower). For this reason, is most suitable for handling graphics that change every frame or every few frames. The tick callback does not automatically imply a relayout or repaint. If you want a repaint or relayout, and aren’t changing widget properties that would trigger that (for example, changing the text of a <strong>Gnome::Gtk3::Label</strong>), then you will have to call <code>queue-resize()</code> or <code>queue-draw-area()</code> yourself.</p><p><code>gdk-frame-clock-get-frame-time()</code> should generally be used for timing continuous animations and <code>gdk-frame-timings-get-predicted-presentation-time()</code> if you are trying to display isolated frames at particular times.</p><p>This is a more convenient alternative to connecting directly to the <em>update</em> signal of <strong>Gnome::Gdk3::FrameClock</strong>, since you don't have to worry about when a <strong>Gnome::Gdk3::FrameClock</strong> is assigned to a widget.</p><p>Returns: an id for the connection of this callback. Remove the callback by passing it to <code>remove-tick-callback()</code></p><pre class="pod-block-code">method add-tick-callback ( GtkTickCallback $callback, Pointer $user_data, GDestroyNotify $notify --&gt; UInt )</pre><ul>
<li><p>GtkTickCallback $callback; function to call for updating animations</p></li>
<li><p>Pointer $user_data; data to pass to <em>callback</em></p></li>
<li><p>GDestroyNotify $notify; function to call to free <em>user-data</em> when the callback is removed.</p></li>
</ul>

<h2 id="can-activate-accel"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">can-activate-accel</a></h2>
<p>Determines whether an accelerator that activates the signal identified by <em>signal-id</em> can currently be activated. This is done by emitting the <em>can-activate-accel</em> signal on <em>widget</em>; if the signal isn’t overridden by a handler or in a derived widget, then the default check is that the widget must be sensitive, and the widget and all its ancestors mapped.</p><p>Returns: <code>True</code> if the accelerator can be activated.</p><pre class="pod-block-code">method can-activate-accel ( UInt $signal_id --&gt; Bool )</pre><ul>
<li><p>UInt $signal_id; the ID of a signal installed on <em>widget</em></p></li>
</ul>

<h2 id="child-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">child-focus</a></h2>
<p>This function is used by custom widget implementations; if you're writing an app, you’d use <code>grab-focus()</code> to move the focus to a particular widget, and <code>gtk-container-set-focus-chain()</code> to change the focus tab order. So you may want to investigate those functions instead.</p><p><code>child-focus()</code> is called by containers as the user moves around the window using keyboard shortcuts. <em>direction</em> indicates what kind of motion is taking place (up, down, left, right, tab forward, tab backward). <code>child-focus()</code> emits the <em>focus</em> signal; widgets override the default handler for this signal in order to implement appropriate focus behavior.</p><p>The default <em>focus</em> handler for a widget should return <code>True</code> if moving in <em>direction</em> left the focus on a focusable location inside that widget, and <code>False</code> if moving in <em>direction</em> moved the focus outside the widget. If returning <code>True</code>, widgets normally call <code>grab-focus()</code> to place the focus accordingly; if returning <code>False</code>, they don’t modify the current focus location.</p><p>Returns: <code>True</code> if focus ended up inside <em>widget</em></p><pre class="pod-block-code">method child-focus ( GtkDirectionType $direction --&gt; Bool )</pre><ul>
<li><p>GtkDirectionType $direction; direction of focus movement</p></li>
</ul>

<h2 id="child-notify"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">child-notify</a></h2>
<p>Emits a <em>child-notify</em> signal for the [child property][child-properties] <em>child-property</em> on <em>widget</em>.</p><p>This is the analogue of <code>g-object-notify()</code> for child properties.</p><p>Also see <code>gtk-container-child-notify()</code>.</p><pre class="pod-block-code">method child-notify ( Str $child_property )</pre><ul>
<li><p>Str $child_property; the name of a child property installed on the class of <em>widget</em>’s parent</p></li>
</ul>

<h2 id="class-bind-template-callback-full"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-bind-template-callback-full</a></h2>
<p>Declares a <em>callback-symbol</em> to handle <em>callback-name</em> from the template XML defined for <em>widget-type</em>. See <code>gtk-builder-add-callback-symbol()</code>.</p><p>Note that this must be called from a composite widget classes class initializer after calling <code>class-set-template()</code>.</p><pre class="pod-block-code">method class-bind-template-callback-full ( GtkWidgetClass $widget_class, Str $callback_name, GCallback $callback_symbol )</pre><ul>
<li><p>GtkWidgetClass $widget_class; A <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>Str $callback_name; The name of the callback as expected in the template XML</p></li>
<li><p>GCallback $callback_symbol; (scope async): The callback symbol</p></li>
</ul>

<h2 id="class-bind-template-child-full"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-bind-template-child-full</a></h2>
<p>Automatically assign an object declared in the class template XML to be set to a location on a freshly built instance’s private data, or alternatively accessible via <code>get-template-child()</code>.</p><p>The struct can point either into the public instance, then you should use G-STRUCT-OFFSET(WidgetType, member) for <em>struct-offset</em>, or in the private struct, then you should use G-PRIVATE-OFFSET(WidgetType, member).</p><p>An explicit strong reference will be held automatically for the duration of your instance’s life cycle, it will be released automatically when <strong>Gnome::Gtk3::ObjectClass</strong>.<code>dispose()</code> runs on your instance and if a <em>struct-offset</em> that is != 0 is specified, then the automatic location in your instance public or private data will be set to <code>undefined</code>. You can however access an automated child pointer the first time your classes <strong>Gnome::Gtk3::ObjectClass</strong>.<code>dispose()</code> runs, or alternatively in <strong>Gnome::Gtk3::WidgetClass</strong>.<code>destroy()</code>.</p><p>If <em>internal-child</em> is specified, <strong>Gnome::Gtk3::BuildableIface</strong>.<code>get-internal-child()</code> will be automatically implemented by the <strong>Gnome::Gtk3::Widget</strong> class so there is no need to implement it manually.</p><p>The wrapper macros <code>class-bind-template-child()</code>, <code>class-bind-template-child-internal()</code>, <code>class-bind-template-child-private()</code> and <code>class-bind-template-child-internal-private()</code> might be more convenient to use.</p><p>Note that this must be called from a composite widget classes class initializer after calling <code>class-set-template()</code>.</p><pre class="pod-block-code">method class-bind-template-child-full ( GtkWidgetClass $widget_class, Str $name, Bool $internal_child, Int $struct_offset )</pre><ul>
<li><p>GtkWidgetClass $widget_class; A <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>Str $name; The “id” of the child defined in the template XML</p></li>
<li><p>Bool $internal_child; Whether the child should be accessible as an “internal-child” when this class is used in GtkBuilder XML</p></li>
<li><p>Int $struct_offset; The structure offset into the composite widget’s instance public or private structure where the automated child pointer should be set, or 0 to not assign the pointer.</p></li>
</ul>

<h2 id="class-find-style-property"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-find-style-property</a></h2>
<p>Finds a style property of a widget class by name.</p><p>Returns: the <strong>Gnome::Gtk3::ParamSpec</strong> of the style property or <code>undefined</code> if <em>class</em> has no style property with that name.</p><pre class="pod-block-code">method class-find-style-property ( GtkWidgetClass $klass, Str $property_name --&gt; GParamSpec )</pre><ul>
<li><p>GtkWidgetClass $klass; a <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>Str $property_name; the name of the style property to find</p></li>
</ul>

<h2 id="class-get-css-name"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-get-css-name</a></h2>
<p>Gets the name used by this class for matching in CSS code. See <code>class-set-css-name()</code> for details.</p><p>Returns: the CSS name of the given class</p><pre class="pod-block-code">method class-get-css-name ( GtkWidgetClass $widget_class --&gt; Str )</pre><ul>
<li><p>GtkWidgetClass $widget_class; class to set the name on</p></li>
</ul>

<h2 id="class-install-style-property"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-install-style-property</a></h2>
<p>Installs a style property on a widget class. The parser for the style property is determined by the value type of <em>pspec</em>.</p><pre class="pod-block-code">method class-install-style-property ( GtkWidgetClass $klass, GParamSpec $pspec )</pre><ul>
<li><p>GtkWidgetClass $klass; a <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>GParamSpec $pspec; the <strong>Gnome::Gtk3::ParamSpec</strong> for the property</p></li>
</ul>

<h2 id="class-install-style-property-parser"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-install-style-property-parser</a></h2>
<p>Installs a style property on a widget class.</p><pre class="pod-block-code">method class-install-style-property-parser ( GtkWidgetClass $klass, GParamSpec $pspec, GtkRcPropertyParser $parser )</pre><ul>
<li><p>GtkWidgetClass $klass; a <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>GParamSpec $pspec; the <strong>Gnome::Gtk3::ParamSpec</strong> for the style property</p></li>
<li><p>GtkRcPropertyParser $parser; the parser for the style property</p></li>
</ul>

<h2 id="class-list-style-properties"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-list-style-properties</a></h2>
<p>Returns all style properties of a widget class.</p><p>Returns: (array length=n-properties) (transfer container): a newly allocated array of <strong>Gnome::Gtk3::ParamSpec</strong>*. The array must be freed with <code>g-free()</code>.</p><pre class="pod-block-code">method class-list-style-properties ( GtkWidgetClass $klass, guint $n_properties --&gt; GParamSpec )</pre><ul>
<li><p>GtkWidgetClass $klass; a <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>guInt-ptr $n_properties; location to return the number of style properties found</p></li>
</ul>

<h2 id="class-set-accessible-role"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-set-accessible-role</a></h2>
<p>Sets the default <strong>AtkRole</strong> to be set on accessibles created for widgets of <em>widget-class</em>. Accessibles may decide to not honor this setting if their role reporting is more refined. Calls to <code>class-set-accessible-type()</code> will reset this value.</p><p>In cases where you want more fine-grained control over the role of accessibles created for <em>widget-class</em>, you should provide your own accessible type and use <code>class-set-accessible-type()</code> instead.</p><p>If <em>role</em> is <strong>ATK-ROLE-INVALID</strong>, the default role will not be changed and the accessible’s default role will be used instead.</p><p>This function should only be called from class init functions of widgets.</p><pre class="pod-block-code">method class-set-accessible-role ( GtkWidgetClass $widget_class, AtkRole $role )</pre><ul>
<li><p>GtkWidgetClass $widget_class; class to set the accessible role for</p></li>
<li><p>AtkRole $role; The role to use for accessibles created for <em>widget-class</em></p></li>
</ul>

<h2 id="class-set-accessible-type"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-set-accessible-type</a></h2>
<p>Sets the type to be used for creating accessibles for widgets of <em>widget-class</em>. The given <em>type</em> must be a subtype of the type used for accessibles of the parent class.</p><p>This function should only be called from class init functions of widgets.</p><pre class="pod-block-code">method class-set-accessible-type ( GtkWidgetClass $widget_class, N-GObject $type )</pre><ul>
<li><p>GtkWidgetClass $widget_class; class to set the accessible type for</p></li>
<li><p>N-GObject $type; The object type that implements the accessible for <em>widget-class</em></p></li>
</ul>

<h2 id="class-set-connect-func"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-set-connect-func</a></h2>
<p>For use in language bindings, this will override the default <strong>Gnome::Gtk3::BuilderConnectFunc</strong> to be used when parsing GtkBuilder XML from this class’s template data.</p><p>Note that this must be called from a composite widget classes class initializer after calling <code>class-set-template()</code>.</p><pre class="pod-block-code">method class-set-connect-func ( GtkWidgetClass $widget_class, GtkBuilderConnectFunc $connect_func, Pointer $connect_data, GDestroyNotify $connect_data_destroy )</pre><ul>
<li><p>GtkWidgetClass $widget_class; A <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>GtkBuilderConnectFunc $connect_func; The <strong>Gnome::Gtk3::BuilderConnectFunc</strong> to use when connecting signals in the class template</p></li>
<li><p>Pointer $connect_data; The data to pass to <em>connect-func</em></p></li>
<li><p>GDestroyNotify $connect_data_destroy; The <strong>Gnome::Gtk3::DestroyNotify</strong> to free <em>connect-data</em>, this will only be used at class finalization time, when no classes of type <em>widget-type</em> are in use anymore.</p></li>
</ul>

<h2 id="class-set-css-name"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-set-css-name</a></h2>
<p>Sets the name to be used for CSS matching of widgets.</p><p>If this function is not called for a given class, the name of the parent class is used.</p><pre class="pod-block-code">method class-set-css-name ( GtkWidgetClass $widget_class, Str $name )</pre><ul>
<li><p>GtkWidgetClass $widget_class; class to set the name on</p></li>
<li><p>Str $name; name to use</p></li>
</ul>

<h2 id="class-set-template"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-set-template</a></h2>
<p>This should be called at class initialization time to specify the GtkBuilder XML to be used to extend a widget.</p><p>For convenience, <code>class-set-template-from-resource()</code> is also provided.</p><p>Note that any class that installs templates must call <code>init-template()</code> in the widget’s instance initializer.</p><pre class="pod-block-code">method class-set-template ( GtkWidgetClass $widget_class, N-GObject $template_bytes )</pre><ul>
<li><p>GtkWidgetClass $widget_class; A <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>N-GObject $template_bytes; A <strong>Gnome::Gtk3::Bytes</strong> holding the <strong>Gnome::Gtk3::Builder</strong> XML</p></li>
</ul>

<h2 id="class-set-template-from-resource"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">class-set-template-from-resource</a></h2>
<p>A convenience function to call <code>class-set-template()</code>.</p><p>Note that any class that installs templates must call <code>init-template()</code> in the widget’s instance initializer.</p><pre class="pod-block-code">method class-set-template-from-resource ( GtkWidgetClass $widget_class, Str $resource_name )</pre><ul>
<li><p>GtkWidgetClass $widget_class; A <strong>Gnome::Gtk3::WidgetClass</strong></p></li>
<li><p>Str $resource_name; The name of the resource to load the template from</p></li>
</ul>

<h2 id="compute-expand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">compute-expand</a></h2>
<p>Computes whether a container should give this widget extra space when possible. Containers should check this, rather than looking at <code>get-hexpand()</code> or <code>get-vexpand()</code>.</p><p>This function already checks whether the widget is visible, so visibility does not need to be checked separately. Non-visible widgets are not expanded.</p><p>The computed expand value uses either the expand setting explicitly set on the widget itself, or, if none has been explicitly set, the widget may expand if some of its children do.</p><p>Returns: whether widget tree rooted here should be expanded</p><pre class="pod-block-code">method compute-expand ( GtkOrientation $orientation --&gt; Bool )</pre><ul>
<li><p>GtkOrientation $orientation; expand direction</p></li>
</ul>

<h2 id="create-pango-context"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">create-pango-context</a></h2>
<p>Creates a new native <strong>Gnome::Pango::Context</strong> with the appropriate font map, font options, font description, and base direction for drawing text for this widget. See also <code>.get-pango-context()</code>.</p><pre class="pod-block-code">method create-pango-context ( --&gt; N-GObject )</pre>
<h3 id="Example_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Example</a></h3>
<pre class="pod-block-code">use Gnome::Gtk3::Button:api&lt;1&gt;;
use Gnome::Pango::Context:api&lt;1&gt;;

my $button .= new(:label&lt;start&gt;);
my Gnome::Pango::Context() $pcontext = $button.create-pango-context;</pre>
<h2 id="create-pango-layout"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">create-pango-layout</a></h2>
<p>Creates a new <strong>PangoLayout</strong> with the appropriate font map, font description, and base direction for drawing text for this widget.</p><p>If you keep a <strong>PangoLayout</strong> created in this way around, you need to re-create it when the widget <strong>PangoContext</strong> is replaced. This can be tracked by using the <em>screen-changed</em> signal on the widget.</p><p>Returns: the new <strong>PangoLayout</strong></p><pre class="pod-block-code">method create-pango-layout ( Str $text --&gt; N-GObject )</pre><ul>
<li><p>Str $text; text to set on the layout (can be <code>undefined</code>)</p></li>
</ul>

<h2 id="destroy"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">destroy</a></h2>
<p>Destroys a widget.</p><p>When a widget is destroyed all references it holds on other objects will be released:</p><ul>
<li><p>if the widget is inside a container, it will be removed from its parent</p></li>
<li><p>if the widget is a container, all its children will be destroyed, recursively</p></li>
<li><p>if the widget is a top level, it will be removed from the list of top level widgets that GTK+ maintains internally</p></li>
</ul>
<p>It's expected that all references held on the widget will also be released; you should connect to the <em>destroy</em> signal if you hold a reference to <em>widget</em> and you wish to remove it when this function is called.</p><p>It's important to notice that <code>destroy()</code> will only cause the <em>widget</em> to be finalized if no additional references, acquired using <code>g-object-ref()</code>, are held on it. In case additional references are in place, the <em>widget</em> will be in an &quot;inert&quot; state after calling this function; <em>widget</em> will still point to valid memory, allowing you to release the references you hold, but you may not query the widget's own state.</p><p>You should typically call this function on top level widgets, and rarely on child widgets.</p><p>See also: <code>gtk-container-remove()</code></p><pre class="pod-block-code">method destroy ( )</pre>
<h2 id="destroyed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">destroyed</a></h2>
<p>This function sets <em>$widget</em> to <code>undefined</code> if <em>$widget</em> != <code>undefined</code>. It’s intended to be used as a callback connected to the “destroy” signal of a widget. You connect <code>destroyed()</code> as a signal handler, and pass the address of your widget variable as user data. Then when the widget is destroyed, the variable will be set to <code>undefined</code>. Useful for example to avoid multiple copies of the same dialog.</p><pre class="pod-block-code">method destroyed ( N-GObject $widget )</pre><ul>
<li><p>N-GObject $widget; the widget to clear <em>widget</em></p></li>
</ul>

<h2 id="device-is-shadowed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">device-is-shadowed</a></h2>
<p>Returns <code>True</code> if <em>device</em> has been shadowed by a GTK+ device grab on another widget, so it would stop sending events to <em>widget</em>. This may be used in the <em>grab-notify</em> signal to check for specific devices. See <code>gtk-device-grab-add()</code>.</p><p>Returns: <code>True</code> if there is an ongoing grab on <em>device</em> by another <strong>Gnome::Gtk3::Widget</strong> than <em>widget</em>.</p><pre class="pod-block-code">method device-is-shadowed ( N-GObject $device --&gt; Bool )</pre><ul>
<li><p>N-GObject $device; a <strong>Gnome::Gdk3::Device</strong></p></li>
</ul>

<h2 id="draw"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">draw</a></h2>
<p>Draws <em>widget</em> to <em>cr</em>. The top left corner of the widget will be drawn to the currently set origin point of <em>cr</em>.</p><p>You should pass a cairo context as <em>cr</em> argument that is in an original state. Otherwise the resulting drawing is undefined. For example changing the operator using <code>cairo-set-operator()</code> or the line width using <code>cairo-set-line-width()</code> might have unwanted side effects. You may however change the context’s transform matrix - like with <code>cairo-scale()</code>, <code>cairo-translate()</code> or <code>cairo-set-matrix()</code> and clip region with <code>cairo-clip()</code> prior to calling this function. Also, it is fine to modify the context with <code>cairo-save()</code> and <code>cairo-push-group()</code> prior to calling this function.</p><p>Note that special-purpose widgets may contain special code for rendering to the screen and might appear differently on screen and when rendered using <code>draw()</code>.</p><pre class="pod-block-code">method draw ( cairo_t $cr )</pre><ul>
<li><p>cairo_t $cr; a cairo context to draw to</p></li>
</ul>

<h2 id="error-bell"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">error-bell</a></h2>
<p>Notifies the user about an input-related error on this widget. If the <em>gtk-error-bell</em> setting is <code>True</code>, it calls <code>gdk-window-beep()</code>, otherwise it does nothing.</p><p>Note that the effect of <code>gdk-window-beep()</code> can be configured in many ways, depending on the windowing backend and the desktop environment or window manager that is used.</p><pre class="pod-block-code">method error-bell ( )</pre>
<h2 id="event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">event</a></h2>
<p>Rarely-used function. This function is used to emit the event signals on a widget (those signals should never be emitted without using this function to do so). If you want to synthesize an event though, don’t use this function; instead, use <code>gtk-main-do-event()</code> so the event will behave as if it were in the event queue. Don’t synthesize expose events; instead, use <code>gdk-window-invalidate-rect()</code> to invalidate a region of the window.</p><p>Returns: return from the event signal emission (<code>True</code> if the event was handled)</p><pre class="pod-block-code">method event ( GdkEvent $event --&gt; Bool )</pre><ul>
<li><p>GdkEvent $event; a <strong>Gnome::Gtk3::Event</strong></p></li>
</ul>

<h2 id="freeze-child-notify"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">freeze-child-notify</a></h2>
<p>Stops emission of <em>child-notify</em> signals on <em>widget</em>. The signals are queued until <code>thaw-child-notify()</code> is called on <em>widget</em>.</p><p>This is the analogue of <code>g-object-freeze-notify()</code> for child properties.</p><pre class="pod-block-code">method freeze-child-notify ( )</pre>
<h2 id="get-accessible"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-accessible</a></h2>
<p>Returns the accessible object that describes the widget to an assistive technology.</p><p>If accessibility support is not available, this <strong>AtkObject</strong> instance may be a no-op. Likewise, if no class-specific <strong>AtkObject</strong> implementation is available for the widget instance in question, it will inherit an <strong>AtkObject</strong> implementation from the first ancestor class for which such an implementation is defined.</p><p>The documentation of the [ATK](http://developer.gnome.org/atk/stable/) library contains more information about accessible objects and their uses.</p><p>Returns: the <strong>AtkObject</strong> associated with <em>widget</em></p><pre class="pod-block-code">method get-accessible ( --&gt; AtkObject )</pre>
<h2 id="get-action-group"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-action-group</a></h2>
<p>Retrieves the <strong>Gnome::Gtk3::ActionGroup</strong> that was registered using <em>$prefix</em>. The resulting <strong>Gnome::Gtk3::ActionGroup</strong> may have been registered to <em>widget</em> or any <strong>Gnome::Gtk3::Widget</strong> in its ancestry.</p><p>If no action group was found matching <em>prefix</em>, then <code>undefined</code> is returned.</p><p>Returns: A <strong>Gnome::Gtk3::ActionGroup</strong> based object or <code>undefined</code>.</p><pre class="pod-block-code">method get-action-group ( Str $prefix --&gt; N-GObject )</pre><ul>
<li><p>Str $prefix; The “prefix” of the action group.</p></li>
</ul>

<h2 id="get-allocated-baseline"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-allocated-baseline</a></h2>
<p>Returns the baseline that has currently been allocated to <em>widget</em>. This function is intended to be used when implementing handlers for the <em>draw</em> function, and when allocating child widgets in <em>size-allocate</em>.</p><p>Returns: the baseline of the <em>widget</em>, or -1 if none</p><pre class="pod-block-code">method get-allocated-baseline ( --&gt; Int )</pre>
<h2 id="get-allocated-height"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-allocated-height</a></h2>
<p>Returns the height that has currently been allocated to <em>widget</em>. This function is intended to be used when implementing handlers for the <em>draw</em> function.</p><p>Returns: the height of the <em>widget</em></p><pre class="pod-block-code">method get-allocated-height ( --&gt; Int )</pre>
<h2 id="get-allocated-size"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-allocated-size</a></h2>
<p>Retrieves the widget’s allocated size.</p><p>This function returns the last values passed to <code>size-allocate-with-baseline()</code>. The value differs from the size returned in <code>get-allocation()</code> in that functions like <code>set-halign()</code> can adjust the allocation, but not the value returned by this function.</p><p>If a widget is not visible, its allocated size is 0.</p><pre class="pod-block-code">method get-allocated-size ( --&gt; List )</pre><p>returns a List with</p><ul>
<li><p>N-GtkAllocation</p></li>
<li><p>int32 $baseline</p></li>
</ul>

<h2 id="get-allocated-width"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-allocated-width</a></h2>
<p>Returns the width that has currently been allocated to <em>widget</em>. This function is intended to be used when implementing handlers for the <em>draw</em> function.</p><p>Returns: the width of the <em>widget</em></p><pre class="pod-block-code">method get-allocated-width ( --&gt; Int )</pre>
<h2 id="get-allocation"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-allocation</a></h2>
<p>Retrieves the widget’s allocation.</p><p>Note, when implementing a <strong>Gnome::Gtk3::Container</strong>: a widget’s allocation will be its “adjusted” allocation, that is, the widget’s parent container typically calls <code>size-allocate()</code> with an allocation, and that allocation is then adjusted (to handle margin and alignment for example) before assignment to the widget.</p><p><code>get-allocation()</code> returns the adjusted allocation that was actually assigned to the widget. The adjusted allocation is guaranteed to be completely contained within the <code>size-allocate()</code> allocation, however.</p><p>So a <strong>Gnome::Gtk3::Container</strong> is guaranteed that its children stay inside the assigned bounds, but not that they have exactly the bounds the container assigned. There is no way to get the original allocation assigned by <code>size-allocate()</code>, since it isn’t stored; if a container implementation needs that information it will have to track it itself.</p><pre class="pod-block-code">method get-allocation ( --&gt; N-GtkAllocation )</pre><p>Returns a N-GtkAllocation</p>
<h2 id="get-ancestor,_get-ancestor-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-ancestor, get-ancestor-rk</a></h2>
<p>Gets the first ancestor of <em>widget</em> with type <em>$widget-type</em>. For example, <code>$widget.get-ancestor(GTK-TYPE-BOX)</code> gets the first native <strong>Gnome::Gtk3::Box</strong> that’s an ancestor of <em>widget</em>. No reference will be added to the returned widget; it should not be unreferenced. See note about checking for a toplevel <strong>Gnome::Gtk3::Window</strong> in the docs for <code>get-toplevel()</code>.</p><p>Note that unlike <code>is-ancestor()</code>, <code>get-ancestor()</code> considers this <em>widget</em> to be an ancestor of itself.</p><p>Returns: the ancestor widget, or <code>undefined</code> if not found</p><pre class="pod-block-code">method get-ancestor-rk (
  GType $widget-type, :$child-type? --&gt; Gnome::GObject::Object
)

method get-ancestor-rk (
  Str $gtk-widget-type-name, :$child-type? --&gt; Gnome::GObject::Object
)

method get-ancestor-rk (
  Gnome::Gtk3::Widget $widget, :$child-type?
  --&gt; Gnome::GObject::Object
)

method get-ancestor ( GType $widget-type --&gt; N-GObject )</pre><ul>
<li><p>N-GObject $widget-type; ancestor type. One can use <code>$widget.get-class-gtype</code> to get the GType of an object.</p></li>
<li><p>Str $gtk-widget-type-name; an ancester object name of how Gtk names these objects. Examples are <code>GtkWidget</code> and <code>GtkDialog</code>.</p></li>
<li><p>Gnome::Gtk3::Widget $widget; a raku widget.</p></li>
<li><p>$child-type: This is an optional argument. You can specify a real type or a type as a string. In the latter case the type must be defined in a module which can be found by the Raku require call.</p></li>
</ul>
<p>The return value <strong>Gnome::GObject::Object</strong> means any child raku object. N-GObject is the type of the native object.</p>
<h3 id="Examplf"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Example</a></h3>
<pre class="pod-block-code">class WGrid {
  submethod BUILD ( ) {
    my Gnome::Gtk3::Button $b .= new(:label&lt;Start&gt;);
    $b.register-signal( self, 'button-action', 'clicked');

    my Gnome::Gtk3::Grid $g .= new;
    $g.attach( $b, 0, 0, 1, 1);

    my Gnome::Gtk3::Window $w .= new;
    $w.set-title('My Button In My Window');
    $w.add($g);
    $w.show-all();
  }

  method button-action ( :_widget($button) ) {
    my Gnome::Gtk3::Window $window = $button.get-ancestor-rk('GtkWindow');
    …
  }
}

my WGrid $wgrid .= new;
Gnome::Gtk3::Main.new.main;</pre>
<h2 id="get-app-paintable"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-app-paintable</a></h2>
<p>Determines whether the application intends to draw on the widget in an <em>draw</em> handler.</p><p>See <code>set-app-paintable()</code></p><p>Returns: <code>True</code> if the widget is app paintable</p><pre class="pod-block-code">method get-app-paintable ( --&gt; Bool )</pre>
<h2 id="get-can-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-can-default</a></h2>
<p>Determines whether <em>widget</em> can be a default widget. See <code>set-can-default()</code>.</p><p>Returns: <code>True</code> if <em>widget</em> can be a default widget, <code>False</code> otherwise</p><pre class="pod-block-code">method get-can-default ( --&gt; Bool )</pre>
<h2 id="get-can-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-can-focus</a></h2>
<p>Determines whether <em>widget</em> can own the input focus. See <code>set-can-focus()</code>.</p><p>Returns: <code>True</code> if <em>widget</em> can own the input focus, <code>False</code> otherwise</p><pre class="pod-block-code">method get-can-focus ( --&gt; Bool )</pre>
<h2 id="get-child-visible"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-child-visible</a></h2>
<p>Gets the value set with <code>set-child-visible()</code>. If you feel a need to use this function, your code probably needs reorganization.</p><p>This function is only useful for container implementations and never should be called by an application.</p><p>Returns: <code>True</code> if the widget is mapped with the parent.</p><pre class="pod-block-code">method get-child-visible ( --&gt; Bool )</pre>
<h2 id="get-clip"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-clip</a></h2>
<p>Retrieves the widget’s clip area.</p><p>The clip area is the area in which all of <em>widget</em>'s drawing will happen. Other toolkits call it the bounding box.</p><p>Historically, in GTK+ the clip area has been equal to the allocation retrieved via <code>get-allocation()</code>.</p><pre class="pod-block-code">method get-clip ( --&gt; N-GtkAllocation )</pre><p>Returns a N-GtkAllocation clip</p>
<h2 id="get-clipboard"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-clipboard</a></h2>
<p>Returns the clipboard object for the given selection to be used with <em>widget</em>. <em>widget</em> must have a <strong>Gnome::Gdk3::Display</strong> associated with it, so must be attached to a toplevel window.</p><p>Returns: the appropriate clipboard object. If no clipboard already exists, a new one will be created. Once a clipboard object has been created, it is persistent for all time.</p><pre class="pod-block-code">method get-clipboard ( GdkAtom $selection --&gt; N-GObject )</pre><ul>
<li><p>GdkAtom $selection; a <strong>Gnome::Gtk3::Atom</strong> which identifies the clipboard to use. <code>GDK-SELECTION-CLIPBOARD</code> gives the default clipboard. Another common value is <code>GDK-SELECTION-PRIMARY</code>, which gives the primary X selection.</p></li>
</ul>

<h2 id="get-default-direction"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-default-direction</a></h2>
<p>Obtains the current default reading direction. See <code>set-default-direction()</code>.</p><p>Returns: the current default direction.</p><pre class="pod-block-code">method get-default-direction ( --&gt; GtkTextDirection )</pre>
<h2 id="get-device-enabled"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-device-enabled</a></h2>
<p>Returns whether <em>device</em> can interact with <em>widget</em> and its children. See <code>set-device-enabled()</code>.</p><p>Returns: <code>True</code> is <em>device</em> is enabled for <em>widget</em></p><pre class="pod-block-code">method get-device-enabled ( N-GObject $device --&gt; Bool )</pre><ul>
<li><p>N-GObject $device; a <strong>Gnome::Gdk3::Device</strong></p></li>
</ul>

<h2 id="get-device-events"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-device-events</a></h2>
<p>Returns the events mask for the widget corresponding to a specific device. These are the events that the widget will receive when <em>device</em> operates on it. Flags in this mask are from <code>GdkEventMask</code> in <strong>Gnome::Gdk3::Types</strong>.</p><p>Returns: device event mask for <em>widget</em></p><pre class="pod-block-code">method get-device-events ( N-GObject $device --&gt; Int )</pre><ul>
<li><p>N-GObject $device; a <strong>Gnome::Gdk3::Device</strong></p></li>
</ul>

<h2 id="get-direction"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-direction</a></h2>
<p>Gets the reading direction for a particular widget. See <code>set-direction()</code>.</p><p>Returns: the reading direction for the widget.</p><pre class="pod-block-code">method get-direction ( --&gt; GtkTextDirection )</pre>
<h2 id="get-display,_get-display-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-display, get-display-rk</a></h2>
<p>Get the <strong>Gnome::Gdk3::Display</strong> for the toplevel window associated with this widget. This function can only be called after the widget has been added to a widget hierarchy with a <strong>Gnome::Gtk3::Window</strong> at the top.</p><p>In general, you should only create display specific resources when a widget has been realized, and you should free those resources when the widget is unrealized.</p><p>Returns: the <strong>Gnome::Gdk3::Display</strong> for the toplevel for this widget.</p><pre class="pod-block-code">method get-display-rk ( --&gt; Gnome::Gdk3::Display )
method get-display ( --&gt; N-GObject )</pre>
<h2 id="get-events"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-events</a></h2>
<p>Returns the event mask (see GdkEventMask) for the widget. These are the events that the widget will receive.</p><p>Note: Internally, the widget event mask will be the logical OR of the event mask set through <code>set-events()</code> or <code>add-events()</code>, and the event mask necessary to cater for every <strong>Gnome::Gtk3::EventController</strong> created for the widget.</p><p>Returns: event mask for <em>widget</em></p><pre class="pod-block-code">method get-events ( --&gt; Int )</pre>
<h2 id="get-focus-on-click"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-focus-on-click</a></h2>
<p>Returns whether the widget should grab focus when it is clicked with the mouse. See <code>set-focus-on-click()</code>.</p><p>Returns: <code>True</code> if the widget should grab focus when it is clicked with the mouse.</p><pre class="pod-block-code">method get-focus-on-click ( --&gt; Bool )</pre>
<h2 id="get-font-map"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-font-map</a></h2>
<p>Gets the font map that has been set with <code>set-font-map()</code>.</p><p>Returns: A <strong>PangoFontMap</strong>, or <code>undefined</code></p><pre class="pod-block-code">method get-font-map ( --&gt; N-GObject )</pre>
<h2 id="get-font-options"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-font-options</a></h2>
<p>Returns the <strong>cairo-font-options-t</strong> used for Pango rendering. When not set, the defaults font options for the <strong>Gnome::Gdk3::Screen</strong> will be used.</p><p>Returns: the <strong>cairo-font-options-t</strong> or <code>undefined</code> if not set</p><pre class="pod-block-code">method get-font-options ( --&gt; cairo_font_options_t )</pre>
<h2 id="get-frame-clock"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-frame-clock</a></h2>
<p>Obtains the frame clock for a widget. The frame clock is a global “ticker” that can be used to drive animations and repaints. The most common reason to get the frame clock is to call <code>gdk-frame-clock-get-frame-time()</code>, in order to get a time to use for animating. For example you might record the start of the animation with an initial value from <code>gdk-frame-clock-get-frame-time()</code>, and then update the animation by calling <code>gdk-frame-clock-get-frame-time()</code> again during each repaint.</p><p><code>gdk-frame-clock-request-phase()</code> will result in a new frame on the clock, but won’t necessarily repaint any widgets. To repaint a widget, you have to use <code>queue-draw()</code> which invalidates the widget (thus scheduling it to receive a draw on the next frame). <code>queue-draw()</code> will also end up requesting a frame on the appropriate frame clock.</p><p>A widget’s frame clock will not change while the widget is mapped. Reparenting a widget (which implies a temporary unmap) can change the widget’s frame clock.</p><p>Unrealized widgets do not have a frame clock.</p><p>Returns: a <strong>Gnome::Gdk3::FrameClock</strong>, or <code>undefined</code> if widget is unrealized</p><pre class="pod-block-code">method get-frame-clock ( --&gt; N-GObject )</pre>
<h2 id="get-halign"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-halign</a></h2>
<p>Gets the value of the <em>halign</em> property.</p><p>For backwards compatibility reasons this method will never return <code>GTK-ALIGN-BASELINE</code>, but instead it will convert it to <code>GTK-ALIGN-FILL</code>. Baselines are not supported for horizontal alignment.</p><p>Returns: the horizontal alignment of <em>widget</em></p><pre class="pod-block-code">method get-halign ( --&gt; GtkAlign )</pre>
<h2 id="get-has-tooltip"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-has-tooltip</a></h2>
<p>Returns the current value of the has-tooltip property. See <em>has-tooltip</em> for more information.</p><p>Returns: current value of has-tooltip on <em>widget</em>.</p><pre class="pod-block-code">method get-has-tooltip ( --&gt; Bool )</pre>
<h2 id="get-has-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-has-window</a></h2>
<p>Determines whether <em>widget</em> has a <strong>Gnome::Gtk3::Window</strong> of its own. See <code>set-has-window()</code>.</p><p>Returns: <code>True</code> if <em>widget</em> has a window, <code>False</code> otherwise</p><pre class="pod-block-code">method get-has-window ( --&gt; Bool )</pre>
<h2 id="get-hexpand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-hexpand</a></h2>
<p>Gets whether the widget would like any available extra horizontal space. When a user resizes a <strong>Gnome::Gtk3::Window</strong>, widgets with expand=TRUE generally receive the extra space. For example, a list or scrollable area or document in your window would often be set to expand.</p><p>Containers should use <code>compute-expand()</code> rather than this function, to see whether a widget, or any of its children, has the expand flag set. If any child of a widget wants to expand, the parent may ask to expand also.</p><p>This function only looks at the widget’s own hexpand flag, rather than computing whether the entire widget tree rooted at this widget wants to expand.</p><p>Returns: whether hexpand flag is set</p><pre class="pod-block-code">method get-hexpand ( --&gt; Bool )</pre>
<h2 id="get-hexpand-set"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-hexpand-set</a></h2>
<p>Gets whether <code>set-hexpand()</code> has been used to explicitly set the expand flag on this widget.</p><p>If hexpand is set, then it overrides any computed expand value based on child widgets. If hexpand is not set, then the expand value depends on whether any children of the widget would like to expand.</p><p>There are few reasons to use this function, but it’s here for completeness and consistency.</p><p>Returns: whether hexpand has been explicitly set</p><pre class="pod-block-code">method get-hexpand-set ( --&gt; Bool )</pre>
<h2 id="get-mapped"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-mapped</a></h2>
<p>Whether the widget is mapped.</p><p>Returns: <code>True</code> if the widget is mapped, <code>False</code> otherwise.</p><pre class="pod-block-code">method get-mapped ( --&gt; Bool )</pre>
<h2 id="get-margin-bottom"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-margin-bottom</a></h2>
<p>Gets the value of the <em>margin-bottom</em> property.</p><p>Returns: The bottom margin of <em>widget</em></p><pre class="pod-block-code">method get-margin-bottom ( --&gt; Int )</pre>
<h2 id="get-margin-end"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-margin-end</a></h2>
<p>Gets the value of the <em>margin-end</em> property.</p><p>Returns: The end margin of <em>widget</em></p><pre class="pod-block-code">method get-margin-end ( --&gt; Int )</pre>
<h2 id="get-margin-start"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-margin-start</a></h2>
<p>Gets the value of the <em>margin-start</em> property.</p><p>Returns: The start margin of <em>widget</em></p><pre class="pod-block-code">method get-margin-start ( --&gt; Int )</pre>
<h2 id="get-margin-top"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-margin-top</a></h2>
<p>Gets the value of the <em>margin-top</em> property.</p><p>Returns: The top margin of <em>widget</em></p><pre class="pod-block-code">method get-margin-top ( --&gt; Int )</pre>
<h2 id="get-modifier-mask"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-modifier-mask</a></h2>
<p>Returns the modifier mask the <em>widget</em>’s windowing system backend uses for a particular purpose.</p><p>See <code>gdk-keymap-get-modifier-mask()</code>.</p><p>Returns: the modifier mask used for <em>intent</em>. The mask bits are GdkModifierType</p><pre class="pod-block-code">method get-modifier-mask ( GdkModifierIntent $intent --&gt; Int )</pre><ul>
<li><p>GdkModifierIntent $intent; the use case for the modifier mask</p></li>
</ul>

<h2 id="get-name"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-name</a></h2>
<p>Retrieves the name of a widget. See <code>set-name()</code> for the significance of widget names.</p><p>Returns: name of the widget. This string is owned by GTK+ and should not be modified or freed</p><pre class="pod-block-code">method get-name ( --&gt; Str )</pre>
<h2 id="get-no-show-all"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-no-show-all</a></h2>
<p>Returns the current value of the <em>no-show-all</em> property, which determines whether calls to <code>show-all()</code> will affect this widget.</p><p>Returns: the current value of the “no-show-all” property.</p><pre class="pod-block-code">method get-no-show-all ( --&gt; Bool )</pre>
<h2 id="get-opacity"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-opacity</a></h2>
<p>Fetches the requested opacity for this widget. See <code>set-opacity()</code>.</p><p>Returns: the requested opacity for this widget.</p><pre class="pod-block-code">method get-opacity ( --&gt; Num )</pre>
<h2 id="get-pango-context"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-pango-context</a></h2>
<p>Gets a <strong>PangoContext</strong> with the appropriate font map, font description, and base direction for this widget. Unlike the context returned by <code>create-pango-context()</code>, this context is owned by the widget (it can be used until the screen for the widget changes or the widget is removed from its toplevel), and will be updated to match any changes to the widget’s attributes. This can be tracked by using the <em>screen-changed</em> signal on the widget.</p><p>Returns: the native object of <strong>Gnome::Pango::Context</strong> for the widget.</p><pre class="pod-block-code">method get-pango-context ( --&gt; N-GObject )</pre>
<h2 id="get-parent,_get-parent-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-parent, get-parent-rk</a></h2>
<p>Returns the parent object of this <em>widget</em> or <code>undefined</code> in the case of the native object or invalid in the case of a raku object.</p><pre class="pod-block-code">method get-parent ( --&gt; N-GObject )
method get-parent-rk ( :$child-type? --&gt; Gnome::GObject::Object )</pre><ul>
<li><p>$child-type: This is an optional argument. You can specify a real type or a type as a string. In the latter case the type must be defined in a module which can be found by the Raku require call.</p></li>
</ul>

<h2 id="get-parent-window,_get-parent-window-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-parent-window, get-parent-window-rk</a></h2>
<p>Gets <em>widget</em>’s parent window, or <code>undefined</code> if it does not have one.</p><p>Returns: the parent window of <em>widget</em>, or <code>undefined</code> if it does not have a parent window.</p><pre class="pod-block-code">method get-parent-window ( --&gt; N-GObject )
method get-parent-window-rk ( :$child-type? --&gt; Gnome::GObject::Object )</pre><ul>
<li><p>$child-type: This is an optional argument. You can specify a real type or a type as a string. In the latter case the type must be defined in a module which can be found by the Raku require call.</p></li>
</ul>

<h2 id="get-path,_get-path-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-path, get-path-rk</a></h2>
<p>Returns the <strong>Gnome::Gtk3::WidgetPath</strong> representing <em>widget</em>, if the widget is not connected to a toplevel widget, a partial path will be created.</p><p>Returns: The <strong>Gnome::Gtk3::WidgetPath</strong> representing <em>widget</em></p><pre class="pod-block-code">method get-path ( --&gt; N-GObject )
method get-path-rk ( --&gt; Gnome::Gtk3::WidgetPath )</pre>
<h2 id="get-preferred-height"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-preferred-height</a></h2>
<p>Retrieves a widget’s initial minimum and natural height.</p><p>This call is specific to width-for-height requests.</p><p>The returned request will be modified by the GtkWidgetClass::adjust_size_request virtual method and by any GtkSizeGroups that have been applied. That is, the returned request is the one that should be used for layout, not necessarily the one returned by the widget itself.</p><pre class="pod-block-code">method get-preferred-height ( --&gt; List )</pre><p>Returns a List with</p><ul>
<li><p>Int minimum_height;</p></li>
<li><p>Int natural_height;</p></li>
</ul>

<h2 id="get-preferred-height-and-baseline-for-width"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-preferred-height-and-baseline-for-width</a></h2>
<p>Retrieves a widget’s minimum and natural height and the corresponding baselines if it would be given the specified width , or the default height if width is -1. The baselines may be -1 which means that no baseline is requested for this widget.</p><p>The returned request will be modified by the GtkWidgetClass::adjust_size_request and GtkWidgetClass::adjust_baseline_request virtual methods and by any GtkSizeGroups that have been applied. That is, the returned request is the one that should be used for layout, not necessarily the one returned by the widget itself.</p><pre class="pod-block-code">method get-preferred-height-and-baseline-for-width (
  Int $width --&gt; List
)</pre><ul>
<li><p>Int $width;</p></li>
</ul>
<p>Returns a List containing;</p><ul>
<li><p>Int minimum_height;</p></li>
<li><p>Int natural_height;</p></li>
<li><p>Int minimum_baseline;</p></li>
<li><p>Int natural_baseline;</p></li>
</ul>

<h2 id="get-preferred-height-for-width"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-preferred-height-for-width</a></h2>
<p>Retrieves a widget’s minimum and natural height if it would be given the specified width .</p><pre class="pod-block-code">method get-preferred-height-for-width ( Int $width --&gt; List )</pre><ul>
<li><p>Int $width;</p></li>
</ul>
<p>Returning a List with</p><ul>
<li><p>Int minimum_height;</p></li>
<li><p>Int natural_height;</p></li>
</ul>

<h2 id="get-preferred-size"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-preferred-size</a></h2>
<p>Retrieves the minimum and natural size of a widget, taking into account the widget’s preference for height-for-width management.</p><p>This is used to retrieve a suitable size by container widgets which do not impose any restrictions on the child placement. It can be used to deduce toplevel window and menu sizes as well as child widgets in free-form containers such as GtkLayout.</p><p>Handle with care. Note that the natural height of a height-for-width widget will generally be a smaller size than the minimum height, since the required height for the natural width is generally smaller than the required height for the minimum width.</p><p>Use gtk_widget_get_preferred_height_and_baseline_for_width() if you want to support baseline alignment.</p><pre class="pod-block-code">method get-preferred-size ( --&gt; List )</pre><p>The returned list holds</p><ul>
<li><p>N-GtkRequisition $minimum_size;</p></li>
<li><p>N-GtkRequisition $natural_size;</p></li>
</ul>

<h2 id="get-preferred-width"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-preferred-width</a></h2>
<p>Retrieves a widget’s initial minimum and natural width.</p><p>This call is specific to height-for-width requests.</p><p>The returned request will be modified by the GtkWidgetClass::adjust_size_request virtual method and by any GtkSizeGroups that have been applied. That is, the returned request is the one that should be used for layout, not necessarily the one returned by the widget itself.</p><pre class="pod-block-code">method get-preferred-width ( --&gt; List )</pre><p>Returned List holds;</p><ul>
<li><p>Int minimum_width;</p></li>
<li><p>Int natural_width;</p></li>
</ul>

<h2 id="get-preferred-width-for-height"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-preferred-width-for-height</a></h2>
<p>Retrieves a widget’s minimum and natural width if it would be given the specified height .</p><p>The returned request will be modified by the GtkWidgetClass::adjust_size_request virtual method and by any GtkSizeGroups that have been applied. That is, the returned request is the one that should be used for layout, not necessarily the one returned by the widget itself.</p><pre class="pod-block-code">method get-preferred-width-for-height ( Int $height --&gt; List )</pre><ul>
<li><p>Int $height;</p></li>
</ul>
<p>The returned List holds</p><ul>
<li><p>Int minimum_width;</p></li>
<li><p>Int natural_width;</p></li>
</ul>

<h2 id="get-realized"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-realized</a></h2>
<p>Determines whether <em>widget</em> is realized.</p><p>Returns: <code>True</code> if <em>widget</em> is realized, <code>False</code> otherwise</p><pre class="pod-block-code">method get-realized ( --&gt; Bool )</pre>
<h2 id="get-receives-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-receives-default</a></h2>
<p>Determines whether <em>widget</em> is always treated as the default widget within its toplevel when it has the focus, even if another widget is the default.</p><p>See <code>set-receives-default()</code>.</p><p>Returns: <code>True</code> if <em>widget</em> acts as the default widget when focused, <code>False</code> otherwise</p><pre class="pod-block-code">method get-receives-default ( --&gt; Bool )</pre>
<h2 id="get-request-mode"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-request-mode</a></h2>
<p>Gets whether the widget prefers a height-for-width layout or a width-for-height layout.</p><p>GtkBin widgets generally propagate the preference of their child, container widgets need to request something either in context of their children or in context of their allocation capabilities.</p><pre class="pod-block-code">method get-request-mode ( --&gt; GtkSizeRequestMode )</pre>
<h2 id="get-scale-factor"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-scale-factor</a></h2>
<p>Retrieves the internal scale factor that maps from window coordinates to the actual device pixels. On traditional systems this is 1, on high density outputs, it can be a higher value (typically 2).</p><p>See <code>gdk-window-get-scale-factor()</code>.</p><p>Returns: the scale factor for <em>widget</em></p><pre class="pod-block-code">method get-scale-factor ( --&gt; Int )</pre>
<h2 id="get-screen,_get-screen-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-screen, get-screen-rk</a></h2>
<p>Get the <strong>Gnome::Gdk3::Screen</strong> from the toplevel window associated with this widget. This function can only be called after the widget has been added to a widget hierarchy with a <strong>Gnome::Gdk3::Window</strong> at the top.</p><p>In general, you should only create screen specific resources when a widget has been realized, and you should free those resources when the widget is unrealized.</p><p>Returns: the <strong>Gnome::Gdk3::Screen</strong> for the toplevel for this widget.</p><pre class="pod-block-code">method get-screen-rk ( --&gt; Gnome::Gdk3::Screen )
method get-screen ( --&gt; N-GObject )</pre>
<h2 id="get-sensitive"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-sensitive</a></h2>
<p>Returns the widget’s sensitivity (in the sense of returning the value that has been set using <code>set-sensitive()</code>).</p><p>The effective sensitivity of a widget is however determined by both its own and its parent widget’s sensitivity. See <code>is-sensitive()</code>.</p><p>Returns: <code>True</code> if the widget is sensitive</p><pre class="pod-block-code">method get-sensitive ( --&gt; Bool )</pre>
<h2 id="get-settings"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-settings</a></h2>
<p>Gets the settings object holding the settings used for this widget.</p><p>Note that this function can only be called when the <strong>Gnome::Gtk3::Widget</strong> is attached to a toplevel, since the settings object is specific to a particular <strong>Gnome::Gdk3::Screen</strong>.</p><p>Returns: the relevant <strong>Gnome::Gtk3::Settings</strong> object</p><pre class="pod-block-code">method get-settings ( --&gt; N-GObject )</pre>
<h2 id="get-size-request"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-size-request</a></h2>
<p>Gets the size request that was explicitly set for the widget using <code>set-size-request()</code>. A value of -1 stored in <em>width</em> or <em>height</em> indicates that that dimension has not been set explicitly and the natural requisition of the widget will be used instead. See <code>set-size-request()</code>. To get the size a widget will actually request, call <code>get-preferred-size()</code> instead of this function.</p><pre class="pod-block-code">method get-size-request ( --&gt; List )</pre><p>Returned List holds;</p><ul>
<li><p>Int width; return location for width, or <code>undefined</code></p></li>
<li><p>Int height; return location for height, or <code>undefined</code></p></li>
</ul>

<h2 id="get-state-flags"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-state-flags</a></h2>
<p>Returns the widget state as a flag set. It is worth mentioning that the effective <code>GTK-STATE-FLAG-INSENSITIVE</code> state will be returned, that is, also based on parent insensitivity, even if <em>widget</em> itself is sensitive.</p><p>Also note that if you are looking for a way to obtain the <strong>Gnome::Gtk3::StateFlags</strong> to pass to a <strong>Gnome::Gtk3::StyleContext</strong> method, you should look at <code>Gnome::Gtk3::StyleContext.get-state()</code>.</p><p>Returns: The state flags for widget. Flags are defined by GtkStateFlags.</p><pre class="pod-block-code">method get-state-flags ( --&gt; UInt )</pre>
<h2 id="get-style-context,_get-style-context-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-style-context, get-style-context-rk</a></h2>
<p>Returns the style context associated to <em>widget</em>. The returned object is guaranteed to be the same for the lifetime of <em>widget</em>.</p><p>Returns: a <strong>Gnome::Gtk3::StyleContext</strong>. This memory is owned by <em>widget</em> and must not be freed.</p><pre class="pod-block-code">method get-style-context ( --&gt; N-GObject )
method get-style-context-rk ( --&gt; Gnome::Gtk3::StyleContext )</pre>
<h2 id="get-support-multidevice"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-support-multidevice</a></h2>
<p>Returns <code>True</code> if <em>widget</em> is multiple pointer aware. See <code>set-support-multidevice()</code> for more information.</p><p>Returns: <code>True</code> if <em>widget</em> is multidevice aware.</p><pre class="pod-block-code">method get-support-multidevice ( --&gt; Bool )</pre>
<h2 id="get-template-child"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-template-child</a></h2>
<p>Fetch an object build from the template XML for <em>widget-type</em> in this <em>widget</em> instance.</p><p>This will only report children which were previously declared with <code>class-bind-template-child-full()</code> or one of its variants.</p><p>This function is only meant to be called for code which is private to the <em>widget-type</em> which declared the child and is meant for language bindings which cannot easily make use of the GObject structure offsets.</p><p>Returns: The object built in the template XML with the id <em>name</em></p><pre class="pod-block-code">method get-template-child ( N-GObject $widget_type, Str $name --&gt; N-GObject )</pre><ul>
<li><p>N-GObject $widget_type; The <strong>Gnome::Gtk3::Type</strong> to get a template child for</p></li>
<li><p>Str $name; The “id” of the child defined in the template XML</p></li>
</ul>

<h2 id="get-tooltip-markup"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-tooltip-markup</a></h2>
<p>Gets the contents of the tooltip for <em>widget</em>.</p><p>Returns: the tooltip text, or <code>undefined</code>. You should free the returned string with <code>g-free()</code> when done.</p><pre class="pod-block-code">method get-tooltip-markup ( --&gt; Str )</pre>
<h2 id="get-tooltip-text"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-tooltip-text</a></h2>
<p>Gets the contents of the tooltip for <em>widget</em>.</p><p>Returns: the tooltip text, or <code>undefined</code>. You should free the returned string with <code>g-free()</code> when done.</p><pre class="pod-block-code">method get-tooltip-text ( --&gt; Str )</pre>
<h2 id="get-tooltip-window,_get-tooltip-window-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-tooltip-window, get-tooltip-window-rk</a></h2>
<p>Returns the <strong>Gnome::Gtk3::Window</strong> of the current tooltip. This can be the GtkWindow created by default, or the custom tooltip window set using <code>set-tooltip-window()</code>.</p><p>Returns: The <strong>Gnome::Gtk3::Window</strong> of the current tooltip. It can be undefined or invalid when there is no window defined.</p><pre class="pod-block-code">method get-tooltip-window ( --&gt; N-GObject )
method get-tooltip-window-rk ( :$child-type? --&gt; Gnome::Gtk3::Window )</pre><ul>
<li><p>$child-type: This is an optional argument. You can specify a real type or a type as a string. In the latter case the type must be defined in a module which can be found by the Raku require call.</p></li>
</ul>

<h2 id="get-toplevel,_get-toplevel-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-toplevel, get-toplevel-rk</a></h2>
<p>This function returns the topmost widget in the container hierarchy <em>widget</em> is a part of. If <em>widget</em> has no parent widgets, it will be returned as the topmost widget. No reference will be added to the returned widget; it should not be unreferenced.</p><p>Note the difference in behavior vs. <code>get-ancestor()</code>; `gtk-widget-get-ancestor (widget, GTK-TYPE-WINDOW)` would return <code>undefined</code> if <em>widget</em> wasn’t inside a toplevel window, and if the window was inside a <strong>Gnome::Gtk3::Window</strong>-derived widget which was in turn inside the toplevel <strong>Gnome::Gtk3::Window</strong>. While the second case may seem unlikely, it actually happens when a <strong>Gnome::Gtk3::Plug</strong> is embedded inside a <strong>Gnome::Gtk3::Socket</strong> within the same application.</p><p>To reliably find the toplevel <strong>Gnome::Gtk3::Window</strong>, use <code>get-toplevel()</code> and call <code>GTK-IS-WINDOW()</code> on the result. For instance, to get the title of a widget's toplevel window, one might use:</p><pre class="pod-block-code">sub get-widget-toplevel-title ( Gnome::Gtk3::Widget $widget --&gt; Str ) {
  Gnome::Gtk3::Widget $toplevel = $widget.get-toplevel-rk;
  ( $toplevel.is-valid and $toplevel.is-toplevel )
    ?? $toplevel.gtk-window-get-title !! ''
}</pre><p>Returns: the topmost ancestor of <em>widget</em>, or <em>widget</em> itself if there’s no ancestor.</p><pre class="pod-block-code">method get-toplevel ( --&gt; N-GObject )
method get-toplevel-rk ( :$child-type? --&gt; Gnome::GObject::Widget )</pre><ul>
<li><p>$child-type: This is an optional argument. You can specify a real type or a type as a string. In the latter case the type must be defined in a module which can be found by the Raku require call.</p></li>
</ul>

<h2 id="get-valign"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-valign</a></h2>
<p>Gets the value of the <em>valign</em> property.</p><p>For backwards compatibility reasons this method will never return <code>GTK-ALIGN-BASELINE</code>, but instead it will convert it to <code>GTK-ALIGN-FILL</code>. If your widget want to support baseline aligned children it must use <code>get-valign-with-baseline()</code>, or `g-object-get (widget, &quot;valign&quot;, &amp;value, NULL)`, which will also report the true value.</p><p>Returns: the vertical alignment of <em>widget</em>, ignoring baseline alignment</p><pre class="pod-block-code">method get-valign ( --&gt; GtkAlign )</pre>
<h2 id="get-valign-with-baseline"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-valign-with-baseline</a></h2>
<p>Gets the value of the <em>valign</em> property, including <code>GTK-ALIGN-BASELINE</code>.</p><p>Returns: the vertical alignment of <em>widget</em></p><pre class="pod-block-code">method get-valign-with-baseline ( --&gt; GtkAlign )</pre>
<h2 id="get-vexpand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-vexpand</a></h2>
<p>Gets whether the widget would like any available extra vertical space.</p><p>See <code>get-hexpand()</code> for more detail.</p><p>Returns: whether vexpand flag is set</p><pre class="pod-block-code">method get-vexpand ( --&gt; Bool )</pre>
<h2 id="get-vexpand-set"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-vexpand-set</a></h2>
<p>Gets whether <code>set-vexpand()</code> has been used to explicitly set the expand flag on this widget.</p><p>See <code>get-hexpand-set()</code> for more detail.</p><p>Returns: whether vexpand has been explicitly set</p><pre class="pod-block-code">method get-vexpand-set ( --&gt; Bool )</pre>
<h2 id="get-visible"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-visible</a></h2>
<p>Determines whether the widget is visible. If you want to take into account whether the widget’s parent is also marked as visible, use <code>is-visible()</code> instead.</p><p>This function does not check if the widget is obscured in any way.</p><p>See <code>set-visible()</code>.</p><p>Returns: <code>True</code> if the widget is visible</p><pre class="pod-block-code">method get-visible ( --&gt; Bool )</pre>
<h2 id="get-visual,_get-visual-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-visual, get-visual-rk</a></h2>
<p>Gets the visual that will be used to render <em>widget</em>.</p><p>Returns: the visual for <em>widget</em></p><pre class="pod-block-code">method get-visual-rk ( --&gt; Gnome::Gdk3::Visual )
method get-visual ( --&gt; N-GObject )</pre>
<h2 id="get-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">get-window</a></h2>
<p>Returns the widget’s window if it is realized, <code>undefined</code> otherwise</p><p>Returns: <em>widget</em>’s gdk window as a native object or Raku object.</p><pre class="pod-block-code">method get-window ( --&gt; N-GObject )</pre>
<h2 id="grab-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">grab-default</a></h2>
<p>Causes <em>widget</em> to become the default widget. <em>widget</em> must be able to be a default widget; typically you would ensure this yourself by calling <code>set-can-default()</code> with a <code>True</code> value. The default widget is activated when the user presses Enter in a window. Default widgets must be activatable, that is, <code>activate()</code> should affect them. Note that <strong>Gnome::Gtk3::Entry</strong> widgets require the “activates-default” property set to <code>True</code> before they activate the default widget when Enter is pressed and the <strong>Gnome::Gtk3::Entry</strong> is focused.</p><pre class="pod-block-code">method grab-default ( )</pre>
<h2 id="grab-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">grab-focus</a></h2>
<p>Causes <em>widget</em> to have the keyboard focus for the <strong>Gnome::Gtk3::Window</strong> it's inside. <em>widget</em> must be a focusable widget, such as a <strong>Gnome::Gtk3::Entry</strong>; something like <strong>Gnome::Gtk3::Frame</strong> won’t work.</p><p>More precisely, it must have the <code>GTK-CAN-FOCUS</code> flag set. Use <code>set-can-focus()</code> to modify that flag.</p><p>The widget also needs to be realized and mapped. This is indicated by the related signals. Grabbing the focus immediately after creating the widget will likely fail and cause critical warnings.</p><pre class="pod-block-code">method grab-focus ( )</pre>
<h2 id="gtk-cairo-should-draw-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">gtk-cairo-should-draw-window</a></h2>
<p>This function is supposed to be called in <em>draw</em> implementations for widgets that support multiple windows. <em>$cr</em> must be untransformed from invoking of the draw function. This function will return <code>True</code> if the contents of the given <em>$window</em> are supposed to be drawn and <code>False</code> otherwise. Note that when the drawing was not initiated by the windowing system this function will return <code>True</code> for all windows, so you need to draw the bottommost window first. Also, do not use “else if” statements to check which window should be drawn.</p><p>Returns: <code>True</code> if <em>window</em> should be drawn</p><pre class="pod-block-code">method gtk-cairo-should-draw-window (
  cairo_t $cr, N-GObject $window --&gt; Bool
)</pre><ul>
<li><p>cairo_t $cr; a cairo context</p></li>
<li><p>N-GObject $window; the window to check. <em>window</em> may not be an input-only window.</p></li>
</ul>

<h2 id="gtk-cairo-transform-to-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">gtk-cairo-transform-to-window</a></h2>
<p>Transforms the given cairo context <em>cr</em> that from <em>widget</em>-relative coordinates to <em>window</em>-relative coordinates. If the <em>widget</em>’s window is not an ancestor of <em>window</em>, no modification will be applied.</p><p>This is the inverse to the transformation GTK applies when preparing an expose event to be emitted with the <em>draw</em> signal. It is intended to help porting multiwindow widgets from GTK+ 2 to the rendering architecture of GTK+ 3.</p><pre class="pod-block-code">method gtk-cairo-transform-to-window (
  cairo_t $cr, N-GObject $widget, N-GObject $window
)</pre><ul>
<li><p>cairo_t $cr; the cairo context to transform</p></li>
<li><p>N-GObject $widget; the widget the context is currently centered for</p></li>
<li><p>N-GObject $window; the window to transform the context to</p></li>
</ul>

<h2 id="gtk-requisition-copy"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">gtk-requisition-copy</a></h2>
<p>Copies a <strong>Gnome::Gtk3::Requisition</strong>.</p><p>Returns: a copy of <em>requisition</em></p><pre class="pod-block-code">method gtk-requisition-copy (
  N-GtkRequisition $requisition --&gt; N-GtkRequisition
)</pre><ul>
<li><p>N-GtkRequisition $requisition; a <strong>Gnome::Gtk3::Requisition</strong></p></li>
</ul>

<h2 id="gtk-requisition-free"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">gtk-requisition-free</a></h2>
<p>Frees a <strong>Gnome::Gtk3::Requisition</strong>.</p><pre class="pod-block-code">method gtk-requisition-free ( N-GtkRequisition $requisition )</pre><ul>
<li><p>N-GtkRequisition $requisition; a <strong>Gnome::Gtk3::Requisition</strong></p></li>
</ul>

<h2 id="gtk-requisition-new"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">gtk-requisition-new</a></h2>
<p>Allocates a new <strong>Gnome::Gtk3::Requisition</strong>-struct and initializes its elements to zero.</p><p>Returns: a new empty <strong>Gnome::Gtk3::Requisition</strong>. The newly allocated <strong>Gnome::Gtk3::Requisition</strong> should be freed with <code>requisition-free()</code>.</p><pre class="pod-block-code">method gtk-requisition-new ( --&gt; N-GtkRequisition )</pre>
<h2 id="has-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">has-default</a></h2>
<p>Determines whether <em>widget</em> is the current default widget within its toplevel. See <code>set-can-default()</code>.</p><p>Returns: <code>True</code> if <em>widget</em> is the current default widget within its toplevel, <code>False</code> otherwise</p><pre class="pod-block-code">method has-default ( --&gt; Bool )</pre>
<h2 id="has-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">has-focus</a></h2>
<p>Determines if the widget has the global input focus. See <code>is-focus()</code> for the difference between having the global input focus, and only having the focus within a toplevel.</p><p>Returns: <code>True</code> if the widget has the global input focus.</p><pre class="pod-block-code">method has-focus ( --&gt; Bool )</pre>
<h2 id="has-grab"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">has-grab</a></h2>
<p>Determines whether the widget is currently grabbing events, so it is the only widget receiving input events (keyboard and mouse).</p><p>See also <code>gtk-grab-add()</code>.</p><p>Returns: <code>True</code> if the widget is in the grab-widgets stack</p><pre class="pod-block-code">method has-grab ( --&gt; Bool )</pre>
<h2 id="has-screen"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">has-screen</a></h2>
<p>Checks whether there is a <strong>Gnome::Gdk3::Screen</strong> is associated with this widget. All toplevel widgets have an associated screen, and all widgets added into a hierarchy with a toplevel window at the top.</p><p>Returns: <code>True</code> if there is a <strong>Gnome::Gdk3::Screen</strong> associated with the widget.</p><pre class="pod-block-code">method has-screen ( --&gt; Bool )</pre>
<h2 id="has-visible-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">has-visible-focus</a></h2>
<p>Determines if the widget should show a visible indication that it has the global input focus. This is a convenience function for use in <em>draw</em> handlers that takes into account whether focus indication should currently be shown in the toplevel window of <em>widget</em>. See <code>gtk-window-get-focus-visible()</code> for more information about focus indication.</p><p>To find out if the widget has the global input focus, use <code>has-focus()</code>.</p><p>Returns: <code>True</code> if the widget should display a “focus rectangle”</p><pre class="pod-block-code">method has-visible-focus ( --&gt; Bool )</pre>
<h2 id="hide"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">hide</a></h2>
<p>Reverses the effects of <code>show()</code>, causing the widget to be hidden (invisible to the user).</p><pre class="pod-block-code">method hide ( )</pre>
<h2 id="hide-on-delete"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">hide-on-delete</a></h2>
<p>Utility function; intended to be connected to the <em>delete-event</em> signal on a <strong>Gnome::Gtk3::Window</strong>. The function calls <code>hide()</code> on its argument, then returns <code>True</code>. If connected to <em>delete-event</em>, the result is that clicking the close button for a window (on the window frame, top right corner usually) will hide but not destroy the window. By default, GTK+ destroys windows when <em>delete-event</em> is received.</p><p>Returns: <code>True</code></p><pre class="pod-block-code">method hide-on-delete ( --&gt; Bool )</pre>
<h2 id="in-destruction"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">in-destruction</a></h2>
<p>Returns whether the widget is currently being destroyed. This information can sometimes be used to avoid doing unnecessary work.</p><p>Returns: <code>True</code> if <em>widget</em> is being destroyed</p><pre class="pod-block-code">method in-destruction ( --&gt; Bool )</pre>
<h2 id="init-template"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">init-template</a></h2>
<p>Creates and initializes child widgets defined in templates. This function must be called in the instance initializer for any class which assigned itself a template using <code>class-set-template()</code></p><p>It is important to call this function in the instance initializer of a <strong>Gnome::Gtk3::Widget</strong> subclass and not in <strong>Gnome::Gtk3::Object</strong>.<code>constructed()</code> or <strong>Gnome::Gtk3::Object</strong>.<code>constructor()</code> for two reasons.</p><p>One reason is that generally derived widgets will assume that parent class composite widgets have been created in their instance initializers.</p><p>Another reason is that when calling <code>g-object-new()</code> on a widget with composite templates, it’s important to build the composite widgets before the construct properties are set. Properties passed to <code>g-object-new()</code> should take precedence over properties set in the private template XML.</p><pre class="pod-block-code">method init-template ( )</pre>
<h2 id="input-shape-combine-region"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">input-shape-combine-region</a></h2>
<p>Sets an input shape for this widget’s GDK window. This allows for windows which react to mouse click in a nonrectangular region, see <code>gdk-window-input-shape-combine-region()</code> for more information.</p><pre class="pod-block-code">method input-shape-combine-region ( cairo_region_t $region )</pre><ul>
<li><p>cairo_region_t $region; shape to be added, or <code>undefined</code> to remove an existing shape</p></li>
</ul>

<h2 id="insert-action-group"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">insert-action-group</a></h2>
<p>Inserts <em>$group</em> into <em>widget</em>. Children of <em>widget</em> that implement <strong>Gnome::Gtk3::Actionable</strong> can then be associated with actions in <em>$group</em> by setting their “action-name” to <em>$prefix</em>.`action-name`.</p><p>If <em>group</em> is <code>undefined</code>, a previously inserted group for <em>name</em> is removed from <em>widget</em>.</p><pre class="pod-block-code">method insert-action-group ( Str $name, N-GObject $group )</pre><ul>
<li><p>Str $name; the prefix for actions in <em>group</em></p></li>
<li><p>N-GObject $group; a <strong>Gnome::Gio::ActionGroup</strong>, or <code>undefined</code></p></li>
</ul>

<h2 id="intersect"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">intersect</a></h2>
<p>Computes the intersection of a <em>widget</em>’s area and <em>$area</em>, storing the intersection in <em>$intersection</em>, and returns <code>True</code> if there was an intersection. <em>$intersection</em> may be <code>undefined</code> if you’re only interested in whether there was an intersection.</p><p>Returns: <code>True</code> if there was an intersection</p><pre class="pod-block-code">method intersect ( N-GObject $area, N-GObject $intersection --&gt; Bool )</pre><ul>
<li><p>N-GObject $area; a N-GdkRectangle</p></li>
<li><p>N-GObject $intersection; N-GdkRectangle to store intersection of <em>widget</em> and <em>area</em></p></li>
</ul>

<h2 id="is-ancestor"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">is-ancestor</a></h2>
<p>Determines whether <em>widget</em> is somewhere inside <em>$ancestor</em>, possibly with intermediate containers.</p><p>Returns: <code>True</code> if <em>$ancestor</em> contains <em>widget</em> as a child, grandchild, great grandchild, etc.</p><pre class="pod-block-code">method is-ancestor ( N-GObject $ancestor --&gt; Bool )</pre><ul>
<li><p>N-GObject $ancestor; another <strong>Gnome::Gtk3::Widget</strong></p></li>
</ul>

<h2 id="is-drawable"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">is-drawable</a></h2>
<p>Determines whether <em>widget</em> can be drawn to. A widget can be drawn to if it is mapped and visible.</p><p>Returns: <code>True</code> if <em>widget</em> is drawable, <code>False</code> otherwise</p><pre class="pod-block-code">method is-drawable ( --&gt; Bool )</pre>
<h2 id="is-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">is-focus</a></h2>
<p>Determines if the widget is the focus widget within its toplevel. (This does not mean that the <em>has-focus</em> property is necessarily set; <em>has-focus</em> will only be set if the toplevel widget additionally has the global input focus.)</p><p>Returns: <code>True</code> if the widget is the focus widget.</p><pre class="pod-block-code">method is-focus ( --&gt; Bool )</pre>
<h2 id="is-sensitive"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">is-sensitive</a></h2>
<p>Returns the widget’s effective sensitivity, which means it is sensitive itself and also its parent widget is sensitive</p><p>Returns: <code>True</code> if the widget is effectively sensitive</p><pre class="pod-block-code">method is-sensitive ( --&gt; Bool )</pre>
<h2 id="is-toplevel"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">is-toplevel</a></h2>
<p>Determines whether <em>widget</em> is a toplevel widget.</p><p>Currently only <strong>Gnome::Gtk3::Window</strong> and <strong>Gnome::Gtk3::Invisible</strong> (and out-of-process <strong>Gnome::Gtk3::Plugs</strong>) are toplevel widgets. Toplevel widgets have no parent widget.</p><p>Returns: <code>True</code> if <em>widget</em> is a toplevel, <code>False</code> otherwise</p><pre class="pod-block-code">method is-toplevel ( --&gt; Bool )</pre>
<h2 id="is-visible"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">is-visible</a></h2>
<p>Determines whether the widget and all its parents are marked as visible.</p><p>This function does not check if the widget is obscured in any way.</p><p>See also <code>get-visible()</code> and <code>set-visible()</code></p><p>Returns: <code>True</code> if the widget and all its parents are visible</p><pre class="pod-block-code">method is-visible ( --&gt; Bool )</pre>
<h2 id="keynav-failed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">keynav-failed</a></h2>
<p>This function should be called whenever keyboard navigation within a single widget hits a boundary. The function emits the <em>keynav-failed</em> signal on the widget and its return value should be interpreted in a way similar to the return value of <code>child-focus()</code>:</p><p>When <code>True</code> is returned, stay in the widget, the failed keyboard navigation is OK and/or there is nowhere we can/should move the focus to.</p><p>When <code>False</code> is returned, the caller should continue with keyboard navigation outside the widget, e.g. by calling <code>child-focus()</code> on the widget’s toplevel.</p><p>The default <em>keynav-failed</em> handler returns <code>False</code> for <code>GTK-DIR-TAB-FORWARD</code> and <code>GTK-DIR-TAB-BACKWARD</code>. For the other values of <strong>Gnome::Gtk3::DirectionType</strong> it returns <code>True</code>.</p><p>Whenever the default handler returns <code>True</code>, it also calls <code>error-bell()</code> to notify the user of the failed keyboard navigation.</p><p>A use case for providing an own implementation of <em>keynav-failed</em> (either by connecting to it or by overriding it) would be a row of <strong>Gnome::Gtk3::Entry</strong> widgets where the user should be able to navigate the entire row with the cursor keys, as e.g. known from user interfaces that require entering license keys.</p><p>Returns: <code>True</code> if stopping keyboard navigation is fine, <code>False</code> if the emitting widget should try to handle the keyboard navigation attempt in its parent container(s).</p><pre class="pod-block-code">method keynav-failed ( GtkDirectionType $direction --&gt; Bool )</pre><ul>
<li><p>GtkDirectionType $direction; direction of focus movement</p></li>
</ul>

<h2 id="list-accel-closures"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">list-accel-closures</a></h2>
<p>Lists the closures used by <em>widget</em> for accelerator group connections with <code>gtk-accel-group-connect-by-path()</code> or <code>gtk-accel-group-connect()</code>. The closures can be used to monitor accelerator changes on <em>widget</em>, by connecting to the <em>GtkAccelGroup</em>::accel-changed signal of the <strong>Gnome::Gtk3::AccelGroup</strong> of a closure which can be found out with <code>gtk-accel-group-from-accel-closure()</code>.</p><p>Returns: a newly allocated <strong>Gnome::Gtk3::List</strong> of closures</p><pre class="pod-block-code">method list-accel-closures ( --&gt; N-GList )</pre>
<h2 id="list-action-prefixes"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">list-action-prefixes</a></h2>
<p>Retrieves a <code>undefined</code>-terminated array of strings containing the prefixes of <strong>Gnome::Gtk3::ActionGroup</strong>'s available to <em>widget</em>.</p><p>Returns: an array of strings.</p><pre class="pod-block-code">method list-action-prefixes ( --&gt; List )</pre>
<h2 id="list-mnemonic-labels,_list-mnemonic-labels-rk"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">list-mnemonic-labels, list-mnemonic-labels-rk</a></h2>
<p>Returns a newly allocated list of the widgets, normally labels, for which this widget is the target of a mnemonic (see for example, <code>Gnome::Gtk3::Label.set-mnemonic-widget()</code>). The widgets in the list are not individually referenced.</p><p>Returns: the list of mnemonic labels; free this list with <code>clear-object()</code> when you are done with it.</p><pre class="pod-block-code">method list-mnemonic-labels ( --&gt; N-GList )
method list-mnemonic-labels-rk ( --&gt; Gnome::Glib::List )</pre>
<h2 id="map"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">map</a></h2>
<p>This function is only for use in widget implementations. Causes a widget to be mapped if it isn’t already.</p><pre class="pod-block-code">method map ( )</pre>
<h2 id="mnemonic-activate"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">mnemonic-activate</a></h2>
<p>Emits the <em>mnemonic-activate</em> signal.</p><p>Returns: <code>True</code> if the signal has been handled</p><pre class="pod-block-code">method mnemonic-activate ( Bool $group_cycling --&gt; Bool )</pre><ul>
<li><p>Bool $group_cycling; <code>True</code> if there are other widgets with the same mnemonic</p></li>
</ul>

<h2 id="queue-allocate"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">queue-allocate</a></h2>
<p>This function is only for use in widget implementations.</p><p>Flags the widget for a rerun of the GtkWidgetClass::size-allocate function. Use this function instead of <code>queue-resize()</code> when the <em>widget</em>'s size request didn't change but it wants to reposition its contents.</p><p>An example user of this function is <code>set-halign()</code>.</p><pre class="pod-block-code">method queue-allocate ( )</pre>
<h2 id="queue-compute-expand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">queue-compute-expand</a></h2>
<p>Mark <em>widget</em> as needing to recompute its expand flags. Call this function when setting legacy expand child properties on the child of a container.</p><p>See <code>compute-expand()</code>.</p><pre class="pod-block-code">method queue-compute-expand ( )</pre>
<h2 id="queue-draw"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">queue-draw</a></h2>
<p>Equivalent to calling <code>queue-draw-area()</code> for the entire area of a widget.</p><pre class="pod-block-code">method queue-draw ( )</pre>
<h2 id="queue-draw-area"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">queue-draw-area</a></h2>
<p>Convenience function that calls <code>queue-draw-region()</code> on the region created from the given coordinates.</p><p>The region here is specified in widget coordinates. Widget coordinates are a bit odd; for historical reasons, they are defined as <em>widget</em>-&gt;window coordinates for widgets that return <code>True</code> for <code>get-has-window()</code>, and are relative to <em>widget</em>-&gt;allocation.x, <em>widget</em>-&gt;allocation.y otherwise.</p><p><em>width</em> or <em>height</em> may be 0, in this case this function does nothing. Negative values for <em>width</em> and <em>height</em> are not allowed.</p><pre class="pod-block-code">method queue-draw-area ( Int $x, Int $y, Int $width, Int $height )</pre><ul>
<li><p>Int $x; x coordinate of upper-left corner of rectangle to redraw</p></li>
<li><p>Int $y; y coordinate of upper-left corner of rectangle to redraw</p></li>
<li><p>Int $width; width of region to draw</p></li>
<li><p>Int $height; height of region to draw</p></li>
</ul>

<h2 id="queue-draw-region"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">queue-draw-region</a></h2>
<p>Invalidates the area of <em>widget</em> defined by <em>region</em> by calling <code>gdk-window-invalidate-region()</code> on the widget’s window and all its child windows. Once the main loop becomes idle (after the current batch of events has been processed, roughly), the window will receive expose events for the union of all regions that have been invalidated.</p><p>Normally you would only use this function in widget implementations. You might also use it to schedule a redraw of a <strong>Gnome::Gtk3::DrawingArea</strong> or some portion thereof.</p><pre class="pod-block-code">method queue-draw-region ( cairo_region_t $region )</pre><ul>
<li><p>cairo_region_t $region; region to draw</p></li>
</ul>

<h2 id="queue-resize"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">queue-resize</a></h2>
<p>This function is only for use in widget implementations. Flags a widget to have its size renegotiated; should be called when a widget for some reason has a new size request. For example, when you change the text in a <strong>Gnome::Gtk3::Label</strong>, <strong>Gnome::Gtk3::Label</strong> queues a resize to ensure there’s enough space for the new text.</p><p>Note that you cannot call <code>queue-resize()</code> on a widget from inside its implementation of the GtkWidgetClass::size-allocate virtual method. Calls to <code>queue-resize()</code> from inside GtkWidgetClass::size-allocate will be silently ignored.</p><pre class="pod-block-code">method queue-resize ( )</pre>
<h2 id="queue-resize-no-redraw"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">queue-resize-no-redraw</a></h2>
<p>This function works like <code>queue-resize()</code>, except that the widget is not invalidated.</p><pre class="pod-block-code">method queue-resize-no-redraw ( )</pre>
<h2 id="realize"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">realize</a></h2>
<p>Creates the GDK (windowing system) resources associated with a widget. For example, <em>widget</em>-&gt;window will be created when a widget is realized. Normally realization happens implicitly; if you show a widget and all its parent containers, then the widget will be realized and mapped automatically.</p><p>Realizing a widget requires all the widget’s parent widgets to be realized; calling <code>realize()</code> realizes the widget’s parents in addition to <em>widget</em> itself. If a widget is not yet inside a toplevel window when you realize it, bad things will happen.</p><p>This function is primarily used in widget implementations, and isn’t very useful otherwise. Many times when you think you might need it, a better approach is to connect to a signal that will be called after the widget is realized automatically, such as <em>draw</em>. Or simply <code>g-signal-connect()</code> to the <em>realize</em> signal.</p><pre class="pod-block-code">method realize ( )</pre>
<h2 id="register-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">register-window</a></h2>
<p>Registers a <strong>Gnome::Gtk3::Window</strong> with the widget and sets it up so that the widget receives events for it. Call <code>unregister-window()</code> when destroying the window.</p><pre class="pod-block-code">method register-window ( N-GObject $window )</pre><ul>
<li><p>N-GObject $window; a <strong>Gnome::Gtk3::Window</strong></p></li>
</ul>

<h2 id="remove-accelerator"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">remove-accelerator</a></h2>
<p>Removes an accelerator from <em>widget</em>, previously installed with <code>add-accelerator()</code>.</p><p>Returns: whether an accelerator was installed and could be removed</p><pre class="pod-block-code">method remove-accelerator ( N-GObject $accel_group, UInt $accel_key, GdkModifierType $accel_mods --&gt; Bool )</pre><ul>
<li><p>N-GObject $accel_group; accel group for this widget</p></li>
<li><p>UInt $accel_key; GDK keyval of the accelerator</p></li>
<li><p>GdkModifierType $accel_mods; modifier key combination of the accelerator</p></li>
</ul>

<h2 id="remove-mnemonic-label"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">remove-mnemonic-label</a></h2>
<p>Removes a widget from the list of mnemonic labels for this widget. (See <code>list-mnemonic-labels()</code>). The widget must have previously been added to the list with <code>add-mnemonic-label()</code>.</p><pre class="pod-block-code">method remove-mnemonic-label ( N-GObject $label )</pre><ul>
<li><p>N-GObject $label; a <strong>Gnome::Gtk3::Widget</strong> that was previously set as a mnemonic label for <em>widget</em> with <code>add-mnemonic-label()</code>.</p></li>
</ul>

<h2 id="remove-tick-callback"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">remove-tick-callback</a></h2>
<p>Removes a tick callback previously registered with <code>add-tick-callback()</code>.</p><pre class="pod-block-code">method remove-tick-callback ( UInt $id )</pre><ul>
<li><p>UInt $id; an id returned by <code>add-tick-callback()</code></p></li>
</ul>

<h2 id="reset-style"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">reset-style</a></h2>
<p>Updates the style context of <em>widget</em> and all descendants by updating its widget path. <strong>Gnome::Gtk3::Containers</strong> may want to use this on a child when reordering it in a way that a different style might apply to it. See also <code>gtk-container-get-path-for-child()</code>.</p><pre class="pod-block-code">method reset-style ( )</pre>
<h2 id="send-focus-change"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">send-focus-change</a></h2>
<p>Sends the focus change <em>event</em> to <em>widget</em></p><p>This function is not meant to be used by applications. The only time it should be used is when it is necessary for a <strong>Gnome::Gtk3::Widget</strong> to assign focus to a widget that is semantically owned by the first widget even though it’s not a direct child - for instance, a search entry in a floating window similar to the quick search in <strong>Gnome::Gtk3::TreeView</strong>.</p><p>An example of its usage is:</p><p>|[&lt;!-- language=&quot;C&quot; --&gt; GdkEvent *fevent = gdk-event-new (GDK-FOCUS-CHANGE);</p><p>fevent-&gt;focus-change.type = GDK-FOCUS-CHANGE; fevent-&gt;focus-change.in = TRUE; fevent-&gt;focus-change.window = -get-window (widget); if (fevent-&gt;focus-change.window != NULL) g-object-ref (fevent-&gt;focus-change.window);</p><p>gtk-widget-send-focus-change (widget, fevent);</p><p>gdk-event-free (event); ]|</p><p>Returns: the return value from the event signal emission: <code>True</code> if the event was handled, and <code>False</code> otherwise</p><pre class="pod-block-code">method send-focus-change ( GdkEvent $event --&gt; Bool )</pre><ul>
<li><p>GdkEvent $event; a <strong>Gnome::Gtk3::Event</strong> of type GDK-FOCUS-CHANGE</p></li>
</ul>

<h2 id="set-accel-path"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-accel-path</a></h2>
<p>Given an accelerator group, <em>accel-group</em>, and an accelerator path, <em>accel-path</em>, sets up an accelerator in <em>accel-group</em> so whenever the key binding that is defined for <em>accel-path</em> is pressed, <em>widget</em> will be activated. This removes any accelerators (for any accelerator group) installed by previous calls to <code>set-accel-path()</code>. Associating accelerators with paths allows them to be modified by the user and the modifications to be saved for future use. (See <code>gtk-accel-map-save()</code>.)</p><p>This function is a low level function that would most likely be used by a menu creation system like <strong>Gnome::Gtk3::UIManager</strong>. If you use <strong>Gnome::Gtk3::UIManager</strong>, setting up accelerator paths will be done automatically.</p><p>Even when you you aren’t using <strong>Gnome::Gtk3::UIManager</strong>, if you only want to set up accelerators on menu items <code>gtk-menu-item-set-accel-path()</code> provides a somewhat more convenient interface.</p><p>Note that <em>accel-path</em> string will be stored in a <strong>Gnome::Gtk3::Quark</strong>. Therefore, if you pass a static string, you can save some memory by interning it first with <code>g-intern-static-string()</code>.</p><pre class="pod-block-code">method set-accel-path ( Str $accel_path, N-GObject $accel_group )</pre><ul>
<li><p>Str $accel_path; path used to look up the accelerator</p></li>
<li><p>N-GObject $accel_group; a <strong>Gnome::Gtk3::AccelGroup</strong>.</p></li>
</ul>

<h2 id="set-allocation"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-allocation</a></h2>
<p>Sets the widget’s allocation. This should not be used directly, but from within a widget’s size-allocate method.</p><p>The allocation set should be the “adjusted” or actual allocation. If you’re implementing a <strong>Gnome::Gtk3::Container</strong>, you want to use <code>size-allocate()</code> instead of <code>set-allocation()</code>. The GtkWidgetClass::adjust-size-allocation virtual method adjusts the allocation inside <code>size-allocate()</code> to create an adjusted allocation.</p><pre class="pod-block-code">method set-allocation ( N-GtkAllocation $allocation )</pre><ul>
<li><p>N-GtkAllocation $allocation; a pointer to a <strong>Gnome::Gtk3::Allocation</strong> to copy from</p></li>
</ul>

<h2 id="set-app-paintable"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-app-paintable</a></h2>
<p>Sets whether the application intends to draw on the widget in an <em>draw</em> handler.</p><p>This is a hint to the widget and does not affect the behavior of the GTK+ core; many widgets ignore this flag entirely. For widgets that do pay attention to the flag, such as <strong>Gnome::Gtk3::EventBox</strong> and <strong>Gnome::Gtk3::Window</strong>, the effect is to suppress default themed drawing of the widget's background. (Children of the widget will still be drawn.) The application is then entirely responsible for drawing the widget background.</p><p>Note that the background is still drawn when the widget is mapped.</p><pre class="pod-block-code">method set-app-paintable ( Bool $app_paintable )</pre><ul>
<li><p>Bool $app_paintable; <code>True</code> if the application will paint on the widget</p></li>
</ul>

<h2 id="set-can-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-can-default</a></h2>
<p>Specifies whether <em>widget</em> can be a default widget. See <code>grab-default()</code> for details about the meaning of “default”.</p><pre class="pod-block-code">method set-can-default ( Bool $can_default )</pre><ul>
<li><p>Bool $can_default; whether or not <em>widget</em> can be a default widget.</p></li>
</ul>

<h2 id="set-can-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-can-focus</a></h2>
<p>Specifies whether <em>widget</em> can own the input focus. See <code>grab-focus()</code> for actually setting the input focus on a widget.</p><pre class="pod-block-code">method set-can-focus ( Bool $can_focus )</pre><ul>
<li><p>Bool $can_focus; whether or not <em>widget</em> can own the input focus.</p></li>
</ul>

<h2 id="set-child-visible"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-child-visible</a></h2>
<p>Sets whether <em>widget</em> should be mapped along with its when its parent is mapped and <em>widget</em> has been shown with <code>show()</code>.</p><p>The child visibility can be set for widget before it is added to a container with <code>set-parent()</code>, to avoid mapping children unnecessary before immediately unmapping them. However it will be reset to its default state of <code>True</code> when the widget is removed from a container.</p><p>Note that changing the child visibility of a widget does not queue a resize on the widget. Most of the time, the size of a widget is computed from all visible children, whether or not they are mapped. If this is not the case, the container can queue a resize itself.</p><p>This function is only useful for container implementations and never should be called by an application.</p><pre class="pod-block-code">method set-child-visible ( Bool $is_visible )</pre><ul>
<li><p>Bool $is_visible; if <code>True</code>, <em>widget</em> should be mapped along with its parent.</p></li>
</ul>

<h2 id="set-clip"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-clip</a></h2>
<p>Sets the widget’s clip. This must not be used directly, but from within a widget’s size-allocate method. It must be called after <code>set-allocation()</code> (or after chaining up to the parent class), because that function resets the clip.</p><p>The clip set should be the area that <em>widget</em> draws on. If <em>widget</em> is a <strong>Gnome::Gtk3::Container</strong>, the area must contain all children's clips.</p><p>If this function is not called by <em>widget</em> during a <em>size-allocate</em> handler, the clip will be set to <em>widget</em>'s allocation.</p><pre class="pod-block-code">method set-clip ( N-GtkAllocation $clip )</pre><ul>
<li><p>N-GtkAllocation $clip; a pointer to a <strong>Gnome::Gtk3::Allocation</strong> to copy from</p></li>
</ul>

<h2 id="set-default-direction"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-default-direction</a></h2>
<p>Sets the default reading direction for widgets where the direction has not been explicitly set by <code>set-direction()</code>.</p><pre class="pod-block-code">method set-default-direction ( GtkTextDirection $dir )</pre><ul>
<li><p>GtkTextDirection $dir; the new default direction. This cannot be <code>GTK-TEXT-DIR-NONE</code>.</p></li>
</ul>

<h2 id="set-device-enabled"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-device-enabled</a></h2>
<p>Enables or disables a <strong>Gnome::Gdk3::Device</strong> to interact with <em>widget</em> and all its children.</p><p>It does so by descending through the <strong>Gnome::Gtk3::Window</strong> hierarchy and enabling the same mask that is has for core events (i.e. the one that <code>gdk-window-get-events()</code> returns).</p><pre class="pod-block-code">method set-device-enabled ( N-GObject $device, Bool $enabled )</pre><ul>
<li><p>N-GObject $device; a <strong>Gnome::Gdk3::Device</strong></p></li>
<li><p>Bool $enabled; whether to enable the device</p></li>
</ul>

<h2 id="set-device-events"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-device-events</a></h2>
<p>Sets the device event mask (see <strong>Gnome::Gtk3::EventMask</strong>) for a widget. The event mask determines which events a widget will receive from <em>device</em>. Keep in mind that different widgets have different default event masks, and by changing the event mask you may disrupt a widget’s functionality, so be careful. This function must be called while a widget is unrealized. Consider <code>add-device-events()</code> for widgets that are already realized, or if you want to preserve the existing event mask. This function can’t be used with windowless widgets (which return <code>False</code> from <code>get-has-window()</code>); to get events on those widgets, place them inside a <strong>Gnome::Gtk3::EventBox</strong> and receive events on the event box.</p><pre class="pod-block-code">method set-device-events ( N-GObject $device, Int $events )</pre><ul>
<li><p>N-GObject $device; a <strong>Gnome::Gdk3::Device</strong></p></li>
<li><p>Int $events; event mask with GdkEventMask flag values</p></li>
</ul>

<h2 id="set-direction"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-direction</a></h2>
<p>Sets the reading direction on a particular widget. This direction controls the primary direction for widgets containing text, and also the direction in which the children of a container are packed. The ability to set the direction is present in order so that correct localization into languages with right-to-left reading directions can be done. Generally, applications will let the default reading direction present, except for containers where the containers are arranged in an order that is explicitly visual rather than logical (such as buttons for text justification).</p><p>If the direction is set to <code>GTK-TEXT-DIR-NONE</code>, then the value set by <code>set-default-direction()</code> will be used.</p><pre class="pod-block-code">method set-direction ( GtkTextDirection $dir )</pre><ul>
<li><p>GtkTextDirection $dir; the new direction</p></li>
</ul>

<h2 id="set-events"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-events</a></h2>
<p>Sets the event mask (see <strong>Gnome::Gtk3::EventMask</strong>) for a widget. The event mask determines which events a widget will receive. Keep in mind that different widgets have different default event masks, and by changing the event mask you may disrupt a widget’s functionality, so be careful. This function must be called while a widget is unrealized. Consider <code>add-events()</code> for widgets that are already realized, or if you want to preserve the existing event mask. This function can’t be used with widgets that have no window. (See <code>get-has-window()</code>). To get events on those widgets, place them inside a <strong>Gnome::Gtk3::EventBox</strong> and receive events on the event box.</p><pre class="pod-block-code">method set-events ( Int $events )</pre><ul>
<li><p>Int $events; event mask</p></li>
</ul>

<h2 id="set-focus-on-click"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-focus-on-click</a></h2>
<p>Sets whether the widget should grab focus when it is clicked with the mouse. Making mouse clicks not grab focus is useful in places like toolbars where you don’t want the keyboard focus removed from the main area of the application.</p><pre class="pod-block-code">method set-focus-on-click ( Bool $focus_on_click )</pre><ul>
<li><p>Bool $focus_on_click; whether the widget should grab focus when clicked with the mouse</p></li>
</ul>

<h2 id="set-font-map"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-font-map</a></h2>
<p>Sets the font map to use for Pango rendering. When not set, the widget will inherit the font map from its parent.</p><pre class="pod-block-code">method set-font-map ( N-GObject $font_map )</pre><ul>
<li><p>N-GObject $font_map; a <strong>PangoFontMap</strong>, or <code>undefined</code> to unset any previously set font map</p></li>
</ul>

<h2 id="set-font-options"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-font-options</a></h2>
<p>Sets the <strong>cairo-font-options-t</strong> used for Pango rendering in this widget. When not set, the default font options for the <strong>Gnome::Gdk3::Screen</strong> will be used.</p><pre class="pod-block-code">method set-font-options ( cairo_font_options_t $options )</pre><ul>
<li><p>cairo_font_options_t $options; a <strong>cairo-font-options-t</strong>, or <code>undefined</code> to unset any previously set default font options.</p></li>
</ul>

<h2 id="set-halign"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-halign</a></h2>
<p>Sets the horizontal alignment of <em>widget</em>. See the <em>halign</em> property.</p><pre class="pod-block-code">method set-halign ( GtkAlign $align )</pre><ul>
<li><p>GtkAlign $align; the horizontal alignment</p></li>
</ul>

<h2 id="set-has-tooltip"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-has-tooltip</a></h2>
<p>Sets the has-tooltip property on <em>widget</em> to <em>has-tooltip</em>. See <em>has-tooltip</em> for more information.</p><pre class="pod-block-code">method set-has-tooltip ( Bool $has_tooltip )</pre><ul>
<li><p>Bool $has_tooltip; whether or not <em>widget</em> has a tooltip.</p></li>
</ul>

<h2 id="set-has-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-has-window</a></h2>
<p>Specifies whether <em>widget</em> has a <strong>Gnome::Gtk3::Window</strong> of its own. Note that all realized widgets have a non-<code>undefined</code> “window” pointer (<code>get-window()</code> never returns a <code>undefined</code> window when a widget is realized), but for many of them it’s actually the <strong>Gnome::Gtk3::Window</strong> of one of its parent widgets. Widgets that do not create a <code>window</code> for themselves in <em>realize</em> must announce this by calling this function with <em>has-window</em> = <code>False</code>.</p><p>This function should only be called by widget implementations, and they should call it in their <code>init()</code> function.</p><pre class="pod-block-code">method set-has-window ( Bool $has_window )</pre><ul>
<li><p>Bool $has_window; whether or not <em>widget</em> has a window.</p></li>
</ul>

<h2 id="set-hexpand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-hexpand</a></h2>
<p>Sets whether the widget would like any available extra horizontal space. When a user resizes a <strong>Gnome::Gtk3::Window</strong>, widgets with expand=TRUE generally receive the extra space. For example, a list or scrollable area or document in your window would often be set to expand.</p><p>Call this function to set the expand flag if you would like your widget to become larger horizontally when the window has extra room.</p><p>By default, widgets automatically expand if any of their children want to expand. (To see if a widget will automatically expand given its current children and state, call <code>compute-expand()</code>. A container can decide how the expandability of children affects the expansion of the container by overriding the compute-expand virtual method on <strong>Gnome::Gtk3::Widget</strong>.).</p><p>Setting hexpand explicitly with this function will override the automatic expand behavior.</p><p>This function forces the widget to expand or not to expand, regardless of children. The override occurs because <code>set-hexpand()</code> sets the hexpand-set property (see <code>set-hexpand-set()</code>) which causes the widget’s hexpand value to be used, rather than looking at children and widget state.</p><pre class="pod-block-code">method set-hexpand ( Bool $expand )</pre><ul>
<li><p>Bool $expand; whether to expand</p></li>
</ul>

<h2 id="set-hexpand-set"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-hexpand-set</a></h2>
<p>Sets whether the hexpand flag (see <code>get-hexpand()</code>) will be used.</p><p>The hexpand-set property will be set automatically when you call <code>set-hexpand()</code> to set hexpand, so the most likely reason to use this function would be to unset an explicit expand flag.</p><p>If hexpand is set, then it overrides any computed expand value based on child widgets. If hexpand is not set, then the expand value depends on whether any children of the widget would like to expand.</p><p>There are few reasons to use this function, but it’s here for completeness and consistency.</p><pre class="pod-block-code">method set-hexpand-set ( Bool $set )</pre><ul>
<li><p>Bool $set; value for hexpand-set property</p></li>
</ul>

<h2 id="set-mapped"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-mapped</a></h2>
<p>Marks the widget as being mapped.</p><p>This function should only ever be called in a derived widget's “map” or “unmap” implementation.</p><pre class="pod-block-code">method set-mapped ( Bool $mapped )</pre><ul>
<li><p>Bool $mapped; <code>True</code> to mark the widget as mapped</p></li>
</ul>

<h2 id="set-margin-bottom"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-margin-bottom</a></h2>
<p>Sets the bottom margin of <em>widget</em>. See the <em>margin-bottom</em> property.</p><pre class="pod-block-code">method set-margin-bottom ( Int $margin )</pre><ul>
<li><p>Int $margin; the bottom margin</p></li>
</ul>

<h2 id="set-margin-end"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-margin-end</a></h2>
<p>Sets the end margin of <em>widget</em>. See the <em>margin-end</em> property.</p><pre class="pod-block-code">method set-margin-end ( Int $margin )</pre><ul>
<li><p>Int $margin; the end margin</p></li>
</ul>

<h2 id="set-margin-start"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-margin-start</a></h2>
<p>Sets the start margin of <em>widget</em>. See the <em>margin-start</em> property.</p><pre class="pod-block-code">method set-margin-start ( Int $margin )</pre><ul>
<li><p>Int $margin; the start margin</p></li>
</ul>

<h2 id="set-margin-top"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-margin-top</a></h2>
<p>Sets the top margin of <em>widget</em>. See the <em>margin-top</em> property.</p><pre class="pod-block-code">method set-margin-top ( Int $margin )</pre><ul>
<li><p>Int $margin; the top margin</p></li>
</ul>

<h2 id="set-name"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-name</a></h2>
<p>Widgets can be named, which allows you to refer to them from a CSS file. You can apply a style to widgets with a particular name in the CSS file. See the documentation for the CSS syntax (on the same page as the docs for <strong>Gnome::Gtk3::StyleContext</strong>).</p><p>Note that the CSS syntax has certain special characters to delimit and represent elements in a selector (period, #, &gt;, *…), so using these will make your widget impossible to match by name. Any combination of alphanumeric symbols, dashes and underscores will suffice.</p><pre class="pod-block-code">method set-name ( Str $name )</pre><ul>
<li><p>Str $name; name for the widget</p></li>
</ul>

<h2 id="set-no-show-all"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-no-show-all</a></h2>
<p>Sets the <em>no-show-all</em> property, which determines whether calls to <code>show-all()</code> will affect this widget.</p><p>This is mostly for use in constructing widget hierarchies with externally controlled visibility, see <strong>Gnome::Gtk3::UIManager</strong>.</p><pre class="pod-block-code">method set-no-show-all ( Bool $no_show_all )</pre><ul>
<li><p>Bool $no_show_all; the new value for the “no-show-all” property</p></li>
</ul>

<h2 id="set-opacity"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-opacity</a></h2>
<p>Request the <em>widget</em> to be rendered partially transparent, with opacity 0 being fully transparent and 1 fully opaque. (Opacity values are clamped to the [0,1] range.). This works on both toplevel widget, and child widgets, although there are some limitations:</p><p>For toplevel widgets this depends on the capabilities of the windowing system. On X11 this has any effect only on X screens with a compositing manager running. See <code>is-composited()</code>. On Windows it should work always, although setting a window’s opacity after the window has been shown causes it to flicker once on Windows.</p><p>For child widgets it doesn’t work if any affected widget has a native window, or disables double buffering.</p><pre class="pod-block-code">method set-opacity ( Num() $opacity )</pre><ul>
<li><p>Num() $opacity; desired opacity, between 0 and 1</p></li>
</ul>

<h2 id="set-parent"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-parent</a></h2>
<p>This function is useful only when implementing subclasses of <strong>Gnome::Gtk3::Container</strong>. Sets the container as the parent of <em>widget</em>, and takes care of some details such as updating the state and style of the child to reflect its new location. The opposite function is <code>unparent()</code>.</p><pre class="pod-block-code">method set-parent ( N-GObject $parent )</pre><ul>
<li><p>N-GObject $parent; parent container</p></li>
</ul>

<h2 id="set-parent-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-parent-window</a></h2>
<p>Sets a non default parent window for <em>widget</em>.</p><p>For <strong>Gnome::Gtk3::Window</strong> classes, setting a <em>parent-window</em> effects whether the window is a toplevel window or can be embedded into other widgets.</p><p>For <strong>Gnome::Gtk3::Window</strong> classes, this needs to be called before the window is realized.</p><pre class="pod-block-code">method set-parent-window ( N-GObject $parent_window )</pre><ul>
<li><p>N-GObject $parent_window; the new parent window.</p></li>
</ul>

<h2 id="set-realized"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-realized</a></h2>
<p>Marks the widget as being realized. This function must only be called after all <strong>Gnome::Gtk3::Windows</strong> for the <em>widget</em> have been created and registered.</p><p>This function should only ever be called in a derived widget's “realize” or “unrealize” implementation.</p><pre class="pod-block-code">method set-realized ( Bool $realized )</pre><ul>
<li><p>Bool $realized; <code>True</code> to mark the widget as realized</p></li>
</ul>

<h2 id="set-receives-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-receives-default</a></h2>
<p>Specifies whether <em>widget</em> will be treated as the default widget within its toplevel when it has the focus, even if another widget is the default.</p><p>See <code>grab-default()</code> for details about the meaning of “default”.</p><pre class="pod-block-code">method set-receives-default ( Bool $receives_default )</pre><ul>
<li><p>Bool $receives_default; whether or not <em>widget</em> can be a default widget.</p></li>
</ul>

<h2 id="set-redraw-on-allocate"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-redraw-on-allocate</a></h2>
<p>Sets whether the entire widget is queued for drawing when its size allocation changes. By default, this setting is <code>True</code> and the entire widget is redrawn on every size change. If your widget leaves the upper left unchanged when made bigger, turning this setting off will improve performance. Note that for widgets where <code>get-has-window()</code> is <code>False</code> setting this flag to <code>False</code> turns off all allocation on resizing: the widget will not even redraw if its position changes; this is to allow containers that don’t draw anything to avoid excess invalidations. If you set this flag on a widget with no window that does draw on <em>widget</em>-&gt;window, you are responsible for invalidating both the old and new allocation of the widget when the widget is moved and responsible for invalidating regions newly when the widget increases size.</p><pre class="pod-block-code">method set-redraw-on-allocate ( Bool $redraw_on_allocate )</pre><ul>
<li><p>Bool $redraw_on_allocate; if <code>True</code>, the entire widget will be redrawn when it is allocated to a new size. Otherwise, only the new portion of the widget will be redrawn.</p></li>
</ul>

<h2 id="set-sensitive"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-sensitive</a></h2>
<p>Sets the sensitivity of a widget. A widget is sensitive if the user can interact with it. Insensitive widgets are “grayed out” and the user can’t interact with them. Insensitive widgets are known as “inactive”, “disabled”, or “ghosted” in some other toolkits.</p><pre class="pod-block-code">method set-sensitive ( Bool $sensitive )</pre><ul>
<li><p>Bool $sensitive; <code>True</code> to make the widget sensitive</p></li>
</ul>

<h2 id="set-size-request"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-size-request</a></h2>
<p>Sets the minimum size of a widget; that is, the widget’s size request will be at least <em>width</em> by <em>height</em>. You can use this function to force a widget to be larger than it normally would be.</p><p>In most cases, <code>gtk-window-set-default-size()</code> is a better choice for toplevel windows than this function; setting the default size will still allow users to shrink the window. Setting the size request will force them to leave the window at least as large as the size request. When dealing with window sizes, <code>gtk-window-set-geometry-hints()</code> can be a useful function as well.</p><p>Note the inherent danger of setting any fixed size - themes, translations into other languages, different fonts, and user action can all change the appropriate size for a given widget. So, it's basically impossible to hardcode a size that will always be correct.</p><p>The size request of a widget is the smallest size a widget can accept while still functioning well and drawing itself correctly. However in some strange cases a widget may be allocated less than its requested size, and in many cases a widget may be allocated more space than it requested.</p><p>If the size request in a given direction is -1 (unset), then the “natural” size request of the widget will be used instead.</p><p>The size request set here does not include any margin from the <strong>Gnome::Gtk3::Widget</strong> properties margin-left, margin-right, margin-top, and margin-bottom, but it does include pretty much all other padding or border properties set by any subclass of <strong>Gnome::Gtk3::Widget</strong>.</p><pre class="pod-block-code">method set-size-request ( Int $width, Int $height )</pre><ul>
<li><p>Int $width; width <em>widget</em> should request, or -1 to unset</p></li>
<li><p>Int $height; height <em>widget</em> should request, or -1 to unset</p></li>
</ul>

<h2 id="set-state-flags"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-state-flags</a></h2>
<p>This function is for use in widget implementations. Turns on flag values in the current widget state (insensitive, prelighted, etc.).</p><p>This function accepts the values <code>GTK-STATE-FLAG-DIR-LTR</code> and <code>GTK-STATE-FLAG-DIR-RTL</code> but ignores them. If you want to set the widget's direction, use <code>set-direction()</code>.</p><p>It is worth mentioning that any other state than <code>GTK-STATE-FLAG-INSENSITIVE</code>, will be propagated down to all non-internal children if <em>widget</em> is a <strong>Gnome::Gtk3::Container</strong>, while <code>GTK-STATE-FLAG-INSENSITIVE</code> itself will be propagated down to all <strong>Gnome::Gtk3::Container</strong> children by different means than turning on the state flag down the hierarchy, both <code>get-state-flags()</code> and <code>is-sensitive()</code> will make use of these.</p><pre class="pod-block-code">method set-state-flags ( UInt $flags, Bool $clear )</pre><ul>
<li><p>UInt $flags; State flags to turn on. Flags are defined by GtkStateFlags.</p></li>
<li><p>Bool $clear; Whether to clear state before turning on <em>flags</em></p></li>
</ul>

<h2 id="set-support-multidevice"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-support-multidevice</a></h2>
<p>Enables or disables multiple pointer awareness. If this setting is <code>True</code>, <em>widget</em> will start receiving multiple, per device enter/leave events. Note that if custom <strong>Gnome::Gtk3::Windows</strong> are created in a <em>realize</em> signal handler, <code>Gnome::Gdk3::Window.set-support-multidevice()</code> will have to be called manually on them.</p><pre class="pod-block-code">method set-support-multidevice ( Bool $support_multidevice )</pre><ul>
<li><p>Bool $support_multidevice; <code>True</code> to support input from multiple devices.</p></li>
</ul>

<h2 id="set-tooltip-markup"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-tooltip-markup</a></h2>
<p>Sets <em>markup</em> as the contents of the tooltip, which is marked up with the [Pango text markup language][PangoMarkupFormat].</p><p>This function will take care of setting <em>has-tooltip</em> to <code>True</code> and of the default handler for the <em>query-tooltip</em> signal.</p><p>See also the <em>tooltip-markup</em> property and <code>gtk-tooltip-set-markup()</code>.</p><pre class="pod-block-code">method set-tooltip-markup ( Str $markup )</pre><ul>
<li><p>Str $markup; the contents of the tooltip for <em>widget</em>, or <code>undefined</code></p></li>
</ul>

<h2 id="set-tooltip-text"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-tooltip-text</a></h2>
<p>Sets <em>text</em> as the contents of the tooltip. This function will take care of setting <em>has-tooltip</em> to <code>True</code> and of the default handler for the <em>query-tooltip</em> signal.</p><p>See also the <em>tooltip-text</em> property and <code>gtk-tooltip-set-text()</code>.</p><pre class="pod-block-code">method set-tooltip-text ( Str $text )</pre><ul>
<li><p>Str $text; the contents of the tooltip for <em>widget</em></p></li>
</ul>

<h2 id="set-tooltip-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-tooltip-window</a></h2>
<p>Replaces the default window used for displaying tooltips with <em>custom-window</em>. GTK+ will take care of showing and hiding <em>custom-window</em> at the right moment, to behave likewise as the default tooltip window. If <em>custom-window</em> is <code>undefined</code>, the default tooltip window will be used.</p><pre class="pod-block-code">method set-tooltip-window ( N-GObject $custom_window )</pre><ul>
<li><p>N-GObject $custom_window; a <strong>Gnome::Gtk3::Window</strong>, or <code>undefined</code></p></li>
</ul>

<h2 id="set-valign"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-valign</a></h2>
<p>Sets the vertical alignment of <em>widget</em>. See the <em>valign</em> property.</p><pre class="pod-block-code">method set-valign ( GtkAlign $align )</pre><ul>
<li><p>GtkAlign $align; the vertical alignment</p></li>
</ul>

<h2 id="set-vexpand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-vexpand</a></h2>
<p>Sets whether the widget would like any available extra vertical space.</p><p>See <code>set-hexpand()</code> for more detail.</p><pre class="pod-block-code">method set-vexpand ( Bool $expand )</pre><ul>
<li><p>Bool $expand; whether to expand</p></li>
</ul>

<h2 id="set-vexpand-set"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-vexpand-set</a></h2>
<p>Sets whether the vexpand flag (see <code>get-vexpand()</code>) will be used.</p><p>See <code>set-hexpand-set()</code> for more detail.</p><pre class="pod-block-code">method set-vexpand-set ( Bool $set )</pre><ul>
<li><p>Bool $set; value for vexpand-set property</p></li>
</ul>

<h2 id="set-visible"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-visible</a></h2>
<p>Sets the visibility state of <em>widget</em>. Note that setting this to <code>True</code> doesn’t mean the widget is actually viewable, see <code>get-visible()</code>.</p><p>This function simply calls <code>show()</code> or <code>hide()</code> but is nicer to use when the visibility of the widget depends on some condition.</p><pre class="pod-block-code">method set-visible ( Bool $visible )</pre><ul>
<li><p>Bool $visible; whether the widget should be shown or not</p></li>
</ul>

<h2 id="set-visual"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-visual</a></h2>
<p>Sets the visual that should be used for by widget and its children for creating <strong>Gnome::Gtk3::Windows</strong>. The visual must be on the same <strong>Gnome::Gdk3::Screen</strong> as returned by <code>get-screen()</code>, so handling the <em>screen-changed</em> signal is necessary.</p><p>Setting a new <em>visual</em> will not cause <em>widget</em> to recreate its windows, so you should call this function before <em>widget</em> is realized.</p><pre class="pod-block-code">method set-visual ( N-GObject $visual )</pre><ul>
<li><p>N-GObject $visual; visual to be used or <code>undefined</code> to unset a previous one</p></li>
</ul>

<h2 id="set-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">set-window</a></h2>
<p>Sets a widget’s window. This function should only be used in a widget’s <em>realize</em> implementation. The <code>window</code> passed is usually either new window created with <code>gdk-window-new()</code>, or the window of its parent widget as returned by <code>get-parent-window()</code>.</p><p>Widgets must indicate whether they will create their own <strong>Gnome::Gtk3::Window</strong> by calling <code>set-has-window()</code>. This is usually done in the widget’s <code>init()</code> function.</p><p>Note that this function does not add any reference to <em>window</em>.</p><pre class="pod-block-code">method set-window ( N-GObject $window )</pre><ul>
<li><p>N-GObject $window; a <strong>Gnome::Gtk3::Window</strong></p></li>
</ul>

<h2 id="shape-combine-region"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">shape-combine-region</a></h2>
<p>Sets a shape for this widget’s GDK window. This allows for transparent windows etc., see <code>gdk-window-shape-combine-region()</code> for more information.</p><pre class="pod-block-code">method shape-combine-region ( cairo_region_t $region )</pre><ul>
<li><p>cairo_region_t $region; shape to be added, or <code>undefined</code> to remove an existing shape</p></li>
</ul>

<h2 id="show"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">show</a></h2>
<p>Flags a widget to be displayed. Any widget that isn’t shown will not appear on the screen. If you want to show all the widgets in a container, it’s easier to call <code>show-all()</code> on the container, instead of individually showing the widgets.</p><p>Remember that you have to show the containers containing a widget, in addition to the widget itself, before it will appear onscreen.</p><p>When a toplevel container is shown, it is immediately realized and mapped; other shown widgets are realized and mapped when their toplevel container is realized and mapped.</p><pre class="pod-block-code">method show ( )</pre>
<h2 id="show-all"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">show-all</a></h2>
<p>Recursively shows a widget, and any child widgets (if the widget is a container).</p><pre class="pod-block-code">method show-all ( )</pre>
<h2 id="show-now"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">show-now</a></h2>
<p>Shows a widget. If the widget is an unmapped toplevel widget (i.e. a <strong>Gnome::Gtk3::Window</strong> that has not yet been shown), enter the main loop and wait for the window to actually be mapped. Be careful; because the main loop is running, anything can happen during this function.</p><pre class="pod-block-code">method show-now ( )</pre>
<h2 id="size-allocate"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">size-allocate</a></h2>
<p>This function is only used by <strong>Gnome::Gtk3::Container</strong> subclasses, to assign a size and position to their child widgets.</p><p>In this function, the allocation may be adjusted. It will be forced to a 1x1 minimum size, and the adjust-size-allocation virtual method on the child will be used to adjust the allocation. Standard adjustments include removing the widget’s margins, and applying the widget’s <em>halign</em> and <em>valign</em> properties.</p><p>For baseline support in containers you need to use <code>size-allocate-with-baseline()</code> instead.</p><pre class="pod-block-code">method size-allocate ( N-GtkAllocation $allocation )</pre><ul>
<li><p>N-GtkAllocation $allocation; position and size to be allocated to <em>widget</em></p></li>
</ul>

<h2 id="size-allocate-with-baseline"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">size-allocate-with-baseline</a></h2>
<p>This function is only used by <strong>Gnome::Gtk3::Container</strong> subclasses, to assign a size, position and (optionally) baseline to their child widgets.</p><p>In this function, the allocation and baseline may be adjusted. It will be forced to a 1x1 minimum size, and the adjust-size-allocation virtual and adjust-baseline-allocation methods on the child will be used to adjust the allocation and baseline. Standard adjustments include removing the widget's margins, and applying the widget’s <em>halign</em> and <em>valign</em> properties.</p><p>If the child widget does not have a valign of <code>GTK-ALIGN-BASELINE</code> the baseline argument is ignored and -1 is used instead.</p><pre class="pod-block-code">method size-allocate-with-baseline ( N-GtkAllocation $allocation, Int $baseline )</pre><ul>
<li><p>N-GtkAllocation $allocation; position and size to be allocated to <em>widget</em></p></li>
<li><p>Int $baseline; The baseline of the child, or -1</p></li>
</ul>

<h2 id="style-get"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">style-get</a></h2>
<p>Gets the values of a multiple style properties of <em>widget</em>.</p><pre class="pod-block-code">method style-get ( Str $first_property_name )</pre><ul>
<li><p>Str $first_property_name; the name of the first property to get @…: pairs of property names and locations to return the property values, starting with the location for <em>first-property-name</em>, terminated by <code>undefined</code>.</p></li>
</ul>

<h2 id="style-get-property"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">style-get-property</a></h2>
<p>Gets the value of a style property of <em>widget</em>.</p><pre class="pod-block-code">method style-get-property ( Str $property_name, N-GObject $value )</pre><ul>
<li><p>Str $property_name; the name of a style property</p></li>
<li><p>N-GObject $value; location to return the property value</p></li>
</ul>

<h2 id="style-get-valist"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">style-get-valist</a></h2>
<p>Non-vararg variant of <code>style-get()</code>. Used primarily by language bindings.</p><pre class="pod-block-code">method style-get-valist ( Str $first_property_name, va_list $var_args )</pre><ul>
<li><p>Str $first_property_name; the name of the first property to get</p></li>
<li><p>va_list $var_args; a va-list of pairs of property names and locations to return the property values, starting with the location for <em>first-property-name</em>.</p></li>
</ul>

<h2 id="thaw-child-notify"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">thaw-child-notify</a></h2>
<p>Reverts the effect of a previous call to <code>freeze-child-notify()</code>. This causes all queued <em>child-notify</em> signals on <em>widget</em> to be emitted.</p><pre class="pod-block-code">method thaw-child-notify ( )</pre>
<h2 id="translate-coordinates"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">translate-coordinates</a></h2>
<p>Translate coordinates relative to this widget’s allocation to coordinates relative to <em>$dest-widget</em>’s allocations. In order to perform this operation, both widgets must be realized, and must share a common toplevel.</p><pre class="pod-block-code">method translate-coordinates (
  N-GObject $dest_widget, Int $src_x, Int $src_y --&gt; List
)</pre><ul>
<li><p>N-GObject $dest_widget; a <strong>Gnome::Gtk3::Widget</strong></p></li>
<li><p>Int $src_x; X position relative to this widget</p></li>
<li><p>Int $src_y; Y position relative to this widget</p></li>
</ul>
<p>Returns a List which holds;</p><ul>
<li><p>Bool result; &lt;False&gt; if either widget was not realized, or there was no common ancestor. In this case, the next values are undefined. Otherwise <code>True</code> and the next values are defined Int.</p></li>
<li><p>Int dest_x; X position relative to <em>$dest-widget</em></p></li>
<li><p>Int dest_y; Y position relative to <em>$dest-widget</em></p></li>
</ul>

<h2 id="trigger-tooltip-query"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">trigger-tooltip-query</a></h2>
<p>Triggers a tooltip query on the display where the toplevel of <em>widget</em> is located. See <code>gtk-tooltip-trigger-tooltip-query()</code> for more information.</p><pre class="pod-block-code">method trigger-tooltip-query ( )</pre>
<h2 id="unmap"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">unmap</a></h2>
<p>This function is only for use in widget implementations. Causes a widget to be unmapped if it’s currently mapped.</p><pre class="pod-block-code">method unmap ( )</pre>
<h2 id="unparent"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">unparent</a></h2>
<p>This function is only for use in widget implementations. Should be called by implementations of the remove method on <strong>Gnome::Gtk3::Container</strong>, to dissociate a child from the container.</p><pre class="pod-block-code">method unparent ( )</pre>
<h2 id="unrealize"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">unrealize</a></h2>
<p>This function is only useful in widget implementations. Causes a widget to be unrealized (frees all GDK resources associated with the widget, such as <em>widget</em>-&gt;window).</p><pre class="pod-block-code">method unrealize ( )</pre>
<h2 id="unregister-window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">unregister-window</a></h2>
<p>Unregisters a <strong>Gnome::Gtk3::Window</strong> from the widget that was previously set up with <code>register-window()</code>. You need to call this when the window is no longer used by the widget, such as when you destroy it.</p><pre class="pod-block-code">method unregister-window ( N-GObject $window )</pre><ul>
<li><p>N-GObject $window; a <strong>Gnome::Gtk3::Window</strong></p></li>
</ul>

<h2 id="unset-state-flags"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">unset-state-flags</a></h2>
<p>This function is for use in widget implementations. Turns off flag values for the current widget state (insensitive, prelighted, etc.). See <code>set-state-flags()</code>.</p><pre class="pod-block-code">method unset-state-flags ( UInt $flags )</pre><ul>
<li><p>UInt $flags; State flags to turn off. Flags are bits defined by GtkStateFlags</p></li>
</ul>

<h2 id="_gtk_widget_new"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">_gtk_widget_new</a></h2>
<p>This is a convenience function for creating a widget and setting its properties in one go. For example you might write: `new (GTK-TYPE-LABEL, &quot;label&quot;, &quot;Hello World&quot;, &quot;xalign&quot;, 0.0, NULL)` to create a left-aligned label. Equivalent to <code>g-object-new()</code>, but returns a widget so you don’t have to cast the object yourself.</p><p>Returns: a new <strong>Gnome::Gtk3::Widget</strong> of type <em>widget-type</em></p><pre class="pod-block-code">method _gtk_widget_new ( N-GObject $type, Str $first_property_name --&gt; N-GObject )</pre><ul>
<li><p>N-GObject $type; type ID of the widget to create</p></li>
<li><p>Str $first_property_name; name of first property to set @…: value of first property, followed by more properties, <code>undefined</code>-terminated</p></li>
</ul>

<h1 id="Signals"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Signals</a></h1>
<p>There are two ways to connect to a signal. The first option you have is to use <code>register-signal()</code> from <strong>Gnome::GObject::Object</strong>. The second option is to use <code>connect-object()</code> directly from <strong>Gnome::GObject::Signal</strong>.</p>
<h2 id="First_method"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">First method</a></h2>
<p>The positional arguments of the signal handler are all obligatory as well as their types. The named attributes <code>:$widget</code> and user data are optional.</p><pre class="pod-block-code"># handler method
method mouse-event ( GdkEvent $event, :$widget ) { … }

# connect a signal on window object
my Gnome::Gtk3::Window $w .= new( … );
$w.register-signal( self, 'mouse-event', 'button-press-event');</pre>
<h2 id="Second_method"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Second method</a></h2>
<pre class="pod-block-code">my Gnome::Gtk3::Window $w .= new( … );
my Callable $handler = sub (
  N-GObject $native, GdkEvent $event, OpaquePointer $data
) {
  …
}

$w.connect-object( 'button-press-event', $handler);</pre><p>Also here, the types of positional arguments in the signal handler are important. This is because both methods <code>register-signal()</code> and <code>connect-object()</code> are using the signatures of the handler routines to setup the native call interface.</p>
<h2 id="Supported_signals"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Supported signals</a></h2>

<h3 id="accel-closures-changed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">accel-closures-changed</a></h3>
<pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
</ul>

<h3 id="button-press-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">button-press-event</a></h3>
<p>The <em>button-press-event</em> signal will be emitted when a button (typically from a mouse) is pressed.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-BUTTON-PRESS-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventButton): the event which triggered this signal.</p></li>
</ul>

<h3 id="button-release-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">button-release-event</a></h3>
<p>The <em>button-release-event</em> signal will be emitted when a button (typically from a mouse) is released.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-BUTTON-RELEASE-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>False</code> to stop other handlers from being invoked for the event. <code>True</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventButton): the event which triggered this signal.</p></li>
</ul>

<h3 id="configure-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">configure-event</a></h3>
<p>The <em>configure-event</em> signal will be emitted when the size, position or stacking of the <em>widget</em>'s window has changed.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-STRUCTURE-MASK</code> mask. GDK will enable this mask automatically for all new windows.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventConfigure): the event which triggered this signal.</p></li>
</ul>

<h3 id="damage-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">damage-event</a></h3>
<p>Emitted when a redirected window belonging to <em>widget</em> gets drawn into. The region/area members of the event shows what area of the redirected drawable was drawn into.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventExpose): the event event</p></li>
</ul>

<h3 id="delete-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">delete-event</a></h3>
<p>The <em>delete-event</em> signal is emitted if a user requests that a toplevel window is closed. The default handler for this signal destroys the window. Connecting <code>hide-on-delete()</code> to this signal will cause the window to be hidden instead, so that it can later be shown again without reconstructing it.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; the event which triggered this signal</p></li>
</ul>

<h3 id="destroy_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">destroy</a></h3>
<p>Signals that all holders of a reference to the widget should release the reference that they hold. May result in finalization of the widget if all references are released.</p><p>This signal is not suitable for saving widget state.</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($object),
  *%user-options
);</pre><ul>
<li><p>$object; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
</ul>

<h3 id="destroy-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">destroy-event</a></h3>
<p>The <em>destroy-event</em> signal is emitted when a <strong>Gnome::Gtk3::Window</strong> is destroyed. You rarely get this signal, because most widgets disconnect themselves from their window before they destroy it, so no widget owns the window at destroy time.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-STRUCTURE-MASK</code> mask. GDK will enable this mask automatically for all new windows.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; the event which triggered this signal</p></li>
</ul>

<h3 id="direction-changed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">direction-changed</a></h3>
<p>The <em>direction-changed</em> signal is emitted when the text direction of a widget changes.</p><pre class="pod-block-code">method handler (
  GEnum $previous_direction,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object on which the signal is emitted</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$previous_direction; the previous text direction of <em>widget</em> as a GTK_TYPE_TEXT_DIRECTION enum</p></li>
</ul>

<h3 id="drag-begin"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-begin</a></h3>
<p>The <em>drag-begin</em> signal is emitted on the drag source when a drag is started. A typical reason to connect to this signal is to set up a custom drag icon with e.g. <code>gtk-drag-source-set-icon-pixbuf()</code>.</p><p>Note that some widgets set up a drag icon in the default handler of this signal, so you may have to use <code>g-signal-connect-after()</code> to override what the default handler did.</p><pre class="pod-block-code">method handler (
  N-GObject $context,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$context; the drag context</p></li>
</ul>

<h3 id="drag-data-delete"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-data-delete</a></h3>
<p>The <em>drag-data-delete</em> signal is emitted on the drag source when a drag with the action <code>GDK-ACTION-MOVE</code> is successfully completed. The signal handler is responsible for deleting the data that has been dropped. What &quot;delete&quot; means depends on the context of the drag operation.</p><pre class="pod-block-code">method handler (
  Unknown type GDK_TYPE_DRAG_CONTEXT $context,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$context; the drag context</p></li>
</ul>

<h3 id="drag-data-get"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-data-get</a></h3>
<p>The <em>drag-data-get</em> signal is emitted on the drag source when the drop site requests the data which is dragged. It is the responsibility of the signal handler to fill <em>$data</em> with the data in the format which is indicated by <em>info</em>. See <code>gtk-selection-data-set()</code> and <code>gtk-selection-data-set-text()</code>.</p><pre class="pod-block-code">method handler (
  N-GObject $context,
  N-GObject $data,
  UInt $info,
  UInt $time,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$context; the drag context, a native</p></li>
<li><p>$data; the native <strong>Gnome::Gtk3::SelectionData</strong> to be filled with the dragged data</p></li>
<li><p>$info; the info that has been registered with the target in the <strong>Gnome::Gtk3::TargetList</strong></p></li>
<li><p>$time; the timestamp at which the data was requested</p></li>
</ul>

<h3 id="drag-data-received"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-data-received</a></h3>
<p>The <em>drag-data-received</em> signal is emitted on the drop site when the dragged data has been received. If the data was received in order to determine whether the drop will be accepted, the handler is expected to call <code>gdk-drag-status()</code> and not finish the drag. If the data was received in response to a <em>drag-drop</em> signal (and this is the last target to be received), the handler for this signal is expected to process the received data and then call <code>gtk-drag-finish()</code>, setting the <em>success</em> parameter depending on whether the data was processed successfully.</p><p>Applications must create some means to determine why the signal was emitted and therefore whether to call <code>gdk-drag-status()</code> or <code>gtk-drag-finish()</code>.</p><p>The handler method API:</p><pre class="pod-block-code">method handler (
  N-GObject $context,
  Int $x,
  Int $y,
  N-GObject $data,
  UInt $info,
  UInt $time,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$context; the drag context</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$x; where the drop happened</p></li>
<li><p>$y; where the drop happened</p></li>
<li><p>$data; the received data</p></li>
<li><p>$info; the info that has been registered with the target in the <strong>Gnome::Gtk3::TargetList</strong></p></li>
<li><p>$time; the timestamp at which the data was received</p></li>
</ul>

<h3 id="drag-drop"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-drop</a></h3>
<p>The <em>drag-drop</em> signal is emitted on the drop site when the user drops the data onto the widget. The signal handler must determine whether the cursor position is in a drop zone or not. If it is not in a drop zone, it returns <code>False</code> and no further processing is necessary. Otherwise, the handler returns <code>True</code>. In this case, the handler must ensure that <code>gtk-drag-finish()</code> is called to let the source know that the drop is done. The call to <code>gtk-drag-finish()</code> can be done either directly or in a <em>drag-data-received</em> handler which gets triggered by calling <code>gtk-drag-get-data()</code> to receive the data for one or more of the supported targets.</p><p>Returns: whether the cursor position is in a drop zone</p><pre class="pod-block-code">method handler (
  N-GObject $context,
  Int $x,
  Int $y,
  UInt $time,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$context; the drag context</p></li>
<li><p>$x; the x coordinate of the current cursor position</p></li>
<li><p>$y; the y coordinate of the current cursor position</p></li>
<li><p>$time; the timestamp of the motion event</p></li>
</ul>

<h3 id="drag-end"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-end</a></h3>
<p>The <em>drag-end</em> signal is emitted on the drag source when a drag is finished. A typical reason to connect to this signal is to undo things done in <em>drag-begin</em>.</p><pre class="pod-block-code">method handler (
  N-GObject $context,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$context; the drag context</p></li>
</ul>

<h3 id="drag-failed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-failed</a></h3>
<p>The <em>drag-failed</em> signal is emitted on the drag source when a drag has failed. The signal handler may hook custom code to handle a failed DnD operation based on the type of error, it returns <code>True</code> is the failure has been already handled (not showing the default &quot;drag operation failed&quot; animation), otherwise it returns <code>False</code>.</p><p>Returns: <code>True</code> if the failed drag operation has been already handled.</p><pre class="pod-block-code">method handler (
  N-GObject $context,
  Int $result,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Bool
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$context; the drag context</p></li>
<li><p>$result; the result of the drag operation. a enum from GtkDragResult</p></li>
</ul>

<h3 id="drag-leave"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-leave</a></h3>
<p>The <em>drag-leave</em> signal is emitted on the drop site when the cursor leaves the widget. A typical reason to connect to this signal is to undo things done in <em>drag-motion</em>, e.g. undo highlighting with <code>gtk-drag-unhighlight()</code>.</p><p>Likewise, the <em>drag-leave</em> signal is also emitted before the <em>drag-drop</em> signal, for instance to allow cleaning up of a preview item created in the <em>drag-motion</em> signal handler.</p><pre class="pod-block-code">method handler (
  N-GObject $context,
  UInt $time,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$context; the drag context</p></li>
<li><p>$time; the timestamp of the motion event</p></li>
</ul>

<h3 id="drag-motion"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">drag-motion</a></h3>
<p>The <em>drag-motion</em> signal is emitted on the drop site when the user moves the cursor over the widget during a drag. The signal handler must determine whether the cursor position is in a drop zone or not. If it is not in a drop zone, it returns <code>False</code> and no further processing is necessary. Otherwise, the handler returns <code>True</code>. In this case, the handler is responsible for providing the necessary information for displaying feedback to the user, by calling <code>gdk-drag-status()</code>.</p><p>If the decision whether the drop will be accepted or rejected can't be made based solely on the cursor position and the type of the data, the handler may inspect the dragged data by calling <code>gtk-drag-get-data()</code> and defer the <code>gdk-drag-status()</code> call to the <em>drag-data-received</em> handler. Note that you must pass <code>GTK-DEST-DEFAULT-DROP</code>, <code>GTK-DEST-DEFAULT-MOTION</code> or <code>GTK-DEST-DEFAULT-ALL</code> to <code>gtk-drag-dest-set()</code> when using the drag-motion signal that way.</p><p>Also note that there is no drag-enter signal. The drag receiver has to keep track of whether he has received any drag-motion signals since the last <em>drag-leave</em> and if not, treat the drag-motion signal as an &quot;enter&quot; signal. Upon an &quot;enter&quot;, the handler will typically highlight the drop site with <code>gtk-drag-highlight()</code>.</p><p>Returns: whether the cursor position is in a drop zone</p><pre class="pod-block-code">method handler (
  N-GObject $context,
  Int $x,
  Int $y,
  Int $time,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$context; the drag context</p></li>
<li><p>$x; the x coordinate of the current cursor position</p></li>
<li><p>$y; the y coordinate of the current cursor position</p></li>
<li><p>$time; the timestamp of the motion event</p></li>
</ul>

<h3 id="draw_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">draw</a></h3>
<p>This signal is emitted when a widget is supposed to render itself. The <em>widget</em>'s top left corner must be painted at the origin of the passed in context and be sized to the values returned by <code>get-allocated-width()</code> and <code>get-allocated-height()</code>.</p><p>Signal handlers connected to this signal can modify the cairo context passed as <em>cr</em> in any way they like and don't need to restore it. The signal emission takes care of calling <code>cairo-save()</code> before and <code>cairo-restore()</code> after invoking the handler.</p><p>The signal handler will get a <em>cr</em> with a clip region already set to the widget's dirty region, i.e. to the area that needs repainting. Complicated widgets that want to avoid redrawing themselves completely can get the full extents of the clip region with <code>gdk-cairo-get-clip-rectangle()</code>, or they can get a finer-grained representation of the dirty region with <code>cairo-copy-clip-rectangle-list()</code>.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  cairo_t $cr,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$cr; the cairo context to draw to</p></li>
</ul>

<h3 id="enter-notify-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">enter-notify-event</a></h3>
<p>The <em>enter-notify-event</em> will be emitted when the pointer enters the <em>widget</em>'s window.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-ENTER-NOTIFY-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventCrossing): the event which triggered this signal.</p></li>
</ul>

<h3 id="event_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">event</a></h3>
<p>The GTK+ main loop will emit three signals for each GDK event delivered to a widget: one generic <em>event</em> signal, another, more specific, signal that matches the type of event delivered (e.g. <em>key-press-event</em>) and finally a generic <em>event-after</em> signal.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event and to cancel the emission of the second specific <em>event</em> signal. <code>False</code> to propagate the event further and to allow the emission of the second signal. The <em>event-after</em> signal is emitted regardless of the return value.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; the <strong>Gnome::Gtk3::Event</strong> which triggered this signal</p></li>
</ul>

<h3 id="event-after"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">event-after</a></h3>
<p>After the emission of the <em>event</em> signal and (optionally) the second more specific signal, <em>event-after</em> will be emitted regardless of the previous two signals handlers return values.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; the <strong>Gnome::Gtk3::Event</strong> which triggered this signal</p></li>
</ul>

<h3 id="focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">focus</a></h3>
<p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  Int $direction,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$direction; it is an enumeration <code>GtkDirectionType</code>.</p></li>
</ul>

<h3 id="focus-in-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">focus-in-event</a></h3>
<p>The <em>focus-in-event</em> signal will be emitted when the keyboard focus enters the <em>widget</em>'s window.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-FOCUS-CHANGE-MASK</code> mask.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventFocus): the event which triggered this signal.</p></li>
</ul>

<h3 id="focus-out-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">focus-out-event</a></h3>
<p>The <em>focus-out-event</em> signal will be emitted when the keyboard focus leaves the <em>widget</em>'s window.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-FOCUS-CHANGE-MASK</code> mask.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventFocus): the event which triggered this signal.</p></li>
</ul>

<h3 id="grab-broken-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">grab-broken-event</a></h3>
<p>Emitted when a pointer or keyboard grab on a window belonging to <em>widget</em> gets broken.</p><p>On X11, this happens when the grab window becomes unviewable (i.e. it or one of its ancestors is unmapped), or if the same application grabs the pointer or keyboard again.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventGrabBroken): the event event</p></li>
</ul>

<h3 id="grab-focus_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">grab-focus</a></h3>
<pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
</ul>

<h3 id="grab-notify"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">grab-notify</a></h3>
<p>The <em>grab-notify</em> signal is emitted when a widget becomes shadowed by a GTK+ grab (not a pointer or keyboard grab) on another widget, or when it becomes unshadowed due to a grab being removed.</p><p>A widget is shadowed by a <code>gtk-grab-add()</code> when the topmost grab widget in the grab stack of its window group is not its ancestor.</p><pre class="pod-block-code">method handler (
  Int $was_grabbed,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$was_grabbed; <code>False</code> if the widget becomes shadowed, <code>True</code> if it becomes unshadowed</p></li>
</ul>

<h3 id="hide_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">hide</a></h3>
<p>The <em>hide</em> signal is emitted when <em>widget</em> is hidden, for example with <code>hide()</code>.</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
</ul>

<h3 id="hierarchy-changed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">hierarchy-changed</a></h3>
<p>The <em>hierarchy-changed</em> signal is emitted when the anchored state of a widget changes. A widget is “anchored” when its toplevel ancestor is a <strong>Gnome::Gtk3::Window</strong>. This signal is emitted when a widget changes from un-anchored to anchored or vice-versa.</p><pre class="pod-block-code">method handler (
  N-GObject $previous_toplevel,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object on which the signal is emitted</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$previous_toplevel; (allow-none): the previous toplevel ancestor, or <code>undefined</code> if the widget was previously unanchored</p></li>
</ul>

<h3 id="key-press-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">key-press-event</a></h3>
<p>The <em>key-press-event</em> signal is emitted when a key is pressed. The signal emission will reoccur at the key-repeat rate when the key is kept pressed.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-KEY-PRESS-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventKey): the event which triggered this signal.</p></li>
</ul>

<h3 id="key-release-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">key-release-event</a></h3>
<p>The <em>key-release-event</em> signal is emitted when a key is released.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-KEY-RELEASE-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventKey): the event which triggered this signal.</p></li>
</ul>

<h3 id="keynav-failed_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">keynav-failed</a></h3>
<p>Gets emitted if keyboard navigation fails. See <code>keynav-failed()</code> for details.</p><p>Returns: <code>1</code> if stopping keyboard navigation is fine, <code>0</code> if the emitting widget should try to handle the keyboard navigation attempt in its parent container(s).</p><pre class="pod-block-code">method handler (
  Int $direction,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$direction; the direction of movement, an enum GtkDirectionType value</p></li>
</ul>

<h3 id="leave-notify-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">leave-notify-event</a></h3>
<p>The <em>leave-notify-event</em> will be emitted when the pointer leaves the <em>widget</em>'s window.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-LEAVE-NOTIFY-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventCrossing): the event which triggered this signal.</p></li>
</ul>

<h3 id="map_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">map</a></h3>
<p>The <em>map</em> signal is emitted when <em>widget</em> is going to be mapped, that is when the widget is visible (which is controlled with <code>set-visible()</code>) and all its parents up to the toplevel widget are also visible. Once the map has occurred, <em>map-event</em> will be emitted.</p><p>The <em>map</em> signal can be used to determine whether a widget will be drawn, for instance it can resume an animation that was stopped during the emission of <em>unmap</em>.</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
</ul>

<h3 id="map-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">map-event</a></h3>
<p>The <em>map-event</em> signal will be emitted when the <em>widget</em>'s window is mapped. A window is mapped when it becomes visible on the screen.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-STRUCTURE-MASK</code> mask. GDK will enable this mask automatically for all new windows.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventAny): the event which triggered this signal.</p></li>
</ul>

<h3 id="mnemonic-activate_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">mnemonic-activate</a></h3>
<p>The default handler for this signal activates <em>widget</em> if <em>group-cycling</em> is <code>False</code>, or just makes <em>widget</em> grab focus if <em>group-cycling</em> is <code>True</code>.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  Bool $group_cycling,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$group_cycling; <code>True</code> if there are other widgets with the same mnemonic</p></li>
</ul>

<h3 id="motion-notify-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">motion-notify-event</a></h3>
<p>The <em>motion-notify-event</em> signal is emitted when the pointer moves over the widget's <strong>Gnome::Gtk3::Window</strong>.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-POINTER-MOTION-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventMotion): the event which triggered this signal.</p></li>
</ul>

<h3 id="move-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">move-focus</a></h3>
<pre class="pod-block-code">method handler (
  Unknown type GTK_TYPE_DIRECTION_TYPE $direction,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$direction;</p></li>
</ul>

<h3 id="parent-set"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">parent-set</a></h3>
<p>The <em>parent-set</em> signal is emitted when a new parent has been set on a widget.</p><pre class="pod-block-code">method handler (
  N-GObject #`{ is widget } $old_parent,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object on which the signal is emitted</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$old_parent; (allow-none): the previous parent, or <code>undefined</code> if the widget just got its initial parent.</p></li>
</ul>

<h3 id="popup-menu"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">popup-menu</a></h3>
<p>This signal gets emitted whenever a widget should pop up a context menu. This usually happens through the standard key binding mechanism; by pressing a certain key while a widget is focused, the user can cause the widget to pop up a menu. For example, the <strong>Gnome::Gtk3::Entry</strong> widget creates a menu with clipboard commands. See the Popup Menu Migration Checklist for an example of how to use this signal.</p><p>Returns: <code>True</code> if a menu was activated</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
</ul>

<h3 id="property-notify-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">property-notify-event</a></h3>
<p>The <em>property-notify-event</em> signal will be emitted when a property on the <em>widget</em>'s window has been changed or deleted.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-PROPERTY-CHANGE-MASK</code> mask.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventProperty): the event which triggered this signal.</p></li>
</ul>

<h3 id="proximity-in-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">proximity-in-event</a></h3>
<p>To receive this signal the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-PROXIMITY-IN-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  Unknown type GTK_TYPE_SELECTION_DATA | G_SIGNAL_TYPE_STATIC_SCOPE $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventProximity): the event which triggered this signal.</p></li>
</ul>

<h3 id="proximity-out-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">proximity-out-event</a></h3>
<p>To receive this signal the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-PROXIMITY-OUT-MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventProximity): the event which triggered this signal.</p></li>
</ul>

<h3 id="query-tooltip"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">query-tooltip</a></h3>
<p>Emitted when <em>has-tooltip</em> is <code>True</code> and the hover timeout has expired with the cursor hovering &quot;above&quot; <em>widget</em>; or emitted when <em>widget</em> got focus in keyboard mode.</p><p>Using the given coordinates, the signal handler should determine whether a tooltip should be shown for <em>widget</em>. If this is the case <code>True</code> should be returned, <code>False</code> otherwise. Note that if <em>keyboard-mode</em> is <code>True</code>, the values of <em>x</em> and <em>y</em> are undefined and should not be used.</p><p>The signal handler is free to manipulate <em>tooltip</em> with the therefore destined function calls.</p><p>Returns: <code>True</code> if <em>tooltip</em> should be shown right now, <code>False</code> otherwise.</p><pre class="pod-block-code">method handler (
  Unknown type GDK_TYPE_EVENT | G_SIGNAL_TYPE_STATIC_SCOPE $x,
  - $y,
  - $keyboard_mode,
  - $tooltip,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$x; the x coordinate of the cursor position where the request has been emitted, relative to <em>widget</em>'s left side</p></li>
<li><p>$y; the y coordinate of the cursor position where the request has been emitted, relative to <em>widget</em>'s top</p></li>
<li><p>$keyboard_mode; <code>True</code> if the tooltip was triggered using the keyboard</p></li>
<li><p>$tooltip; a <strong>Gnome::Gtk3::Tooltip</strong></p></li>
</ul>

<h3 id="realize_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">realize</a></h3>
<p>The <em>realize</em> signal is emitted when <em>widget</em> is associated with a <strong>Gnome::Gtk3::Window</strong>, which means that <code>realize()</code> has been called or the widget has been mapped (that is, it is going to be drawn).</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
</ul>

<h3 id="screen-changed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">screen-changed</a></h3>
<p>The <em>screen-changed</em> signal gets emitted when the screen of a widget has changed.</p><pre class="pod-block-code">method handler (
  - $previous_screen,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object on which the signal is emitted</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$previous_screen; (allow-none): the previous screen, or <code>undefined</code> if the widget was not associated with a screen before</p></li>
</ul>

<h3 id="scroll-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">scroll-event</a></h3>
<p>The <em>scroll-event</em> signal is emitted when a button in the 4 to 7 range is pressed. Wheel mice are usually configured to generate button press events for buttons 4 and 5 when the wheel is turned.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK_SCROLL_MASK</code> mask.</p><p>This signal will be sent to the grab widget if there is one.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventScroll): the event which triggered this signal.</p></li>
</ul>

<h3 id="selection-clear-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">selection-clear-event</a></h3>
<p>The <em>selection-clear-event</em> signal will be emitted when the the <em>widget</em>'s window has lost ownership of a selection.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventSelection): the event which triggered this signal.</p></li>
</ul>

<h3 id="selection-get"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">selection-get</a></h3>
<pre class="pod-block-code">method handler (
  N-GObject $data,
  UInt $info,
  UInt $time,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$data; a native GtkSelectionData object</p></li>
<li><p>$info; ?</p></li>
<li><p>$time;</p></li>
</ul>

<h3 id="selection-notify-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">selection-notify-event</a></h3>
<p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventSelection): the event which triggered this signal.</p></li>
</ul>

<h3 id="selection-received"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">selection-received</a></h3>
<pre class="pod-block-code">method handler (
  N-GObject $data,
  UInt $time,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$data; a native GtkSelectionData object</p></li>
<li><p>$time;</p></li>
</ul>

<h3 id="selection-request-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">selection-request-event</a></h3>
<p>The <em>selection-request-event</em> signal will be emitted when another client requests ownership of the selection owned by the <em>widget</em>'s window.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventSelection): the event which triggered this signal.</p></li>
</ul>

<h3 id="show_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">show</a></h3>
<p>The <em>show</em> signal is emitted when <em>widget</em> is shown, for example with <code>show()</code>.</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
</ul>

<h3 id="show-help"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">show-help</a></h3>
<p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  - $help_type,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$help_type;</p></li>
</ul>

<h3 id="size-allocate_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">size-allocate</a></h3>
<pre class="pod-block-code">method handler (
  Unknown type GDK_TYPE_RECTANGLE | G_SIGNAL_TYPE_STATIC_SCOPE $allocation,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$allocation; (type Gtk.Allocation): the region which has been allocated to the widget.</p></li>
</ul>

<h3 id="state-flags-changed"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">state-flags-changed</a></h3>
<p>The <em>state-flags-changed</em> signal is emitted when the widget state changes, see <code>get-state-flags()</code>.</p><pre class="pod-block-code">method handler (
  Unknown type GTK_TYPE_STATE_FLAGS $flags,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$flags; The previous state flags.</p></li>
</ul>

<h3 id="style-updated"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">style-updated</a></h3>
<p>The <em>style-updated</em> signal is a convenience signal that is emitted when the <em>changed</em> signal is emitted on the <em>widget</em>'s associated <strong>Gnome::Gtk3::StyleContext</strong> as returned by <code>get-style-context()</code>.</p><p>Note that style-modifying functions like <code>override-color()</code> also cause this signal to be emitted.</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object on which the signal is emitted</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
</ul>

<h3 id="unmap_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">unmap</a></h3>
<p>The <em>unmap</em> signal is emitted when <em>widget</em> is going to be unmapped, which means that either it or any of its parents up to the toplevel widget have been set as hidden.</p><p>As <em>unmap</em> indicates that a widget will not be shown any longer, it can be used to, for example, stop an animation on the widget.</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
</ul>

<h3 id="unmap-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">unmap-event</a></h3>
<p>The <em>unmap-event</em> signal will be emitted when the <em>widget</em>'s window is unmapped. A window is unmapped when it becomes invisible on the screen.</p><p>To receive this signal, the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-STRUCTURE-MASK</code> mask. GDK will enable this mask automatically for all new windows.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventAny): the event which triggered this signal</p></li>
</ul>

<h3 id="unrealize_0"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">unrealize</a></h3>
<p>The <em>unrealize</em> signal is emitted when the <strong>Gnome::Gtk3::Window</strong> associated with <em>widget</em> is destroyed, which means that <code>unrealize()</code> has been called or the widget has been unmapped (that is, it is going to be hidden).</p><pre class="pod-block-code">method handler (
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
);</pre><ul>
<li><p>$widget; the object which received the signal.</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
</ul>

<h3 id="window-state-event"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">window-state-event</a></h3>
<p>The <em>window-state-event</em> will be emitted when the state of the toplevel window associated to the <em>widget</em> changes.</p><p>To receive this signal the <strong>Gnome::Gtk3::Window</strong> associated to the widget needs to enable the <code>GDK-STRUCTURE-MASK</code> mask. GDK will enable this mask automatically for all new windows.</p><p>Returns: <code>True</code> to stop other handlers from being invoked for the event. <code>False</code> to propagate the event further.</p><pre class="pod-block-code">method handler (
  N-GdkEvent $event,
  Int :$_handle_id,
  Gnome::GObject::Object :_widget($widget),
  *%user-options
  --&gt; Int
);</pre><ul>
<li><p>$widget; the object which received the signal</p></li>
<li><p>$_handle_id; the registered event handler id</p></li>
<li><p>$event; (type N-GdkEventWindowState): the event which triggered this signal.</p></li>
</ul>

<h1 id="Properties"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Properties</a></h1>
<p>An example of using a string type property of a <strong>Gnome::Gtk3::Label</strong> object. This is just showing how to set/read a property, not that it is the best way to do it. This is because a) The class initialization often provides some options to set some of the properties and b) the classes provide many methods to modify just those properties. In the case below one can use <code>new(:label('my text label'))</code> or <code>set-text('my text label')</code>.</p><pre class="pod-block-code">my Gnome::Gtk3::Label $label .= new;
my Gnome::GObject::Value $gv .= new(:init(G_TYPE_STRING));
$label.get-property( 'label', $gv);
$gv.set-string('my text label');</pre>
<h2 id="Supported_properties"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Supported properties</a></h2>

<h3 id="Application_paintable:_app-paintable"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Application paintable: app-paintable</a></h3>
<p>Whether the application will paint directly on the widget Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>app-paintable</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Can_default:_can-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Can default: can-default</a></h3>
<p>Whether the widget can be the default widget Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>can-default</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Can_focus:_can-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Can focus: can-focus</a></h3>
<p>Whether the widget can accept the input focus Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>can-focus</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Composite_child:_composite-child"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Composite child: composite-child</a></h3>
<p>Whether the widget is part of a composite widget Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>composite-child</em> is <code>G_TYPE_BOOLEAN</code>. Value is read only.</p>
<h3 id="Events:_events"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Events: events</a></h3>
<p>The event mask that decides what kind of GdkEvents this widget gets.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>events</em> is <code>G_TYPE_FLAGS</code>.</p>
<h3 id="Expand_Both:_expand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Expand Both: expand</a></h3>
<p>Whether to expand in both directions. Setting this sets both <em>hexpand</em> and <em>vexpand</em></p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>expand</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Focus_on_click:_focus-on-click"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Focus on click: focus-on-click</a></h3>
<p>Whether the widget should grab focus when it is clicked with the mouse.</p><p>This property is only relevant for widgets that can take focus.</p><p>Before 3.20, several widgets (GtkButton, GtkFileChooserButton, GtkComboBox) implemented this property individually.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>focus-on-click</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Horizontal_Alignment:_halign"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Horizontal Alignment: halign</a></h3>
<p>How to distribute horizontal space if widget gets extra space, see <strong>Gnome::Gtk3::Align</strong></p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>halign</em> is <code>G_TYPE_ENUM</code>.</p>
<h3 id="Has_default:_has-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Has default: has-default</a></h3>
<p>Whether the widget is the default widget. Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>has-default</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Has_focus:_has-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Has focus: has-focus</a></h3>
<p>Whether the widget has the input focus. Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>has-focus</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Has_tooltip:_has-tooltip"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Has tooltip: has-tooltip</a></h3>
<p>Enables or disables the emission of <em>query-tooltip</em> on <em>widget</em>. A value of <code>True</code> indicates that <em>widget</em> can have a tooltip, in this case the widget will be queried using <em>query-tooltip</em> to determine whether it will provide a tooltip or not.</p><p>Note that setting this property to <code>True</code> for the first time will change the event masks of the GdkWindows of this widget to include leave-notify and motion-notify events. This cannot and will not be undone when the property is set to <code>False</code> again.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>has-tooltip</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Height_request:_height-request"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Height request: height-request</a></h3>
<p>The <strong>Gnome::GObject::Value</strong> type of property <em>height-request</em> is <code>G_TYPE_INT</code>.</p>
<h3 id="Horizontal_Expand:_hexpand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Horizontal Expand: hexpand</a></h3>
<p>Whether to expand horizontally. See <code>set-hexpand()</code>.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>hexpand</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Horizontal_Expand_Set:_hexpand-set"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Horizontal Expand Set: hexpand-set</a></h3>
<p>Whether to use the <em>hexpand</em> property. See <code>get-hexpand-set()</code>.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>hexpand-set</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Is_focus:_is-focus"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Is focus: is-focus</a></h3>
<p>Whether the widget is the focus widget within the toplevel. Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>is-focus</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="All_Margins:_margin"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">All Margins: margin</a></h3>
<p>Sets all four sides' margin at once. If read, returns max margin on any side.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>margin</em> is <code>G_TYPE_INT</code>.</p>
<h3 id="Margin_on_Bottom:_margin-bottom"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Margin on Bottom: margin-bottom</a></h3>
<p>Margin on bottom side of widget.</p><p>This property adds margin outside of the widget's normal size request, the margin will be added in addition to the size from <code>set-size-request()</code> for example.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>margin-bottom</em> is <code>G_TYPE_INT</code>.</p>
<h3 id="Margin_on_End:_margin-end"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Margin on End: margin-end</a></h3>
<p>Margin on end of widget, horizontally. This property supports left-to-right and right-to-left text directions.</p><p>This property adds margin outside of the widget's normal size request, the margin will be added in addition to the size from <code>set-size-request()</code> for example.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>margin-end</em> is <code>G_TYPE_INT</code>.</p>
<h3 id="Margin_on_Start:_margin-start"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Margin on Start: margin-start</a></h3>
<p>Margin on start of widget, horizontally. This property supports left-to-right and right-to-left text directions.</p><p>This property adds margin outside of the widget's normal size request, the margin will be added in addition to the size from <code>set-size-request()</code> for example.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>margin-start</em> is <code>G_TYPE_INT</code>.</p>
<h3 id="Margin_on_Top:_margin-top"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Margin on Top: margin-top</a></h3>
<p>Margin on top side of widget.</p><p>This property adds margin outside of the widget's normal size request, the margin will be added in addition to the size from <code>set-size-request()</code> for example.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>margin-top</em> is <code>G_TYPE_INT</code>.</p>
<h3 id="Widget_name:_name"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Widget name: name</a></h3>
<p>The name of the widget Default value: Any</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>name</em> is <code>G_TYPE_STRING</code>.</p>
<h3 id="No_show_all:_no-show-all"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">No show all: no-show-all</a></h3>
<p>Whether show-all should not affect this widget. Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>no-show-all</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Opacity_for_Widget:_opacity"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Opacity for Widget: opacity</a></h3>
<p>The requested opacity of the widget. See <code>set-opacity()</code> for more details about window opacity.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>opacity</em> is <code>G_TYPE_DOUBLE</code>.</p>
<h3 id="Parent_widget:_parent"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Parent widget: parent</a></h3>
<p>The parent widget of this widget. Must be a Container widget Widget type: GTK-TYPE-CONTAINER</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>parent</em> is <code>G_TYPE_OBJECT</code>.</p>
<h3 id="Receives_default:_receives-default"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Receives default: receives-default</a></h3>
<p>If TRUE, the widget will receive the default action when it is focused Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>receives-default</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Scale_factor:_scale-factor"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Scale factor: scale-factor</a></h3>
<p>The scale factor of the widget. See <code>get-scale-factor()</code> for more details about widget scaling.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>scale-factor</em> is <code>G_TYPE_INT</code>.</p>
<h3 id="Sensitive:_sensitive"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Sensitive: sensitive</a></h3>
<p>Whether the widget responds to input Default value: True</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>sensitive</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Tooltip_markup:_tooltip-markup"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Tooltip markup: tooltip-markup</a></h3>
<p>Sets the text of tooltip to be the given string, which is marked up with the [Pango text markup language][PangoMarkupFormat]. Also see <code>gtk-tooltip-set-markup()</code>.</p><p>This is a convenience property which will take care of getting the tooltip shown if the given string is not <code>undefined</code>: <em>has-tooltip</em> will automatically be set to <code>True</code> and there will be taken care of <em>query-tooltip</em> in the default signal handler.</p><p>Note that if both <em>tooltip-text</em> and <em>tooltip-markup</em> are set, the last one wins.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>tooltip-markup</em> is <code>G_TYPE_STRING</code>.</p>
<h3 id="Tooltip_Text:_tooltip-text"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Tooltip Text: tooltip-text</a></h3>
<p>Sets the text of tooltip to be the given string.</p><p>Also see <code>gtk-tooltip-set-text()</code>.</p><p>This is a convenience property which will take care of getting the tooltip shown if the given string is not <code>undefined</code>: <em>has-tooltip</em> will automatically be set to <code>True</code> and there will be taken care of <em>query-tooltip</em> in the default signal handler.</p><p>Note that if both <em>tooltip-text</em> and <em>tooltip-markup</em> are set, the last one wins.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>tooltip-text</em> is <code>G_TYPE_STRING</code>.</p>
<h3 id="Vertical_Alignment:_valign"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Vertical Alignment: valign</a></h3>
<p>How to distribute vertical space if widget gets extra space, see <strong>Gnome::Gtk3::Align</strong></p><p>Widget type: GTK_TYPE_ALIGN</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>valign</em> is <code>G_TYPE_ENUM</code>.</p>
<h3 id="Vertical_Expand:_vexpand"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Vertical Expand: vexpand</a></h3>
<p>Whether to expand vertically. See <code>set-vexpand()</code>.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>vexpand</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Vertical_Expand_Set:_vexpand-set"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Vertical Expand Set: vexpand-set</a></h3>
<p>Whether to use the <em>vexpand</em> property. See <code>get-vexpand-set()</code>.</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>vexpand-set</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Visible:_visible"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Visible: visible</a></h3>
<p>Whether the widget is visible Default value: False</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>visible</em> is <code>G_TYPE_BOOLEAN</code>.</p>
<h3 id="Width_request:_width-request"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Width request: width-request</a></h3>
<p>The <strong>Gnome::GObject::Value</strong> type of property <em>width-request</em> is <code>G_TYPE_INT</code>.</p>
<h3 id="Window:_window"><a href="#Gnome::Gtk3::Widget" class="u" title="go to top of document">Window: window</a></h3>
<p>The widget's window if it is realized, <code>undefined</code> otherwise.</p><p>Widget type: GDK_TYPE_WINDOW</p><p>The <strong>Gnome::GObject::Value</strong> type of property <em>window</em> is <code>G_TYPE_OBJECT</code>.</p></section>		</div>
</div><footer><div>Rendered from <span class="path">/home/marcel/Languages/Raku/Projects/gnome-api1/gnome-gtk3/lib/Gnome/Gtk3/Widget.rakumod</span></div><div>at <span class="time">2025-07-19T14:13:38Z</span></div></footer>
	</body>
</html>
