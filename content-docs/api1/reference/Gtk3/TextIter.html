---
---
<!doctype html>
<html lang="en">
<head>
<title>Gnome::Gtk3::TextIter</title>
<meta charset="UTF-8" />

<link href="asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />

</head>
	<body class="pod">
<header><img src="asset_files/images/gtk-raku.png" id="Camelia_bug"><h2 class="title" id="Gnome::Gtk3::TextIter">Gnome::Gtk3::TextIter</h2></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#Description">Description</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Synopsis">Synopsis</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Declaration">Declaration</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#enum_GtkTextSearchFlags">enum GtkTextSearchFlags</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#new">new</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_buffer">[[gtk_] text_iter_] get_buffer</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[gtk_]_text_iter_copy">[gtk_] text_iter_copy</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[gtk_]_text_iter_free">[gtk_] text_iter_free</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[gtk_]_text_iter_assign">[gtk_] text_iter_assign</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_offset">[[gtk_] text_iter_] get_offset</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_line">[[gtk_] text_iter_] get_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_line_offset">[[gtk_] text_iter_] get_line_offset</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_line_index">[[gtk_] text_iter_] get_line_index</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_visible_line_offset">[[gtk_] text_iter_] get_visible_line_offset</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_visible_line_index">[[gtk_] text_iter_] get_visible_line_index</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_char">[[gtk_] text_iter_] get_char</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_slice">[[gtk_] text_iter_] get_slice</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_text">[[gtk_] text_iter_] get_text</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_visible_slice">[[gtk_] text_iter_] get_visible_slice</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_visible_text">[[gtk_] text_iter_] get_visible_text</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_pixbuf">[[gtk_] text_iter_] get_pixbuf</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_marks">[[gtk_] text_iter_] get_marks</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_child_anchor">[[gtk_] text_iter_] get_child_anchor</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_toggled_tags">[[gtk_] text_iter_] get_toggled_tags</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_starts_tag">[[gtk_] text_iter_] starts_tag</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_ends_tag">[[gtk_] text_iter_] ends_tag</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_toggles_tag">[[gtk_] text_iter_] toggles_tag</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_has_tag">[[gtk_] text_iter_] has_tag</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_tags">[[gtk_] text_iter_] get_tags</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[gtk_]_text_iter_editable">[gtk_] text_iter_editable</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_can_insert">[[gtk_] text_iter_] can_insert</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_starts_word">[[gtk_] text_iter_] starts_word</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_ends_word">[[gtk_] text_iter_] ends_word</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_inside_word">[[gtk_] text_iter_] inside_word</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_starts_sentence">[[gtk_] text_iter_] starts_sentence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_ends_sentence">[[gtk_] text_iter_] ends_sentence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_inside_sentence">[[gtk_] text_iter_] inside_sentence</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_starts_line">[[gtk_] text_iter_] starts_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_ends_line">[[gtk_] text_iter_] ends_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_is_cursor_position">[[gtk_] text_iter_] is_cursor_position</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_chars_in_line">[[gtk_] text_iter_] get_chars_in_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_bytes_in_line">[[gtk_] text_iter_] get_bytes_in_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_attributes">[[gtk_] text_iter_] get_attributes</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_get_language">[[gtk_] text_iter_] get_language</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_is_end">[[gtk_] text_iter_] is_end</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_is_start">[[gtk_] text_iter_] is_start</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_char">[[gtk_] text_iter_] forward_char</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_char">[[gtk_] text_iter_] backward_char</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_chars">[[gtk_] text_iter_] forward_chars</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_chars">[[gtk_] text_iter_] backward_chars</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_line">[[gtk_] text_iter_] forward_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_line">[[gtk_] text_iter_] backward_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_lines">[[gtk_] text_iter_] forward_lines</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_lines">[[gtk_] text_iter_] backward_lines</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_word_end">[[gtk_] text_iter_] forward_word_end</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_word_start">[[gtk_] text_iter_] backward_word_start</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_word_ends">[[gtk_] text_iter_] forward_word_ends</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_word_starts">[[gtk_] text_iter_] backward_word_starts</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_visible_line">[[gtk_] text_iter_] forward_visible_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_visible_line">[[gtk_] text_iter_] backward_visible_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_visible_lines">[[gtk_] text_iter_] forward_visible_lines</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_visible_lines">[[gtk_] text_iter_] backward_visible_lines</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_visible_word_end">[[gtk_] text_iter_] forward_visible_word_end</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_visible_word_start">[[gtk_] text_iter_] backward_visible_word_start</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_visible_word_ends">[[gtk_] text_iter_] forward_visible_word_ends</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_visible_word_starts">[[gtk_] text_iter_] backward_visible_word_starts</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_sentence_end">[[gtk_] text_iter_] forward_sentence_end</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_sentence_start">[[gtk_] text_iter_] backward_sentence_start</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_sentence_ends">[[gtk_] text_iter_] forward_sentence_ends</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_sentence_starts">[[gtk_] text_iter_] backward_sentence_starts</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_cursor_position">[[gtk_] text_iter_] forward_cursor_position</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_cursor_position">[[gtk_] text_iter_] backward_cursor_position</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_cursor_positions">[[gtk_] text_iter_] forward_cursor_positions</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_cursor_positions">[[gtk_] text_iter_] backward_cursor_positions</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_visible_cursor_position">[[gtk_] text_iter_] forward_visible_cursor_position</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_visible_cursor_position">[[gtk_] text_iter_] backward_visible_cursor_position</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_visible_cursor_positions">[[gtk_] text_iter_] forward_visible_cursor_positions</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_visible_cursor_positions">[[gtk_] text_iter_] backward_visible_cursor_positions</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_set_offset">[[gtk_] text_iter_] set_offset</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_set_line">[[gtk_] text_iter_] set_line</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_set_line_offset">[[gtk_] text_iter_] set_line_offset</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_set_line_index">[[gtk_] text_iter_] set_line_index</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_to_end">[[gtk_] text_iter_] forward_to_end</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_to_line_end">[[gtk_] text_iter_] forward_to_line_end</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_set_visible_line_offset">[[gtk_] text_iter_] set_visible_line_offset</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_set_visible_line_index">[[gtk_] text_iter_] set_visible_line_index</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_to_tag_toggle">[[gtk_] text_iter_] forward_to_tag_toggle</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_to_tag_toggle">[[gtk_] text_iter_] backward_to_tag_toggle</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_find_char">[[gtk_] text_iter_] forward_find_char</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_find_char">[[gtk_] text_iter_] backward_find_char</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_forward_search">[[gtk_] text_iter_] forward_search</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_backward_search">[[gtk_] text_iter_] backward_search</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[gtk_]_text_iter_equal">[gtk_] text_iter_equal</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[gtk_]_text_iter_compare">[gtk_] text_iter_compare</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[[gtk_]_text_iter_]_in_range">[[gtk_] text_iter_] in_range</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#[gtk_]_text_iter_order">[gtk_] text_iter_order</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top"><p>Text buffer iterator</p>
<h1 id="Description"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">Description</a></h1>
<p>You may wish to begin by reading the [text widget conceptual overview](https://developer.gnome.org/gtk3/3.24/TextWidget.html) which gives an overview of all the objects and data types related to the text widget and how they work together.</p>
<h1 id="Synopsis"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">Synopsis</a></h1>

<h2 id="Declaration"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">Declaration</a></h2>
<pre class="pod-block-code">unit class Gnome::Gtk3::TextIter;
also is Gnome::GObject::Boxed;</pre>
<h2 id="enum_GtkTextSearchFlags"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">enum GtkTextSearchFlags</a></h2>
<p>Flags affecting how a search is done.</p><p>If neither <code>GTK_TEXT_SEARCH_VISIBLE_ONLY</code> nor <code>GTK_TEXT_SEARCH_TEXT_ONLY</code> are enabled, the match must be exact; the special 0xFFFC character will match embedded pixbufs or child widgets.</p><ul>
<li><p>GTK_TEXT_SEARCH_VISIBLE_ONLY: Search only visible data. A search match may have invisible text interspersed.</p></li>
<li><p>GTK_TEXT_SEARCH_TEXT_ONLY: Search only text. A match may have pixbufs or child widgets mixed inside the matched range.</p></li>
<li><p>GTK_TEXT_SEARCH_CASE_INSENSITIVE: The text will be matched regardless of what case it is in.</p></li>
</ul>

<h1 id="Methods"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">Methods</a></h1>

<h2 id="new"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">new</a></h2>
<p>Create a new plain object.</p><pre class="pod-block-code">multi method new ( )</pre><p>Create a new object using a native object from elsewhere.</p><pre class="pod-block-code">multi method new ( Bool :$native-object! )</pre>
<h2 id="[[gtk_]_text_iter_]_get_buffer"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_buffer</a></h2>
<p>Returns the <strong>Gnome::Gtk3::TextBuffer</strong> this iterator is associated with.</p><p>Returns: (transfer none): the buffer</p><pre class="pod-block-code">method gtk_text_iter_get_buffer ( --&gt; N-GObject  )</pre>
<h2 id="[gtk_]_text_iter_copy"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[gtk_] text_iter_copy</a></h2>
<p>Creates a dynamically-allocated copy of an iterator. This function is not useful in applications, because iterators can be copied with a simple assignment (`<strong>Gnome::Gtk3::TextIter</strong> i = j;`). The function is used by language bindings.</p><p>Returns: a copy of the <em>iter</em>, free with <code>gtk_text_iter_free()</code></p><pre class="pod-block-code">method gtk_text_iter_copy ( --&gt; N-GObject  )</pre>
<h2 id="[gtk_]_text_iter_free"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[gtk_] text_iter_free</a></h2>
<p>Free an iterator allocated on the heap. This function is intended for use in language bindings, and is not especially useful for applications, because iterators can simply be allocated on the stack.</p><pre class="pod-block-code">method gtk_text_iter_free ( )</pre>
<h2 id="[gtk_]_text_iter_assign"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[gtk_] text_iter_assign</a></h2>
<p>Assigns the value of <em>other</em> to <em>iter</em>. This function is not useful in applications, because iterators can be assigned with `<strong>Gnome::Gtk3::TextIter</strong> i = j;`. The function is used by language bindings.</p><p>Since: 3.2</p><pre class="pod-block-code">method gtk_text_iter_assign ( N-GObject $other )</pre><ul>
<li><p>N-GObject $other; another <strong>Gnome::Gtk3::TextIter</strong></p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_get_offset"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_offset</a></h2>
<p>Returns the character offset of an iterator. Each character in a <strong>Gnome::Gtk3::TextBuffer</strong> has an offset, starting with 0 for the first character in the buffer. Use <code>gtk_text_buffer_get_iter_at_offset()</code> to convert an offset back into an iterator.</p><p>Returns: a character offset</p><pre class="pod-block-code">method gtk_text_iter_get_offset ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_line</a></h2>
<p>Returns the line number containing the iterator. Lines in a <strong>Gnome::Gtk3::TextBuffer</strong> are numbered beginning with 0 for the first line in the buffer.</p><p>Returns: a line number</p><pre class="pod-block-code">method gtk_text_iter_get_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_line_offset"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_line_offset</a></h2>
<p>Returns the character offset of the iterator, counting from the start of a newline-terminated line. The first character on the line has offset 0.</p><p>Returns: offset from start of line</p><pre class="pod-block-code">method gtk_text_iter_get_line_offset ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_line_index"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_line_index</a></h2>
<p>Returns the byte index of the iterator, counting from the start of a newline-terminated line. Remember that <strong>Gnome::Gtk3::TextBuffer</strong> encodes text in UTF-8, and that characters can require a variable number of bytes to represent.</p><p>Returns: distance from start of line, in bytes</p><pre class="pod-block-code">method gtk_text_iter_get_line_index ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_visible_line_offset"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_visible_line_offset</a></h2>
<p>Returns the offset in characters from the start of the line to the given <em>iter</em>, not counting characters that are invisible due to tags with the “invisible” flag toggled on.</p><p>Returns: offset in visible characters from the start of the line</p><pre class="pod-block-code">method gtk_text_iter_get_visible_line_offset ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_visible_line_index"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_visible_line_index</a></h2>
<p>Returns the number of bytes from the start of the line to the given <em>iter</em>, not counting bytes that are invisible due to tags with the “invisible” flag toggled on.</p><p>Returns: byte index of <em>iter</em> with respect to the start of the line</p><pre class="pod-block-code">method gtk_text_iter_get_visible_line_index ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_char"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_char</a></h2>
<p>The Unicode character at this iterator is returned. (Equivalent to operator* on a C++ iterator.) If the element at this iterator is a non-character element, such as an image embedded in the buffer, the Unicode “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero is returned; zero is not a valid Unicode character. So you can write a loop which ends when <code>gtk_text_iter_get_char()</code> returns 0.</p><p>Returns: a Unicode character, or 0 if <em>iter</em> is not dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_get_char ( --&gt; uint32 )</pre>
<h2 id="[[gtk_]_text_iter_]_get_slice"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_slice</a></h2>
<p>Returns the text in the given range. A “slice” is an array of characters encoded in UTF-8 format, including the Unicode “unknown” character 0xFFFC for iterable non-character elements in the buffer, such as images. Because images are encoded in the slice, byte and character offsets in the returned array will correspond to byte offsets in the text buffer. Note that 0xFFFC can occur in normal text as well, so it is not a reliable indicator that a pixbuf or widget is in the buffer.</p><p>Returns: (transfer full): slice of text from the buffer</p><pre class="pod-block-code">method gtk_text_iter_get_slice ( N-GObject $end --&gt; Str  )</pre><ul>
<li><p>N-GObject $end; iterator at end of a range</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_get_text"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_text</a></h2>
<p>Returns text in the given range. If the range contains non-text elements such as images, the character and byte offsets in the returned string will not correspond to character and byte offsets in the buffer. If you want offsets to correspond, see <code>gtk_text_iter_get_slice()</code>.</p><p>Returns: (transfer full): array of characters from the buffer</p><pre class="pod-block-code">method gtk_text_iter_get_text ( N-GObject $end --&gt; Str  )</pre><ul>
<li><p>N-GObject $end; iterator at end of a range</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_get_visible_slice"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_visible_slice</a></h2>
<p>Like <code>gtk_text_iter_get_slice()</code>, but invisible text is not included. Invisible text is usually invisible because a <strong>Gnome::Gtk3::TextTag</strong> with the “invisible” attribute turned on has been applied to it.</p><p>Returns: (transfer full): slice of text from the buffer</p><pre class="pod-block-code">method gtk_text_iter_get_visible_slice ( N-GObject $end --&gt; Str  )</pre><ul>
<li><p>N-GObject $end; iterator at end of range</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_get_visible_text"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_visible_text</a></h2>
<p>Like <code>gtk_text_iter_get_text()</code>, but invisible text is not included. Invisible text is usually invisible because a <strong>Gnome::Gtk3::TextTag</strong> with the “invisible” attribute turned on has been applied to it.</p><p>Returns: (transfer full): string containing visible text in the range</p><pre class="pod-block-code">method gtk_text_iter_get_visible_text ( N-GObject $end --&gt; Str  )</pre><ul>
<li><p>N-GObject $end; iterator at end of range</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_get_pixbuf"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_pixbuf</a></h2>
<p>If the element at <em>iter</em> is a pixbuf, the pixbuf is returned (with no new reference count added). Otherwise, <code>Any</code> is returned.</p><p>Returns: (transfer none): the pixbuf at <em>iter</em></p><pre class="pod-block-code">method gtk_text_iter_get_pixbuf ( --&gt; N-GObject  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_marks"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_marks</a></h2>
<p>Returns a list of all <strong>Gnome::Gtk3::TextMark</strong> at this location. Because marks are not iterable (they don’t take up any &quot;space&quot; in the buffer, they are just marks in between iterable locations), multiple marks can exist in the same place. The returned list is not in any meaningful order.</p><p>Returns: (element-type <strong>Gnome::Gtk3::TextMark</strong>) (transfer container): list of <strong>Gnome::Gtk3::TextMark</strong></p><pre class="pod-block-code">method gtk_text_iter_get_marks ( --&gt; N-GSList  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_child_anchor"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_child_anchor</a></h2>
<p>If the location at <em>iter</em> contains a child anchor, the anchor is returned (with no new reference count added). Otherwise, <code>Any</code> is returned.</p><p>Returns: (transfer none): the anchor at <em>iter</em></p><pre class="pod-block-code">method gtk_text_iter_get_child_anchor ( --&gt; GtkTextChildAnchor  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_toggled_tags"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_toggled_tags</a></h2>
<p>Returns a list of <strong>Gnome::Gtk3::TextTag</strong> that are toggled on or off at this point. (If <em>toggled_on</em> is <code>1</code>, the list contains tags that are toggled on.) If a tag is toggled on at <em>iter</em>, then some non-empty range of characters following <em>iter</em> has that tag applied to it. If a tag is toggled off, then some non-empty range following <em>iter</em> does not have the tag applied to it.</p><p>Returns: (element-type <strong>Gnome::Gtk3::TextTag</strong>) (transfer container): tags toggled at this point</p><pre class="pod-block-code">method gtk_text_iter_get_toggled_tags ( Int $toggled_on --&gt; N-GSList  )</pre><ul>
<li><p>Int $toggled_on; <code>1</code> to get toggled-on tags</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_starts_tag"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] starts_tag</a></h2>
<p>Returns <code>1</code> if <em>tag</em> is toggled on at exactly this point. If <em>tag</em> is <code>Any</code>, returns <code>1</code> if any tag is toggled on at this point.</p><p>Note that if <code>gtk_text_iter_starts_tag()</code> returns <code>1</code>, it means that <em>iter</em> is at the beginning of the tagged range, and that the character at <em>iter</em> is inside the tagged range. In other words, unlike <code>gtk_text_iter_ends_tag()</code>, if <code>gtk_text_iter_starts_tag()</code> returns <code>1</code>, <code>gtk_text_iter_has_tag()</code> will also return <code>1</code> for the same parameters.</p><p>Returns: whether <em>iter</em> is the start of a range tagged with <em>tag</em> Since: 3.20</p><pre class="pod-block-code">method gtk_text_iter_starts_tag ( N-GObject $tag --&gt; Int  )</pre><ul>
<li><p>N-GObject $tag; (nullable): a <strong>Gnome::Gtk3::TextTag</strong>, or <code>Any</code></p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_ends_tag"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] ends_tag</a></h2>
<p>Returns <code>1</code> if <em>tag</em> is toggled off at exactly this point. If <em>tag</em> is <code>Any</code>, returns <code>1</code> if any tag is toggled off at this point.</p><p>Note that if <code>gtk_text_iter_ends_tag()</code> returns <code>1</code>, it means that <em>iter</em> is at the end of the tagged range, but that the character at <em>iter</em> is outside the tagged range. In other words, unlike <code>gtk_text_iter_starts_tag()</code>, if <code>gtk_text_iter_ends_tag()</code> returns <code>1</code>, <code>gtk_text_iter_has_tag()</code> will return <code>0</code> for the same parameters.</p><p>Returns: whether <em>iter</em> is the end of a range tagged with <em>tag</em></p><pre class="pod-block-code">method gtk_text_iter_ends_tag ( N-GObject $tag --&gt; Int  )</pre><ul>
<li><p>N-GObject $tag; (allow-none): a <strong>Gnome::Gtk3::TextTag</strong>, or <code>Any</code></p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_toggles_tag"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] toggles_tag</a></h2>
<p>This is equivalent to (<code>gtk_text_iter_starts_tag()</code> || <code>gtk_text_iter_ends_tag()</code>), i.e. it tells you whether a range with <em>tag</em> applied to it begins or ends at <em>iter</em>.</p><p>Returns: whether <em>tag</em> is toggled on or off at <em>iter</em></p><pre class="pod-block-code">method gtk_text_iter_toggles_tag ( N-GObject $tag --&gt; Int  )</pre><ul>
<li><p>N-GObject $tag; (allow-none): a <strong>Gnome::Gtk3::TextTag</strong>, or <code>Any</code></p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_has_tag"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] has_tag</a></h2>
<p>Returns <code>1</code> if <em>iter</em> points to a character that is part of a range tagged with <em>tag</em>. See also <code>gtk_text_iter_starts_tag()</code> and <code>gtk_text_iter_ends_tag()</code>.</p><p>Returns: whether <em>iter</em> is tagged with <em>tag</em></p><pre class="pod-block-code">method gtk_text_iter_has_tag ( N-GObject $tag --&gt; Int  )</pre><ul>
<li><p>N-GObject $tag; a <strong>Gnome::Gtk3::TextTag</strong></p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_get_tags"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_tags</a></h2>
<p>Returns a list of tags that apply to <em>iter</em>, in ascending order of priority (highest-priority tags are last). The <strong>Gnome::Gtk3::TextTag</strong> in the list don’t have a reference added, but you have to free the list itself.</p><p>Returns: (element-type <strong>Gnome::Gtk3::TextTag</strong>) (transfer container): list of <strong>Gnome::Gtk3::TextTag</strong></p><pre class="pod-block-code">method gtk_text_iter_get_tags ( --&gt; N-GSList  )</pre>
<h2 id="[gtk_]_text_iter_editable"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[gtk_] text_iter_editable</a></h2>
<p>Returns whether the character at <em>iter</em> is within an editable region of text. Non-editable text is “locked” and can’t be changed by the user via <strong>Gnome::Gtk3::TextView</strong>. This function is simply a convenience wrapper around <code>gtk_text_iter_get_attributes()</code>. If no tags applied to this text affect editability, <em>default_setting</em> will be returned.</p><p>You don’t want to use this function to decide whether text can be inserted at <em>iter</em>, because for insertion you don’t want to know whether the char at <em>iter</em> is inside an editable range, you want to know whether a new character inserted at <em>iter</em> would be inside an editable range. Use <code>gtk_text_iter_can_insert()</code> to handle this case.</p><p>Returns: whether <em>iter</em> is inside an editable range</p><pre class="pod-block-code">method gtk_text_iter_editable ( Int $default_setting --&gt; Int  )</pre><ul>
<li><p>Int $default_setting; <code>1</code> if text is editable by default</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_can_insert"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] can_insert</a></h2>
<p>Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at <em>iter</em> would be editable. If text inserted at <em>iter</em> would be editable then the user should be allowed to insert text at <em>iter</em>. <code>gtk_text_buffer_insert_interactive()</code> uses this function to decide whether insertions are allowed at a given position.</p><p>Returns: whether text inserted at <em>iter</em> would be editable</p><pre class="pod-block-code">method gtk_text_iter_can_insert ( Int $default_editability --&gt; Int  )</pre><ul>
<li><p>Int $default_editability; <code>1</code> if text is editable by default</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_starts_word"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] starts_word</a></h2>
<p>Determines whether <em>iter</em> begins a natural-language word. Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> is at the start of a word</p><pre class="pod-block-code">method gtk_text_iter_starts_word ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_ends_word"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] ends_word</a></h2>
<p>Determines whether <em>iter</em> ends a natural-language word. Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> is at the end of a word</p><pre class="pod-block-code">method gtk_text_iter_ends_word ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_inside_word"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] inside_word</a></h2>
<p>Determines whether the character pointed by <em>iter</em> is part of a natural-language word (as opposed to say inside some whitespace). Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p><p>Note that if <code>gtk_text_iter_starts_word()</code> returns <code>1</code>, then this function returns <code>1</code> too, since <em>iter</em> points to the first character of the word.</p><p>Returns: <code>1</code> if <em>iter</em> is inside a word</p><pre class="pod-block-code">method gtk_text_iter_inside_word ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_starts_sentence"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] starts_sentence</a></h2>
<p>Determines whether <em>iter</em> begins a sentence. Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> is at the start of a sentence.</p><pre class="pod-block-code">method gtk_text_iter_starts_sentence ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_ends_sentence"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] ends_sentence</a></h2>
<p>Determines whether <em>iter</em> ends a sentence. Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> is at the end of a sentence.</p><pre class="pod-block-code">method gtk_text_iter_ends_sentence ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_inside_sentence"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] inside_sentence</a></h2>
<p>Determines whether <em>iter</em> is inside a sentence (as opposed to in between two sentences, e.g. after a period and before the first letter of the next sentence). Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> is inside a sentence.</p><pre class="pod-block-code">method gtk_text_iter_inside_sentence ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_starts_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] starts_line</a></h2>
<p>Returns <code>1</code> if <em>iter</em> begins a paragraph, i.e. if <code>gtk_text_iter_get_line_offset()</code> would return 0. However this function is potentially more efficient than <code>gtk_text_iter_get_line_offset()</code> because it doesn’t have to compute the offset, it just has to see whether it’s 0.</p><p>Returns: whether <em>iter</em> begins a line</p><pre class="pod-block-code">method gtk_text_iter_starts_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_ends_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] ends_line</a></h2>
<p>Returns <code>1</code> if <em>iter</em> points to the start of the paragraph delimiter characters for a line (delimiters will be either a newline, a carriage return, a carriage return followed by a newline, or a Unicode paragraph separator character). Note that an iterator pointing to the \n of a \r\n pair will not be counted as the end of a line, the line ends before the \r. The end iterator is considered to be at the end of a line, even though there are no paragraph delimiter chars there.</p><p>Returns: whether <em>iter</em> is at the end of a line</p><pre class="pod-block-code">method gtk_text_iter_ends_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_is_cursor_position"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] is_cursor_position</a></h2>
<p>See <code>gtk_text_iter_forward_cursor_position()</code> or <strong>PangoLogAttr</strong> or <code>pango_break()</code> for details on what a cursor position is.</p><p>Returns: <code>1</code> if the cursor can be placed at <em>iter</em></p><pre class="pod-block-code">method gtk_text_iter_is_cursor_position ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_chars_in_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_chars_in_line</a></h2>
<p>Returns the number of characters in the line containing <em>iter</em>, including the paragraph delimiters.</p><p>Returns: number of characters in the line</p><pre class="pod-block-code">method gtk_text_iter_get_chars_in_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_bytes_in_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_bytes_in_line</a></h2>
<p>Returns the number of bytes in the line containing <em>iter</em>, including the paragraph delimiters.</p><p>Returns: number of bytes in the line</p><pre class="pod-block-code">method gtk_text_iter_get_bytes_in_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_get_attributes"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_attributes</a></h2>
<p>Computes the effect of any tags applied to this spot in the text. The <em>values</em> parameter should be initialized to the default settings you wish to use if no tags are in effect. You’d typically obtain the defaults from <code>gtk_text_view_get_default_attributes()</code>.</p><p><code>gtk_text_iter_get_attributes()</code> will modify <em>values</em>, applying the effects of any tags present at <em>iter</em>. If any tags affected <em>values</em>, the function returns <code>1</code>.</p><p>Returns: <code>1</code> if <em>values</em> was modified</p><pre class="pod-block-code">method gtk_text_iter_get_attributes ( N-GObject $values --&gt; Int  )</pre><ul>
<li><p>N-GObject $values; (out): a <strong>Gnome::Gtk3::TextAttributes</strong> to be filled in</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_get_language"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] get_language</a></h2>
<p>A convenience wrapper around <code>gtk_text_iter_get_attributes()</code>, which returns the language in effect at <em>iter</em>. If no tags affecting language apply to <em>iter</em>, the return value is identical to that of <code>gtk_get_default_language()</code>.</p><p>Returns: (transfer full): language in effect at <em>iter</em></p><pre class="pod-block-code">method gtk_text_iter_get_language ( --&gt; PangoLanguage  )</pre>
<h2 id="[[gtk_]_text_iter_]_is_end"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] is_end</a></h2>
<p>Returns <code>1</code> if <em>iter</em> is the end iterator, i.e. one past the last dereferenceable iterator in the buffer. <code>gtk_text_iter_is_end()</code> is the most efficient way to check whether an iterator is the end iterator.</p><p>Returns: whether <em>iter</em> is the end iterator</p><pre class="pod-block-code">method gtk_text_iter_is_end ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_is_start"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] is_start</a></h2>
<p>Returns <code>1</code> if <em>iter</em> is the first iterator in the buffer, that is if <em>iter</em> has a character offset of 0.</p><p>Returns: whether <em>iter</em> is the first in the buffer</p><pre class="pod-block-code">method gtk_text_iter_is_start ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_char"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_char</a></h2>
<p>Moves <em>iter</em> forward by one character offset. Note that images embedded in the buffer occupy 1 character slot, so <code>gtk_text_iter_forward_char()</code> may actually move onto an image instead of a character, if you have images in your buffer. If <em>iter</em> is the end iterator or one character before it, <em>iter</em> will now point at the end iterator, and <code>gtk_text_iter_forward_char()</code> returns <code>0</code> for convenience when writing loops.</p><p>Returns: whether <em>iter</em> moved and is dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_forward_char ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_backward_char"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_char</a></h2>
<p>Moves backward by one character offset. Returns <code>1</code> if movement was possible; if <em>iter</em> was the first in the buffer (character offset 0), <code>gtk_text_iter_backward_char()</code> returns <code>0</code> for convenience when writing loops.</p><p>Returns: whether movement was possible</p><pre class="pod-block-code">method gtk_text_iter_backward_char ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_chars"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_chars</a></h2>
<p>Moves <em>count</em> characters if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the new position of <em>iter</em> is different from its original position, and dereferenceable (the last iterator in the buffer is not dereferenceable). If <em>count</em> is 0, the function does nothing and returns <code>0</code>.</p><p>Returns: whether <em>iter</em> moved and is dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_forward_chars ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of characters to move, may be negative</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_chars"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_chars</a></h2>
<p>Moves <em>count</em> characters backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>0</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>0</code>.</p><p>Returns: whether <em>iter</em> moved and is dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_backward_chars ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of characters to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_line</a></h2>
<p>Moves <em>iter</em> to the start of the next line. If the iter is already on the last line of the buffer, moves the iter to the end of the current line. If after the operation, the iter is at the end of the buffer and not dereferencable, returns <code>0</code>. Otherwise, returns <code>1</code>.</p><p>Returns: whether <em>iter</em> can be dereferenced</p><pre class="pod-block-code">method gtk_text_iter_forward_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_backward_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_line</a></h2>
<p>Moves <em>iter</em> to the start of the previous line. Returns <code>1</code> if <em>iter</em> could be moved; i.e. if <em>iter</em> was at character offset 0, this function returns <code>0</code>. Therefore if <em>iter</em> was already on line 0, but not at the start of the line, <em>iter</em> is snapped to the start of the line and the function returns <code>1</code>. (Note that this implies that in a loop calling this function, the line number may not change on every iteration, if your first iteration is on line 0.)</p><p>Returns: whether <em>iter</em> moved</p><pre class="pod-block-code">method gtk_text_iter_backward_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_lines"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_lines</a></h2>
<p>Moves <em>count</em> lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>0</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>0</code>. If <em>count</em> is negative, moves backward by 0 - <em>count</em> lines.</p><p>Returns: whether <em>iter</em> moved and is dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_forward_lines ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of lines to move forward</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_lines"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_lines</a></h2>
<p>Moves <em>count</em> lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>0</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>0</code>. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines.</p><p>Returns: whether <em>iter</em> moved and is dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_backward_lines ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of lines to move backward</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_word_end"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_word_end</a></h2>
<p>Moves forward to the next word end. (If <em>iter</em> is currently on a word end, moves forward to the next one after that.) Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_forward_word_end ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_backward_word_start"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_word_start</a></h2>
<p>Moves backward to the previous word start. (If <em>iter</em> is currently on a word start, moves backward to the next one after that.) Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_backward_word_start ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_word_ends"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_word_ends</a></h2>
<p>Calls <code>gtk_text_iter_forward_word_end()</code> up to <em>count</em> times.</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_forward_word_ends ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of times to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_word_starts"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_word_starts</a></h2>
<p>Calls <code>gtk_text_iter_backward_word_start()</code> up to <em>count</em> times.</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_backward_word_starts ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of times to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_visible_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_visible_line</a></h2>
<p>Moves <em>iter</em> to the start of the next visible line. Returns <code>1</code> if there was a next line to move to, and <code>0</code> if <em>iter</em> was simply moved to the end of the buffer and is now not dereferenceable, or if <em>iter</em> was already at the end of the buffer.</p><p>Returns: whether <em>iter</em> can be dereferenced</p><p>Since: 2.8</p><pre class="pod-block-code">method gtk_text_iter_forward_visible_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_backward_visible_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_visible_line</a></h2>
<p>Moves <em>iter</em> to the start of the previous visible line. Returns <code>1</code> if <em>iter</em> could be moved; i.e. if <em>iter</em> was at character offset 0, this function returns <code>0</code>. Therefore if <em>iter</em> was already on line 0, but not at the start of the line, <em>iter</em> is snapped to the start of the line and the function returns <code>1</code>. (Note that this implies that in a loop calling this function, the line number may not change on every iteration, if your first iteration is on line 0.)</p><p>Returns: whether <em>iter</em> moved</p><p>Since: 2.8</p><pre class="pod-block-code">method gtk_text_iter_backward_visible_line ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_visible_lines"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_visible_lines</a></h2>
<p>Moves <em>count</em> visible lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>0</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>0</code>. If <em>count</em> is negative, moves backward by 0 - <em>count</em> lines.</p><p>Returns: whether <em>iter</em> moved and is dereferenceable</p><p>Since: 2.8</p><pre class="pod-block-code">method gtk_text_iter_forward_visible_lines ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of lines to move forward</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_visible_lines"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_visible_lines</a></h2>
<p>Moves <em>count</em> visible lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn’t move, or moved onto the end iterator, then <code>0</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>0</code>. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines.</p><p>Returns: whether <em>iter</em> moved and is dereferenceable</p><p>Since: 2.8</p><pre class="pod-block-code">method gtk_text_iter_backward_visible_lines ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of lines to move backward</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_visible_word_end"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_visible_word_end</a></h2>
<p>Moves forward to the next visible word end. (If <em>iter</em> is currently on a word end, moves forward to the next one after that.) Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><p>Since: 2.4</p><pre class="pod-block-code">method gtk_text_iter_forward_visible_word_end ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_backward_visible_word_start"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_visible_word_start</a></h2>
<p>Moves backward to the previous visible word start. (If <em>iter</em> is currently on a word start, moves backward to the next one after that.) Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><p>Since: 2.4</p><pre class="pod-block-code">method gtk_text_iter_backward_visible_word_start ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_visible_word_ends"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_visible_word_ends</a></h2>
<p>Calls <code>gtk_text_iter_forward_visible_word_end()</code> up to <em>count</em> times.</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><p>Since: 2.4</p><pre class="pod-block-code">method gtk_text_iter_forward_visible_word_ends ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of times to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_visible_word_starts"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_visible_word_starts</a></h2>
<p>Calls <code>gtk_text_iter_backward_visible_word_start()</code> up to <em>count</em> times.</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><p>Since: 2.4</p><pre class="pod-block-code">method gtk_text_iter_backward_visible_word_starts ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of times to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_sentence_end"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_sentence_end</a></h2>
<p>Moves forward to the next sentence end. (If <em>iter</em> is at the end of a sentence, moves to the next end of sentence.) Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_forward_sentence_end ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_backward_sentence_start"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_sentence_start</a></h2>
<p>Moves backward to the previous sentence start; if <em>iter</em> is already at the start of a sentence, moves backward to the next one. Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_backward_sentence_start ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_sentence_ends"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_sentence_ends</a></h2>
<p>Calls <code>gtk_text_iter_forward_sentence_end()</code> <em>count</em> times (or until <code>gtk_text_iter_forward_sentence_end()</code> returns <code>0</code>). If <em>count</em> is negative, moves backward instead of forward.</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_forward_sentence_ends ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of sentences to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_sentence_starts"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_sentence_starts</a></h2>
<p>Calls <code>gtk_text_iter_backward_sentence_start()</code> up to <em>count</em> times, or until it returns <code>0</code>. If <em>count</em> is negative, moves forward instead of backward.</p><p>Returns: <code>1</code> if <em>iter</em> moved and is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_backward_sentence_starts ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of sentences to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_cursor_position"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_cursor_position</a></h2>
<p>Moves <em>iter</em> forward by a single cursor position. Cursor positions are (unsurprisingly) positions where the cursor can appear. Perhaps surprisingly, there may not be a cursor position between all characters. The most common example for European languages would be a carriage return/newline sequence. For some Unicode characters, the equivalent of say the letter “a” with an accent mark will be represented as two characters, first the letter then a &quot;combining mark&quot; that causes the accent to be rendered; so the cursor can’t go between those two characters. See also the <strong>PangoLogAttr</strong>-struct and <code>pango_break()</code> function.</p><p>Returns: <code>1</code> if we moved and the new position is dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_forward_cursor_position ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_backward_cursor_position"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_cursor_position</a></h2>
<p>Like <code>gtk_text_iter_forward_cursor_position()</code>, but moves backward.</p><p>Returns: <code>1</code> if we moved</p><pre class="pod-block-code">method gtk_text_iter_backward_cursor_position ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_cursor_positions"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_cursor_positions</a></h2>
<p>Moves up to <em>count</em> cursor positions. See <code>gtk_text_iter_forward_cursor_position()</code> for details.</p><p>Returns: <code>1</code> if we moved and the new position is dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_forward_cursor_positions ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of positions to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_cursor_positions"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_cursor_positions</a></h2>
<p>Moves up to <em>count</em> cursor positions. See <code>gtk_text_iter_forward_cursor_position()</code> for details.</p><p>Returns: <code>1</code> if we moved and the new position is dereferenceable</p><pre class="pod-block-code">method gtk_text_iter_backward_cursor_positions ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of positions to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_visible_cursor_position"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_visible_cursor_position</a></h2>
<p>Moves <em>iter</em> forward to the next visible cursor position. See <code>gtk_text_iter_forward_cursor_position()</code> for details.</p><p>Returns: <code>1</code> if we moved and the new position is dereferenceable</p><p>Since: 2.4</p><pre class="pod-block-code">method gtk_text_iter_forward_visible_cursor_position ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_backward_visible_cursor_position"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_visible_cursor_position</a></h2>
<p>Moves <em>iter</em> forward to the previous visible cursor position. See <code>gtk_text_iter_backward_cursor_position()</code> for details.</p><p>Returns: <code>1</code> if we moved and the new position is dereferenceable</p><p>Since: 2.4</p><pre class="pod-block-code">method gtk_text_iter_backward_visible_cursor_position ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_visible_cursor_positions"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_visible_cursor_positions</a></h2>
<p>Moves up to <em>count</em> visible cursor positions. See <code>gtk_text_iter_forward_cursor_position()</code> for details.</p><p>Returns: <code>1</code> if we moved and the new position is dereferenceable</p><p>Since: 2.4</p><pre class="pod-block-code">method gtk_text_iter_forward_visible_cursor_positions ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of positions to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_visible_cursor_positions"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_visible_cursor_positions</a></h2>
<p>Moves up to <em>count</em> visible cursor positions. See <code>gtk_text_iter_backward_cursor_position()</code> for details.</p><p>Returns: <code>1</code> if we moved and the new position is dereferenceable</p><p>Since: 2.4</p><pre class="pod-block-code">method gtk_text_iter_backward_visible_cursor_positions ( Int $count --&gt; Int  )</pre><ul>
<li><p>Int $count; number of positions to move</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_set_offset"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] set_offset</a></h2>
<p>Sets <em>iter</em> to point to <em>char_offset</em>. <em>char_offset</em> counts from the start of the entire text buffer, starting with 0.</p><pre class="pod-block-code">method gtk_text_iter_set_offset ( Int $char_offset )</pre><ul>
<li><p>Int $char_offset; a character number</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_set_line"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] set_line</a></h2>
<p>Moves iterator <em>iter</em> to the start of the line <em>line_number</em>. If <em>line_number</em> is negative or larger than the number of lines in the buffer, moves <em>iter</em> to the start of the last line in the buffer.</p><pre class="pod-block-code">method gtk_text_iter_set_line ( Int $line_number )</pre><ul>
<li><p>Int $line_number; line number (counted from 0)</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_set_line_offset"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] set_line_offset</a></h2>
<p>Moves <em>iter</em> within a line, to a new character (not byte) offset. The given character offset must be less than or equal to the number of characters in the line; if equal, <em>iter</em> moves to the start of the next line. See <code>gtk_text_iter_set_line_index()</code> if you have a byte index rather than a character offset.</p><pre class="pod-block-code">method gtk_text_iter_set_line_offset ( Int $char_on_line )</pre><ul>
<li><p>Int $char_on_line; a character offset relative to the start of <em>iter</em>’s current line</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_set_line_index"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] set_line_index</a></h2>
<p>Same as <code>gtk_text_iter_set_line_offset()</code>, but works with a byte index. The given byte index must be at the start of a character, it can’t be in the middle of a UTF-8 encoded character.</p><pre class="pod-block-code">method gtk_text_iter_set_line_index ( Int $byte_on_line )</pre><ul>
<li><p>Int $byte_on_line; a byte index relative to the start of <em>iter</em>’s current line</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_to_end"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_to_end</a></h2>
<p>Moves <em>iter</em> forward to the “end iterator,” which points one past the last valid character in the buffer. <code>gtk_text_iter_get_char()</code> called on the end iterator returns 0, which is convenient for writing loops.</p><pre class="pod-block-code">method gtk_text_iter_forward_to_end ( )</pre>
<h2 id="[[gtk_]_text_iter_]_forward_to_line_end"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_to_line_end</a></h2>
<p>Moves the iterator to point to the paragraph delimiter characters, which will be either a newline, a carriage return, a carriage return/newline in sequence, or the Unicode paragraph separator character. If the iterator is already at the paragraph delimiter characters, moves to the paragraph delimiter characters for the next line. If <em>iter</em> is on the last line in the buffer, which does not end in paragraph delimiters, moves to the end iterator (end of the last line), and returns <code>0</code>.</p><p>Returns: <code>1</code> if we moved and the new location is not the end iterator</p><pre class="pod-block-code">method gtk_text_iter_forward_to_line_end ( --&gt; Int  )</pre>
<h2 id="[[gtk_]_text_iter_]_set_visible_line_offset"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] set_visible_line_offset</a></h2>
<p>Like <code>gtk_text_iter_set_line_offset()</code>, but the offset is in visible characters, i.e. text with a tag making it invisible is not counted in the offset.</p><pre class="pod-block-code">method gtk_text_iter_set_visible_line_offset ( Int $char_on_line )</pre><ul>
<li><p>Int $char_on_line; a character offset</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_set_visible_line_index"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] set_visible_line_index</a></h2>
<p>Like <code>gtk_text_iter_set_line_index()</code>, but the index is in visible bytes, i.e. text with a tag making it invisible is not counted in the index.</p><pre class="pod-block-code">method gtk_text_iter_set_visible_line_index ( Int $byte_on_line )</pre><ul>
<li><p>Int $byte_on_line; a byte index</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_to_tag_toggle"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_to_tag_toggle</a></h2>
<p>Moves forward to the next toggle (on or off) of the <strong>Gnome::Gtk3::TextTag</strong> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>Any</code>. If no matching tag toggles are found, returns <code>0</code>, otherwise <code>1</code>. Does not return toggles located at <em>iter</em>, only toggles after <em>iter</em>. Sets <em>iter</em> to the location of the toggle, or to the end of the buffer if no toggle is found.</p><p>Returns: whether we found a tag toggle after <em>iter</em></p><pre class="pod-block-code">method gtk_text_iter_forward_to_tag_toggle ( N-GObject $tag --&gt; Int  )</pre><ul>
<li><p>N-GObject $tag; (allow-none): a <strong>Gnome::Gtk3::TextTag</strong>, or <code>Any</code></p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_to_tag_toggle"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_to_tag_toggle</a></h2>
<p>Moves backward to the next toggle (on or off) of the <strong>Gnome::Gtk3::TextTag</strong> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>Any</code>. If no matching tag toggles are found, returns <code>0</code>, otherwise <code>1</code>. Does not return toggles located at <em>iter</em>, only toggles before <em>iter</em>. Sets <em>iter</em> to the location of the toggle, or the start of the buffer if no toggle is found.</p><p>Returns: whether we found a tag toggle before <em>iter</em></p><pre class="pod-block-code">method gtk_text_iter_backward_to_tag_toggle ( N-GObject $tag --&gt; Int  )</pre><ul>
<li><p>N-GObject $tag; (allow-none): a <strong>Gnome::Gtk3::TextTag</strong>, or <code>Any</code></p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_find_char"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_find_char</a></h2>
<p>Advances <em>iter</em>, calling <em>pred</em> on each character. If <em>pred</em> returns <code>1</code>, returns <code>1</code> and stops scanning. If <em>pred</em> never returns <code>1</code>, <em>iter</em> is set to <em>limit</em> if <em>limit</em> is non-<code>Any</code>, otherwise to the end iterator.</p><p>Returns: whether a match was found</p><pre class="pod-block-code">method gtk_text_iter_forward_find_char ( GtkTextCharPredicate $pred, Pointer $user_data, N-GObject $limit --&gt; Int  )</pre><ul>
<li><p>GtkTextCharPredicate $pred; (scope call): a function to be called on each character</p></li>
<li><p>Pointer $user_data; user data for <em>pred</em></p></li>
<li><p>N-GObject $limit; (allow-none): search limit, or <code>Any</code> for none</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_find_char"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_find_char</a></h2>
<p>Same as <code>gtk_text_iter_forward_find_char()</code>, but goes backward from <em>iter</em>.</p><p>Returns: whether a match was found</p><pre class="pod-block-code">method gtk_text_iter_backward_find_char ( GtkTextCharPredicate $pred, Pointer $user_data, N-GObject $limit --&gt; Int  )</pre><ul>
<li><p>GtkTextCharPredicate $pred; (scope call): function to be called on each character</p></li>
<li><p>Pointer $user_data; user data for <em>pred</em></p></li>
<li><p>N-GObject $limit; (allow-none): search limit, or <code>Any</code> for none</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_forward_search"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] forward_search</a></h2>
<p>Searches forward for <em>str</em>. Any match is returned by setting <em>match_start</em> to the first character of the match and <em>match_end</em> to the first character after the match. The search will not continue past <em>limit</em>. Note that a search is a linear or O(n) operation, so you may wish to use <em>limit</em> to avoid locking up your UI on large buffers.</p><p><em>match_start</em> will never be set to a <strong>Gnome::Gtk3::TextIter</strong> located before <em>iter</em>, even if there is a possible <em>match_end</em> after or at <em>iter</em>.</p><p>Returns: whether a match was found</p><pre class="pod-block-code">method gtk_text_iter_forward_search ( Str $str, GtkTextSearchFlags $flags, N-GObject $match_start, N-GObject $match_end, N-GObject $limit --&gt; Int  )</pre><ul>
<li><p>Str $str; a search string</p></li>
<li><p>GtkTextSearchFlags $flags; flags affecting how the search is done</p></li>
<li><p>N-GObject $match_start; (out caller-allocates) (allow-none): return location for start of match, or <code>Any</code></p></li>
<li><p>N-GObject $match_end; (out caller-allocates) (allow-none): return location for end of match, or <code>Any</code></p></li>
<li><p>N-GObject $limit; (allow-none): location of last possible <em>match_end</em>, or <code>Any</code> for the end of the buffer</p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_backward_search"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] backward_search</a></h2>
<p>Same as <code>gtk_text_iter_forward_search()</code>, but moves backward.</p><p><em>match_end</em> will never be set to a <strong>Gnome::Gtk3::TextIter</strong> located after <em>iter</em>, even if there is a possible <em>match_start</em> before or at <em>iter</em>.</p><p>Returns: whether a match was found</p><pre class="pod-block-code">method gtk_text_iter_backward_search ( Str $str, GtkTextSearchFlags $flags, N-GObject $match_start, N-GObject $match_end, N-GObject $limit --&gt; Int  )</pre><ul>
<li><p>Str $str; search string</p></li>
<li><p>GtkTextSearchFlags $flags; bitmask of flags affecting the search</p></li>
<li><p>N-GObject $match_start; (out caller-allocates) (allow-none): return location for start of match, or <code>Any</code></p></li>
<li><p>N-GObject $match_end; (out caller-allocates) (allow-none): return location for end of match, or <code>Any</code></p></li>
<li><p>N-GObject $limit; (allow-none): location of last possible <em>match_start</em>, or <code>Any</code> for start of buffer</p></li>
</ul>

<h2 id="[gtk_]_text_iter_equal"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[gtk_] text_iter_equal</a></h2>
<p>Tests whether two iterators are equal, using the fastest possible mechanism. This function is very fast; you can expect it to perform better than e.g. getting the character offset for each iterator and comparing the offsets yourself. Also, it’s a bit faster than <code>gtk_text_iter_compare()</code>.</p><p>Returns: <code>1</code> if the iterators point to the same place in the buffer</p><pre class="pod-block-code">method gtk_text_iter_equal ( N-GTextIter $rhs --&gt; Int  )</pre><ul>
<li><p>N-GTextIter $rhs; another <strong>Gnome::Gtk3::TextIter</strong></p></li>
</ul>

<h2 id="[gtk_]_text_iter_compare"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[gtk_] text_iter_compare</a></h2>
<p>A <code>qsort()</code>-style function that returns negative if <em>lhs</em> is less than <em>rhs</em>, positive if <em>lhs</em> is greater than <em>rhs</em>, and 0 if they’re equal. Ordering is in character offset order, i.e. the first character in the buffer is less than the second character in the buffer.</p><p>Returns: -1 if <em>lhs</em> is less than <em>rhs</em>, 1 if <em>lhs</em> is greater, 0 if they are equal</p><pre class="pod-block-code">method gtk_text_iter_compare ( N-GTextIter $rhs --&gt; Int  )</pre><ul>
<li><p>N-GTextIter $rhs; another <strong>Gnome::Gtk3::TextIter</strong></p></li>
</ul>

<h2 id="[[gtk_]_text_iter_]_in_range"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[[gtk_] text_iter_] in_range</a></h2>
<p>Checks whether <em>iter</em> falls in the range [<em>start</em>, <em>end</em>). <em>start</em> and <em>end</em> must be in ascending order.</p><p>Returns: <code>1</code> if <em>iter</em> is in the range</p><pre class="pod-block-code">method gtk_text_iter_in_range ( N-GTextIter $start, N-GTextIter $end --&gt; Int  )</pre><ul>
<li><p>N-GTextIter $start; start of range</p></li>
<li><p>N-GTextIter $end; end of range</p></li>
</ul>

<h2 id="[gtk_]_text_iter_order"><a href="#Gnome::Gtk3::TextIter" class="u" title="go to top of document">[gtk_] text_iter_order</a></h2>
<p>Swaps the value of <em>first</em> and <em>second</em> if <em>second</em> comes before <em>first</em> in the buffer. That is, ensures that <em>first</em> and <em>second</em> are in sequence. Most text buffer functions that take a range call this automatically on your behalf, so there’s no real reason to call it yourself in those cases. There are some exceptions, such as <code>gtk_text_iter_in_range()</code>, that expect a pre-sorted range.</p><pre class="pod-block-code">method gtk_text_iter_order ( N-GTextIter $second )</pre><ul>
<li><p>N-GTextIter $second; another <strong>Gnome::Gtk3::TextIter</strong></p></li>
</ul>
</section>		</div>
</div><footer><div>Rendered from <span class="path">/home/marcel/Languages/Raku/Projects/gnome-api1/gnome-gtk3/lib/Gnome/Gtk3/TextIter.rakumod</span></div><div>at <span class="time">2025-07-19T14:13:23Z</span></div></footer>
	</body>
</html>
