---
---
<!doctype html>
<html lang="en">
<head>
<title>Gnome::Gio::Task</title>
<meta charset="UTF-8" />

<link href="asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />

</head>
	<body class="pod">
<header><img src="asset_files/images/gtk-raku.png" id="Camelia_bug"><h2 class="title" id="Gnome::Gio::Task">Gnome::Gio::Task</h2></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#Description">Description</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Asynchronous_operations">Asynchronous operations</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Chained_asynchronous_operations">Chained asynchronous operations</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Asynchronous_operations_from_synchronous_ones">Asynchronous operations from synchronous ones</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Adding_cancellability_to_uncancellable_tasks">Adding cancellability to uncancellable tasks</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Porting_from_Gnome::Gio::Task">Porting from Gnome::Gio::Task</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Thread-safety_considerations">Thread-safety considerations</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Uml_Diagram">Uml Diagram</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#"></a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Class_initialization">Class initialization</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#new">new</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#:native-object">:native-object</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#new-task">new-task</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Methods">Methods</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#attach-source">attach-source</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-cancellable">get-cancellable</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-check-cancellable">get-check-cancellable</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-completed">get-completed</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-context">get-context</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-name">get-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-priority">get-priority</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-return-on-cancel">get-return-on-cancel</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-source-object">get-source-object</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-source-tag">get-source-tag</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#get-task-data">get-task-data</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#had-error">had-error</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#propagate-boolean">propagate-boolean</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#propagate-int">propagate-int</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#propagate-pointer">propagate-pointer</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#propagate-value">propagate-value</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-boolean">return-boolean</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-error">return-error</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-error-if-cancelled">return-error-if-cancelled</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-int">return-int</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-new-error_This_function_is_not_yet_available">return-new-error This function is not yet available</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-new-error-literal">return-new-error-literal</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-pointer">return-pointer</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-prefixed-error_This_function_is_not_yet_available">return-prefixed-error This function is not yet available</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#return-value">return-value</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#run-in-thread">run-in-thread</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#run-in-thread-sync">run-in-thread-sync</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-check-cancellable">set-check-cancellable</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-name">set-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-priority">set-priority</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-return-on-cancel">set-return-on-cancel</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-source-tag">set-source-tag</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-static-name">set-static-name</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#set-task-data">set-task-data</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#Functions">Functions</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#is-valid">is-valid</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#report-error">report-error</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#report-new-error_This_function_is_not_yet_available">report-new-error This function is not yet available</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top">
<h1 id="Description"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Description</a></h1>
<p>A <strong>Gnome::Gio::Task</strong> represents and manages a cancellable ‘task’.</p>
<h3 id="Asynchronous_operations"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Asynchronous operations</a></h3>
<p>The most common usage of <strong>Gnome::Gio::Task</strong> is as a <strong>Gnome::Gio::Task</strong>, to manage data during an asynchronous operation. You call <code>.newtask()</code> in the ‘start’ method, followed by <code>.set-task-data()</code> and the like if you need to keep some additional data associated with the task, and then pass the task object around through your asynchronous operation. Eventually, you will call a method such as <code>.return-pointer()</code> or <code>.return-error()</code>, which will save the value you give it and then invoke the task’s callback function in the thread-default main context (see <code>.push-thread-default()</code> in class <code>Gnome::Gio::Task</code>) where it was created (waiting until the next iteration of the main loop first, if necessary). The caller will pass the <strong>Gnome::Gio::Task</strong> back to the operation’s finish function (as a <strong>Gnome::Gio::Task</strong>), and you can use <code>.propagate-pointer()</code> or the like to extract the return value.</p><p>Using <strong>Gnome::Gio::Task</strong> requires the thread-default <strong>MainContext</strong> from when the <strong>Gnome::Gio::Task</strong> was constructed to be running at least until the task has completed and its data has been freed.</p><p>If a <strong>Gnome::Gio::Task</strong> has been constructed and its callback set, it is an error to not call <strong>g_task_return_</strong>*()` on it. GLib will warn at runtime if this happens (since 2.76).</p><p>Here is an example for using <strong>Gnome::Gio::Task</strong> as a <strong>Gnome::Gio::Task</strong>:</p>
<h3 id="Chained_asynchronous_operations"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Chained asynchronous operations</a></h3>
<p><strong>Gnome::Gio::Task</strong> also tries to simplify asynchronous operations that internally chain together several smaller asynchronous operations. <code>.get-cancellable()</code>, <code>.get-context()</code>, and <code>.get-priority()</code> allow you to get back the task’s <strong>Gnome::Gio::Task</strong>, <strong>MainContext</strong> , and [I/O priority](iface.AsyncResult.html#io-priority) when starting a new subtask, so you don’t have to keep track of them yourself. <code>.attach-source()</code> simplifies the case of waiting for a source to fire (automatically using the correct <strong>MainContext</strong> and priority).</p><p>Here is an example for chained asynchronous operations:</p>
<h3 id="Asynchronous_operations_from_synchronous_ones"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Asynchronous operations from synchronous ones</a></h3>
<p>You can use <code>.run-in-thread()</code> to turn a synchronous operation into an asynchronous one, by running it in a thread. When it completes, the result will be dispatched to the thread-default main context (see <code>.push-thread-default()</code> in class <code>Gnome::Gio::Task</code>) where the <strong>Gnome::Gio::Task</strong> was created.</p><p>Running a task in a thread:</p>
<h3 id="Adding_cancellability_to_uncancellable_tasks"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Adding cancellability to uncancellable tasks</a></h3>
<p>Finally, <code>.run-in-thread()</code> and <code>.run-in-thread-sync()</code> can be used to turn an uncancellable operation into a cancellable one. If you call <code>.set-return-on-cancel()</code>, passing <code>True</code>, then if the task’s <strong>Gnome::Gio::Task</strong> is cancelled, it will return control back to the caller immediately, while allowing the task thread to continue running in the background (and simply discarding its result when it finally does finish). Provided that the task thread is careful about how it uses locks and other externally-visible resources, this allows you to make ‘GLib-friendly’ asynchronous and cancellable synchronous variants of blocking APIs.</p><p>Cancelling a task:</p>
<h3 id="Porting_from_Gnome::Gio::Task"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Porting from <strong>Gnome::Gio::Task</strong></a></h3>
<p><strong>Gnome::Gio::Task</strong>’s API attempts to be simpler than <strong>Gnome::Gio::Task</strong>’s in several ways:</p><ul>
<li><p>You can save task-specific data with <code>.set-task-data()</code>, and retrieve it later with <code>.get-task-data()</code>. This replaces the abuse of <code>.set-op-res-gpointer()</code> in class <code>Gnome::Gio::SimpleAsyncResult</code> for the same purpose with <strong>Gnome::Gio::Task</strong>.</p></li>
<li><p>In addition to the task data, <strong>Gnome::Gio::Task</strong> also keeps track of the [priority](iface.AsyncResult.html#io-priority), <strong>Gnome::Gio::Task</strong>, and <strong>MainContext</strong> associated with the task, so tasks that consist of a chain of simpler asynchronous operations will have easy access to those values when starting each sub-task.</p></li>
<li><p><code>.return-error-if-cancelled()</code> provides simplified handling for cancellation. In addition, cancellation overrides any other <strong>Gnome::Gio::Task</strong> return value by default, like <strong>Gnome::Gio::Task</strong> does when <code>.set-check-cancellable()</code> in class <code>Gnome::Gio::SimpleAsyncResult</code> is called. (You can use <code>.set-check-cancellable()</code> to turn off that behavior.) On the other hand, <code>.run-in-thread()</code> guarantees that it will always run your <strong>task_func</strong>, even if the task’s <strong>Gnome::Gio::Task</strong> is already cancelled before the task gets a chance to run; you can start your <strong>task_func</strong> with a <code>.return-error-if-cancelled()</code> check if you need the old behavior.</p></li>
<li><p>The ‘return’ methods (eg, <code>.return-pointer()</code>) automatically cause the task to be ‘completed’ as well, and there is no need to worry about the ‘complete’ vs ‘complete in idle’ distinction. (<strong>Gnome::Gio::Task</strong> automatically figures out whether the task’s callback can be invoked directly, or if it needs to be sent to another <strong>MainContext</strong> , or delayed until the next iteration of the current <strong>MainContext</strong> .)</p></li>
<li><p>The ‘finish’ functions for <strong>Gnome::Gio::Task</strong> based operations are generally much simpler than <strong>Gnome::Gio::Task</strong> ones, normally consisting of only a single call to <code>.propagate-pointer()</code> or the like. Since <code>.propagate-pointer()</code> ‘steals’ the return value from the <strong>Gnome::Gio::Task</strong>, it is not necessary to juggle pointers around to prevent it from being freed twice.</p></li>
<li><p>With <strong>Gnome::Gio::Task</strong>, it was common to call <code>.propagate-error()</code> in class <code>Gnome::Gio::SimpleAsyncResult</code> from the <strong>_finish</strong>()` wrapper function, and have virtual method implementations only deal with successful returns. This behavior is deprecated, because it makes it difficult for a subclass to chain to a parent class’s async methods. Instead, the wrapper function should just be a simple wrapper, and the virtual method should call an appropriate <strong>g_task_propagate_</strong> function. Note that wrapper methods can now use <code>.legacy-propagate-error()</code> in class <code>Gnome::Gio::R-AsyncResult</code> to do old-style <strong>Gnome::Gio::Task</strong> error-returning behavior, and <code>.is-tagged()</code> in class <code>Gnome::Gio::R-AsyncResult</code> to check if a result is tagged as having come from the <strong>_async</strong>()` wrapper function (for ‘short-circuit’ results, such as when passing <strong>0</strong> to <code>.read-async()</code> in class <code>Gnome::Gio::InputStream</code>).</p></li>
</ul>

<h3 id="Thread-safety_considerations"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Thread-safety considerations</a></h3>
<p>Due to some infelicities in the API design, there is a thread-safety concern that users of <strong>Gnome::Gio::Task</strong> have to be aware of:</p><p>If the <strong>Gnome::Glib::T-lib</strong> thread drops its last reference to the source object or the task data before the task is finalized, then the finalizers of these objects may be called on the worker thread.</p><p>This is a problem if the finalizers use non-threadsafe API, and can lead to hard-to-debug crashes. Possible workarounds include:</p><ul>
<li><p>Clear task data in a signal handler for <strong>notify</strong>::completed`</p></li>
<li><p>Keep iterating a main context in the main thread and defer dropping the reference to the source object to that main context when the task is finalized</p></li>
</ul>

<h2 id="Uml_Diagram"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Uml Diagram</a></h2>
<div class="image-container inline"><img src="asset_files/images/plantuml/Task.png" width="70%" height="auto" alt="No caption"></div>
</section>
<section name="pod">
<h1 id="Class_initialization"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Class initialization</a></h1>

<h2 id="new"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">new</a></h2>

<h3 id=":native-object"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">:native-object</a></h3>
<p>Create an object using a native object from an object of the same type found elsewhere. See also <strong>Gnome::N::TopLevelSupportClass</strong>.</p><pre class="pod-block-code">multi method new ( N-Object() :$native-object! )</pre></section>
<section name="pod">
<h2 id="new-task"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">new-task</a></h2>
<p>Creates a <strong>Gnome::Gio::Task</strong> acting on <code>$source-object</code>, which will eventually be used to invoke <code>$callback</code> in the current thread-default main context.</p><p>Call this in the &quot;start&quot; method of your asynchronous method, and pass the <strong>Gnome::Gio::Task</strong> around throughout the asynchronous operation. You can use <code>.set-task-data()</code> to attach task-specific data to the object, which you can retrieve later via <code>.get-task-data()</code>.</p><p>By default, if <code>$cancellable</code> is cancelled, then the return value of the task will always be <code>G_IO_ERROR_CANCELLED</code>, even if the task had already completed before the cancellation. This allows for simplified handling in cases where cancellation may imply that other objects that the task depends on have been destroyed. If you do not want this behavior, you can use <code>.set-check-cancellable()</code> to change it.</p><pre class="pod-block-code">method new-task ( gpointer $source-object, N-Object() $cancellable, GAsyncReadyCallback &amp;callback, gpointer $callback-data --&gt; Gnome::Gio::Task \)
</pre><ul>
<li><p>$source-object; the <strong>Gnome::GObject::Object</strong> that owns this task, or undefined..</p></li>
<li><p>$cancellable; optional <strong>Gnome::Gio::Cancellable</strong> object, undefined to ignore..</p></li>
<li><p>GAsyncReadyCallback &amp;callback; a <strong>Gnome::Gio::T-iotypes</strong>.. The function must be specified with the following signature; <code>:( N-Object $source-object, N-Object $res, gpointer $data )</code>.</p></li>
<li><p>$callback-data; user data passed to <code>$callback</code>..</p></li>
</ul>
</section>
<section name="pod">
<h1 id="Methods"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Methods</a></h1>
</section>
<section name="pod">
<h2 id="attach-source"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">attach-source</a></h2>
<p>A utility function for dealing with async operations where you need to wait for a <strong>Gnome::Glib::N-Source</strong> to trigger. Attaches <code>$source</code> to <code>$task</code>'s <strong>Gnome::Glib::N-MainContext</strong> with <code>$task</code>'s [priority](iface.AsyncResult.html#io-priority), and sets <code>$source</code>'s callback to <code>$callback</code>, with <code>$task</code> as the callback's <strong>user_data</strong>.</p><p>It will set the <code>$source</code>’s name to the task’s name (as set with <code>.set-name()</code>), if one has been set on the task and the source doesn’t yet have a name.</p><p>This takes a reference on <code>$task</code> until <code>$source</code> is destroyed.</p><pre class="pod-block-code">method attach-source ( N-Object $source, GSourceFunc &amp;callback )
</pre><ul>
<li><p>$source; the source to attach</p></li>
<li><p>GSourceFunc &amp;callback; the callback to invoke when <code>$source</code> triggers. The function must be specified with the following signature; <code>:( gpointer $user-data )</code>.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="get-cancellable"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-cancellable</a></h2>
<p>Gets <code>$task</code>'s <strong>Gnome::Gio::Cancellable</strong></p><pre class="pod-block-code">method get-cancellable (--&gt; N-Object )
</pre><p>Return value; <code>$task</code>'s <strong>Gnome::Gio::Cancellable</strong>. </p></section>
<section name="pod">
<h2 id="get-check-cancellable"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-check-cancellable</a></h2>
<p>Gets <code>$task</code>'s check-cancellable flag. See <code>.set-check-cancellable()</code> for more details.</p><pre class="pod-block-code">method get-check-cancellable (--&gt; Bool )
</pre><p>Return value; No documentation about its value and use. </p></section>
<section name="pod">
<h2 id="get-completed"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-completed</a></h2>
<p>Gets the value of <strong>Gnome::Gio::Task</strong>:completed. This changes from <code>False</code> to <code>True</code> after the task’s callback is invoked, and will return <code>False</code> if called from inside the callback.</p><pre class="pod-block-code">method get-completed (--&gt; Bool )
</pre><p>Return value; <code>True</code> if the task has completed, <code>False</code> otherwise.. </p></section>
<section name="pod">
<h2 id="get-context"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-context</a></h2>
<p>Gets the <strong>Gnome::Glib::N-MainContext</strong> that <code>$task</code> will return its result in (that is, the context that was the thread-default main context at the point when <code>$task</code> was created).</p><p>This will always return a non-undefined value, even if the task's context is the default <strong>Gnome::Glib::N-MainContext</strong>.</p><pre class="pod-block-code">method get-context (--&gt; N-Object )
</pre><p>Return value; <code>$task</code>'s <strong>Gnome::Glib::N-MainContext</strong>. </p></section>
<section name="pod">
<h2 id="get-name"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-name</a></h2>
<p>Gets <code>$task</code>’s name. See <code>.set-name()</code>.</p><pre class="pod-block-code">method get-name (--&gt; Str )
</pre><p>Return value; <code>$task</code>’s name, or undefined. </p></section>
<section name="pod">
<h2 id="get-priority"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-priority</a></h2>
<p>Gets <code>$task</code>'s priority</p><pre class="pod-block-code">method get-priority (--&gt; Int )
</pre><p>Return value; <code>$task</code>'s priority. </p></section>
<section name="pod">
<h2 id="get-return-on-cancel"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-return-on-cancel</a></h2>
<p>Gets <code>$task</code>'s return-on-cancel flag. See <code>.set-return-on-cancel()</code> for more details.</p><pre class="pod-block-code">method get-return-on-cancel (--&gt; Bool )
</pre><p>Return value; No documentation about its value and use. </p></section>
<section name="pod">
<h2 id="get-source-object"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-source-object</a></h2>
<p>Gets the source object from <code>$task</code>. Like g_async_result_get_source_object(), but does not ref the object.</p><pre class="pod-block-code">method get-source-object (--&gt; gpointer )
</pre><p>Return value; <code>$task</code>'s source object, or undefined. </p></section>
<section name="pod">
<h2 id="get-source-tag"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-source-tag</a></h2>
<p>Gets <code>$task</code>'s source tag. See <code>.set-source-tag()</code>.</p><pre class="pod-block-code">method get-source-tag (--&gt; gpointer )
</pre><p>Return value; <code>$task</code>'s source tag. </p></section>
<section name="pod">
<h2 id="get-task-data"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">get-task-data</a></h2>
<p>Gets <code>$task</code>'s <strong>task_data</strong>.</p><pre class="pod-block-code">method get-task-data (--&gt; gpointer )
</pre><p>Return value; <code>$task</code>'s <strong>task_data</strong>.. </p></section>
<section name="pod">
<h2 id="had-error"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">had-error</a></h2>
<p>Tests if <code>$task</code> resulted in an error.</p><pre class="pod-block-code">method had-error (--&gt; Bool )
</pre><p>Return value; <code>True</code> if the task resulted in an error, <code>False</code> otherwise.. </p></section>
<section name="pod">
<h2 id="propagate-boolean"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">propagate-boolean</a></h2>
<p>Gets the result of <code>$task</code> as a #gboolean.</p><p>If the task resulted in an error, or was cancelled, then this will instead return <code>False</code> and set <code>$error</code>.</p><p>Since this method transfers ownership of the return value (or error) to the caller, you may only call it once.</p><pre class="pod-block-code">method propagate-boolean ( CArray[N-Error] $err --&gt; Bool )
</pre><ul>
<li><p>$err; Error object. When defined, an error can be returned when there is one. Use <code>Pointer</code> when you want to ignore the error. .</p></li>
</ul>
<p>Return value; the task result, or <code>False</code> on error. </p></section>
<section name="pod">
<h2 id="propagate-int"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">propagate-int</a></h2>
<p>Gets the result of <code>$task</code> as an integer (#gssize).</p><p>If the task resulted in an error, or was cancelled, then this will instead return -1 and set <code>$error</code>.</p><p>Since this method transfers ownership of the return value (or error) to the caller, you may only call it once.</p><pre class="pod-block-code">method propagate-int ( CArray[N-Error] $err --&gt; Int )
</pre><ul>
<li><p>$err; Error object. When defined, an error can be returned when there is one. Use <code>Pointer</code> when you want to ignore the error. .</p></li>
</ul>
<p>Return value; the task result, or -1 on error. </p></section>
<section name="pod">
<h2 id="propagate-pointer"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">propagate-pointer</a></h2>
<p>Gets the result of <code>$task</code> as a pointer, and transfers ownership of that value to the caller.</p><p>If the task resulted in an error, or was cancelled, then this will instead return undefined and set <code>$error</code>.</p><p>Since this method transfers ownership of the return value (or error) to the caller, you may only call it once.</p><pre class="pod-block-code">method propagate-pointer ( CArray[N-Error] $err --&gt; gpointer )
</pre><ul>
<li><p>$err; Error object. When defined, an error can be returned when there is one. Use <code>Pointer</code> when you want to ignore the error. .</p></li>
</ul>
<p>Return value; the task result, or undefined on error. </p></section>
<section name="pod">
<h2 id="propagate-value"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">propagate-value</a></h2>
<p>Gets the result of <code>$task</code> as a <strong>Gnome::GObject::N-Value</strong>, and transfers ownership of that value to the caller. As with <code>.return-value()</code>, this is a generic low-level method; <code>.propagate-pointer()</code> and the like will usually be more useful for C code.</p><p>If the task resulted in an error, or was cancelled, then this will instead set <code>$error</code> and return <code>False</code>.</p><p>Since this method transfers ownership of the return value (or error) to the caller, you may only call it once.</p><pre class="pod-block-code">method propagate-value ( N-Object $value, CArray[N-Error] $err --&gt; Bool )
</pre><ul>
<li><p>$value; return location for the <strong>Gnome::GObject::N-Value</strong></p></li>
<li><p>$err; Error object. When defined, an error can be returned when there is one. Use <code>Pointer</code> when you want to ignore the error. .</p></li>
</ul>
<p>Return value; <code>True</code> if <code>$task</code> succeeded, <code>False</code> on error.. </p></section>
<section name="pod">
<h2 id="return-boolean"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-boolean</a></h2>
<p>Sets <code>$task</code>'s result to <code>$result</code> and completes the task (see <code>.return-pointer()</code> for more discussion of exactly what this means).</p><pre class="pod-block-code">method return-boolean ( Bool() $result )
</pre><ul>
<li><p>$result; the #gboolean result of a task function..</p></li>
</ul>
</section>
<section name="pod">
<h2 id="return-error"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-error</a></h2>
<p>Sets <code>$task</code>'s result to <code>$error</code> (which <code>$task</code> assumes ownership of) and completes the task (see <code>.return-pointer()</code> for more discussion of exactly what this means).</p><p>Note that since the task takes ownership of <code>$error</code>, and since the task may be completed before returning from <code>.return-error()</code>, you cannot assume that <code>$error</code> is still valid after calling this. Call g_error_copy() on the error if you need to keep a local copy as well.</p><p>See also <code>.return-new-error()</code>, <code>.return-new-error-literal()</code>.</p><pre class="pod-block-code">method return-error ( N-Object $error )
</pre><ul>
<li><p>$error; (transfer ownership: full) the <strong>Gnome::Glib::N-Error</strong> result of a task function.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="return-error-if-cancelled"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-error-if-cancelled</a></h2>
<p>Checks if <code>$task</code>'s <strong>Gnome::Gio::Cancellable</strong> has been cancelled, and if so, sets <code>$task</code>'s error accordingly and completes the task (see <code>.return-pointer()</code> for more discussion of exactly what this means).</p><pre class="pod-block-code">method return-error-if-cancelled (--&gt; Bool )
</pre><p>Return value; <code>True</code> if <code>$task</code> has been cancelled, <code>False</code> if not. </p></section>
<section name="pod">
<h2 id="return-int"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-int</a></h2>
<p>Sets <code>$task</code>'s result to <code>$result</code> and completes the task (see <code>.return-pointer()</code> for more discussion of exactly what this means).</p><pre class="pod-block-code">method return-int ( Int() $result )
</pre><ul>
<li><p>$result; the integer (#gssize) result of a task function..</p></li>
</ul>
</section>
<section name="pod">
<h2 id="return-new-error_This_function_is_not_yet_available"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-new-error This function is not yet available</a></h2>
<p>Sets <code>$task</code>'s result to a new <strong>Gnome::Glib::N-Error</strong> created from <code>$domain</code>, <code>$code</code>, <code>$format</code>, and the remaining arguments, and completes the task (see <code>.return-pointer()</code> for more discussion of exactly what this means).</p><p>See also <code>.return-error()</code>.</p><pre class="pod-block-code">method return-new-error ( UInt $domain, Int() $code, Str $format, … )
</pre><ul>
<li><p>$domain; a <strong>Gnome::Glib::Task</strong>..</p></li>
<li><p>$code; an error code..</p></li>
<li><p>$format; a string with format characters..</p></li>
<li><p>…; …. Note that each argument must be specified as a type followed by its value!</p></li>
</ul>
</section>
<section name="pod">
<h2 id="return-new-error-literal"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-new-error-literal</a></h2>
<p>Sets <code>$task</code>’s result to a new [type <code>$GLib</code>.Error] created from <code>$domain</code>, <code>$code</code>, <code>$message</code> and completes the task.</p><p>See <code>.return-pointer()</code> for more discussion of exactly what ‘completing the task’ means.</p><p>See also <code>.return-new-error()</code>.</p><pre class="pod-block-code">method return-new-error-literal ( UInt $domain, Int() $code, Str $message )
</pre><ul>
<li><p>$domain; a <strong>Gnome::Glib::Task</strong>..</p></li>
<li><p>$code; an error code..</p></li>
<li><p>$message; an error message.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="return-pointer"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-pointer</a></h2>
<p>Sets <code>$task</code>'s result to <code>$result</code> and completes the task. If <code>$result</code> is defined, then <code>$result-destroy</code> will be used to free <code>$result</code> if the caller does not take ownership of it with <code>.propagate-pointer()</code>.</p><p>&quot;Completes the task&quot; means that for an ordinary asynchronous task it will either invoke the task's callback, or else queue that callback to be invoked in the proper <strong>Gnome::Glib::N-MainContext</strong>, or in the next iteration of the current <strong>Gnome::Glib::N-MainContext</strong>. For a task run via <code>.run-in-thread()</code> or <code>.run-in-thread-sync()</code>, calling this method will save <code>$result</code> to be returned to the caller later, but the task will not actually be completed until the <strong>Gnome::Gio::T-task</strong> exits.</p><p>Note that since the task may be completed before returning from <code>.return-pointer()</code>, you cannot assume that <code>$result</code> is still valid after calling this, unless you are still holding another reference on it.</p><pre class="pod-block-code">method return-pointer ( gpointer $result, GDestroyNotify &amp;result-destroy )
</pre><ul>
<li><p>$result; (transfer ownership: full) the pointer result of a task function.</p></li>
<li><p>GDestroyNotify &amp;result-destroy; a <strong>Gnome::Glib::T-types</strong> function.. The function must be specified with the following signature; <code>:( gpointer $data )</code>.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="return-prefixed-error_This_function_is_not_yet_available"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-prefixed-error This function is not yet available</a></h2>
<p>Sets <code>$task</code>'s result to <code>$error</code> (which <code>$task</code> assumes ownership of), with the message prefixed according to <code>$format</code>, and completes the task (see <code>.return-pointer()</code> for more discussion of exactly what this means).</p><p>Note that since the task takes ownership of <code>$error</code>, and since the task may be completed before returning from <code>.return-prefixed-error()</code>, you cannot assume that <code>$error</code> is still valid after calling this. Call g_error_copy() on the error if you need to keep a local copy as well.</p><p>See also <code>.return-error()</code>, g_prefix_error().</p><pre class="pod-block-code">method return-prefixed-error ( N-Object $error, Str $format, … )
</pre><ul>
<li><p>$error; (transfer ownership: full) the <strong>Gnome::Glib::N-Error</strong> result of a task function.</p></li>
<li><p>$format; a string with format characters..</p></li>
<li><p>…; …. Note that each argument must be specified as a type followed by its value!</p></li>
</ul>
</section>
<section name="pod">
<h2 id="return-value"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">return-value</a></h2>
<p>Sets <code>$task</code>'s result to <code>$result</code> (by copying it) and completes the task.</p><p>If <code>$result</code> is undefined then a <strong>Gnome::GObject::N-Value</strong> of type <code>G_TYPE_POINTER</code> with a value of undefined will be used for the result.</p><p>This is a very generic low-level method intended primarily for use by language bindings; for C code, <code>.return-pointer()</code> and the like will normally be much easier to use.</p><pre class="pod-block-code">method return-value ( N-Object $result )
</pre><ul>
<li><p>$result; the <strong>Gnome::GObject::N-Value</strong> result of a task function</p></li>
</ul>
</section>
<section name="pod">
<h2 id="run-in-thread"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">run-in-thread</a></h2>
<p>Runs <code>$task-func</code> in another thread. When <code>$task-func</code> returns, <code>$task</code>'s <strong>Gnome::Gio::T-iotypes</strong> will be invoked in <code>$task</code>'s <strong>Gnome::Glib::N-MainContext</strong>.</p><p>This takes a ref on <code>$task</code> until the task completes.</p><p>See <strong>Gnome::Gio::T-task</strong> for more details about how <code>$task-func</code> is handled.</p><p>Although GLib currently rate-limits the tasks queued via <code>.run-in-thread()</code>, you should not assume that it will always do this. If you have a very large number of tasks to run (several tens of tasks), but don't want them to all run at once, you should only queue a limited number of them (around ten) at a time.</p><p>Be aware that if your task depends on other tasks to complete, use of this function could lead to a livelock if the other tasks also use this function and enough of them (around 10) execute in a dependency chain, as that will exhaust the thread pool. If this situation is possible, consider using a separate worker thread or thread pool explicitly, rather than using <code>.run-in-thread()</code>.</p><pre class="pod-block-code">method run-in-thread ( GTaskThreadFunc &amp;task-func )
</pre><ul>
<li><p>GTaskThreadFunc &amp;task-func; a <strong>Gnome::Gio::T-task</strong>. The function must be specified with the following signature; <code>:( N-Object $task, gpointer $source-object, gpointer $task-data, N-Object $cancellable )</code>.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="run-in-thread-sync"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">run-in-thread-sync</a></h2>
<p>Runs <code>$task-func</code> in another thread, and waits for it to return or be cancelled. You can use <code>.propagate-pointer()</code>, etc, afterward to get the result of <code>$task-func</code>.</p><p>See <strong>Gnome::Gio::T-task</strong> for more details about how <code>$task-func</code> is handled.</p><p>Normally this is used with tasks created with a undefined <strong>callback</strong>, but note that even if the task does have a callback, it will not be invoked when <code>$task-func</code> returns. <strong>Gnome::Gio::Task</strong>:completed will be set to <code>True</code> just before this function returns.</p><p>Although GLib currently rate-limits the tasks queued via <code>.run-in-thread-sync()</code>, you should not assume that it will always do this. If you have a very large number of tasks to run, but don't want them to all run at once, you should only queue a limited number of them at a time.</p><pre class="pod-block-code">method run-in-thread-sync ( GTaskThreadFunc &amp;task-func )
</pre><ul>
<li><p>GTaskThreadFunc &amp;task-func; a <strong>Gnome::Gio::T-task</strong>. The function must be specified with the following signature; <code>:( N-Object $task, gpointer $source-object, gpointer $task-data, N-Object $cancellable )</code>.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="set-check-cancellable"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">set-check-cancellable</a></h2>
<p>Sets or clears <code>$task</code>'s check-cancellable flag. If this is <code>True</code> (the default), then <code>.propagate-pointer()</code>, etc, and <code>.had-error()</code> will check the task's <strong>Gnome::Gio::Cancellable</strong> first, and if it has been cancelled, then they will consider the task to have returned an &quot;Operation was cancelled&quot; error (<code>G_IO_ERROR_CANCELLED</code>), regardless of any other error or return value the task may have had.</p><p>If <code>$check-cancellable</code> is <code>False</code>, then the <strong>Gnome::Gio::Task</strong> will not check the cancellable itself, and it is up to <code>$task</code>'s owner to do this (eg, via <code>.return-error-if-cancelled()</code>).</p><p>If you are using <code>.set-return-on-cancel()</code> as well, then you must leave check-cancellable set <code>True</code>.</p><pre class="pod-block-code">method set-check-cancellable ( Bool() $check-cancellable )
</pre><ul>
<li><p>$check-cancellable; whether <strong>Gnome::Gio::Task</strong> will check the state of its <strong>Gnome::Gio::Cancellable</strong> for you..</p></li>
</ul>
</section>
<section name="pod">
<h2 id="set-name"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">set-name</a></h2>
<p>Sets <code>$task</code>’s name, used in debugging and profiling. The name defaults to undefined.</p><p>The task name should describe in a human readable way what the task does. For example, ‘Open file’ or ‘Connect to network host’. It is used to set the name of the <strong>Gnome::Glib::N-Source</strong> used for idle completion of the task.</p><p>This function may only be called before the <code>$task</code> is first used in a thread other than the one it was constructed in. It is called automatically by <code>.set-source-tag()</code> if not called already.</p><pre class="pod-block-code">method set-name ( Str $name )
</pre><ul>
<li><p>$name; a human readable name for the task, or undefined to unset it.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="set-priority"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">set-priority</a></h2>
<p>Sets <code>$task</code>'s priority. If you do not call this, it will default to <code>G_PRIORITY_DEFAULT</code>.</p><p>This will affect the priority of <strong>GSources</strong> created with <code>.attach-source()</code> and the scheduling of tasks run in threads, and can also be explicitly retrieved later via <code>.get-priority()</code>.</p><pre class="pod-block-code">method set-priority ( Int() $priority )
</pre><ul>
<li><p>$priority; the [priority](iface.AsyncResult.html#io-priority) of the request.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="set-return-on-cancel"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">set-return-on-cancel</a></h2>
<p>Sets or clears <code>$task</code>'s return-on-cancel flag. This is only meaningful for tasks run via <code>.run-in-thread()</code> or <code>.run-in-thread-sync()</code>.</p><p>If <code>$return-on-cancel</code> is <code>True</code>, then cancelling <code>$task</code>'s <strong>Gnome::Gio::Cancellable</strong> will immediately cause it to return, as though the task's <strong>Gnome::Gio::T-task</strong> had called <code>.return-error-if-cancelled()</code> and then returned.</p><p>This allows you to create a cancellable wrapper around an uninterruptible function. The <strong>Gnome::Gio::T-task</strong> just needs to be careful that it does not modify any externally-visible state after it has been cancelled. To do that, the thread should call <code>.set-return-on-cancel()</code> again to (atomically) set return-on-cancel <code>False</code> before making externally-visible changes; if the task gets cancelled before the return-on-cancel flag could be changed, <code>.set-return-on-cancel()</code> will indicate this by returning <code>False</code>.</p><p>You can disable and re-enable this flag multiple times if you wish. If the task's <strong>Gnome::Gio::Cancellable</strong> is cancelled while return-on-cancel is <code>False</code>, then calling <code>.set-return-on-cancel()</code> to set it <code>True</code> again will cause the task to be cancelled at that point.</p><p>If the task's <strong>Gnome::Gio::Cancellable</strong> is already cancelled before you call <code>.run-in-thread()</code>/<code>.run-in-thread-sync()</code>, then the <strong>Gnome::Gio::T-task</strong> will still be run (for consistency), but the task will also be completed right away.</p><pre class="pod-block-code">method set-return-on-cancel ( Bool() $return-on-cancel --&gt; Bool )
</pre><ul>
<li><p>$return-on-cancel; whether the task returns automatically when it is cancelled..</p></li>
</ul>
<p>Return value; <code>True</code> if <code>$task</code>'s return-on-cancel flag was changed to match <code>$return-on-cancel</code>. <code>False</code> if <code>$task</code> has already been cancelled.. </p></section>
<section name="pod">
<h2 id="set-source-tag"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">set-source-tag</a></h2>
<p>Sets <code>$task</code>'s source tag.</p><p>You can use this to tag a task return value with a particular pointer (usually a pointer to the function doing the tagging) and then later check it using <code>.get-source-tag()</code> (or g_async_result_is_tagged()) in the task's &quot;finish&quot; function, to figure out if the response came from a particular place.</p><p>A macro wrapper around this function will automatically set the task’s name to the string form of <code>$source-tag</code> if it’s not already set, for convenience.</p><pre class="pod-block-code">method set-source-tag ( gpointer $source-tag )
</pre><ul>
<li><p>$source-tag; an opaque pointer indicating the source of this task.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="set-static-name"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">set-static-name</a></h2>
<p>Sets <code>$task</code>’s name, used in debugging and profiling.</p><p>This is a variant of <code>.set-name()</code> that avoids copying <code>$name</code>.</p><pre class="pod-block-code">method set-static-name ( Str $name )
</pre><ul>
<li><p>$name; a human readable name for the task. Must be a string literal.</p></li>
</ul>
</section>
<section name="pod">
<h2 id="set-task-data"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">set-task-data</a></h2>
<p>Sets <code>$task</code>'s task data (freeing the existing task data, if any).</p><pre class="pod-block-code">method set-task-data ( gpointer $task-data, GDestroyNotify &amp;task-data-destroy )
</pre><ul>
<li><p>$task-data; task-specific data.</p></li>
<li><p>GDestroyNotify &amp;task-data-destroy; <strong>Gnome::Glib::T-types</strong> for <code>$task-data</code>. The function must be specified with the following signature; <code>:( gpointer $data )</code>.</p></li>
</ul>
</section>
<section name="pod">
<h1 id="Functions"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">Functions</a></h1>
</section>
<section name="pod">
<h2 id="is-valid"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">is-valid</a></h2>
<p>Checks that <code>$result</code> is a <strong>Gnome::Gio::Task</strong>, and that <code>$source-object</code> is its source object (or that <code>$source-object</code> is undefined and <code>$result</code> has no source object). This can be used in g_return_if_fail() checks.</p><pre class="pod-block-code">method is-valid ( gpointer $result, gpointer $source-object --&gt; Bool )
</pre><ul>
<li><p>$result; A <strong>Gnome::Gio::R-AsyncResult</strong>.</p></li>
<li><p>$source-object; the source object expected to be associated with the task.</p></li>
</ul>
<p>Return value; <code>True</code> if <code>$result</code> and <code>$source-object</code> are valid, <code>False</code> if not. </p></section>
<section name="pod">
<h2 id="report-error"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">report-error</a></h2>
<p>Creates a <strong>Gnome::Gio::Task</strong> and then immediately calls <code>.return-error()</code> on it. Use this in the wrapper function of an asynchronous method when you want to avoid even calling the virtual method. You can then use g_async_result_is_tagged() in the finish method wrapper to check if the result there is tagged as having been created by the wrapper method, and deal with it appropriately if so.</p><p>See also <code>.report-new-error()</code>.</p><pre class="pod-block-code">method report-error ( gpointer $source-object, GAsyncReadyCallback &amp;callback, gpointer $callback-data, gpointer $source-tag, N-Object $error )
</pre><ul>
<li><p>$source-object; the <strong>Gnome::GObject::Object</strong> that owns this task, or undefined..</p></li>
<li><p>GAsyncReadyCallback &amp;callback; a <strong>Gnome::Gio::T-iotypes</strong>.. The function must be specified with the following signature; <code>:( N-Object $source-object, N-Object $res, gpointer $data )</code>.</p></li>
<li><p>$callback-data; user data passed to <code>$callback</code>..</p></li>
<li><p>$source-tag; an opaque pointer indicating the source of this task.</p></li>
<li><p>$error; (transfer ownership: full) error to report</p></li>
</ul>
</section>
<section name="pod">
<h2 id="report-new-error_This_function_is_not_yet_available"><a href="#Gnome::Gio::Task" class="u" title="go to top of document">report-new-error This function is not yet available</a></h2>
<p>Creates a <strong>Gnome::Gio::Task</strong> and then immediately calls <code>.return-new-error()</code> on it. Use this in the wrapper function of an asynchronous method when you want to avoid even calling the virtual method. You can then use g_async_result_is_tagged() in the finish method wrapper to check if the result there is tagged as having been created by the wrapper method, and deal with it appropriately if so.</p><p>See also <code>.report-error()</code>.</p><pre class="pod-block-code">method report-new-error ( gpointer $source-object, GAsyncReadyCallback &amp;callback, gpointer $callback-data, gpointer $source-tag, UInt $domain, Int() $code, Str $format, … )
</pre><ul>
<li><p>$source-object; the <strong>Gnome::GObject::Object</strong> that owns this task, or undefined..</p></li>
<li><p>GAsyncReadyCallback &amp;callback; a <strong>Gnome::Gio::T-iotypes</strong>.. The function must be specified with the following signature; <code>:( N-Object $source-object, N-Object $res, gpointer $data )</code>.</p></li>
<li><p>$callback-data; user data passed to <code>$callback</code>..</p></li>
<li><p>$source-tag; an opaque pointer indicating the source of this task.</p></li>
<li><p>$domain; a <strong>Gnome::Glib::Task</strong>..</p></li>
<li><p>$code; an error code..</p></li>
<li><p>$format; a string with format characters..</p></li>
<li><p>…; …. Note that each argument must be specified as a type followed by its value!</p></li>
</ul>
</section>		</div>
</div><footer><div>Rendered from <span class="path">/home/marcel/Languages/Raku/Projects/gnome-source-skim-tool/gnome-api2/gnome-gio/doc/Task.rakudoc</span></div><div>at <span class="time">2025-04-15T13:41:36Z</span></div></footer>
	</body>
</html>
